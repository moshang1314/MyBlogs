# 请你来写个函数在`main`函数执行前先执行

> ```c++
> //第一种：gcc扩展，标记这个函数应当在main函数之前执行。同样有一个__attribute((destructor)),标记函数应当在程序结束之前（main函数结束之后，或者调用了exit后）执行；
> __attribute((constructor)) void before(){
> 	printf("before main 1\n");
> }
> 
> //第二种：全局 static变量的初始化在程序初始阶段，先于main函数的执行
> int test1(){
> 	cout << "before main 2" << endl;
> 	return 1;
> }
> static int i = test1();
> //第三种
> int a = [](){
> 	cout << "before main  3" << endl;
> 	return 0;
> }();
> 
> int main(int argc, char** argv){
> 	cout << "main function" << endl;
> 	return 0;
> }
> ```

# C++模板是什么，底层怎么实现的？

> 编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那么编译器无法实例化该模板，最终导致链接错误。

# 复现`memcpy()`和`memmove()`

> 当内存内容复制过程中，源地址空间与目的地址空间重叠，会发生错误，若按从前往后按字节拷贝，则先拷贝的数据会覆盖掉未拷贝的数据。因此，当`dest`的地址小于`src`的地址的时候我们应该采用从前往后拷贝，当`dest`的地址大于`src`但是小于`src+count`时我们应该采用从后往前拷贝，当我们的`dest`大于`src+count`时从前往后拷贝和从后往前拷贝都可以。`memcpy`没有考虑内存重叠问题，`memmove`考虑了。
>
> ```c++
> //模拟实现memcpy函数
> void* memcpy(void *dest, void *src, size_t num){
>     void *ret = dest;
>     size_t i = 0;
>     assert(dest != NULL);
>     assert(src != NULL);
>     for(i = 0; i < num; i++){
>         //因为void*不能直接解引用，所以需要强转成char*再来解引用
>         *(char*) dest = *(char*) src;
>         dest = (char*)dest + 1;
>         src = (char*)src + 1;
>     }
>     return ret;
> }
> 
> //考虑内存重叠的memmove函数
> void* memmove(void *dest, void *src, size_t num){
>     char *p1 = (char*)dest;
>     char *p2 = (char*)src;
>     if(p1 < p2){
>         for(size_t i = 0; i < num; ++i)
>             *(p1++) = *(p2++);
>     }
>     else{
>         p1 += num - 1;
>         p2 += num - 1;
>         for(size_t i = 0; i < num; ++i)
>             *(p1--) = *(p2--);
>     }
>     return dest;
> }
> ```

# 构造函数和析构函数可否抛出异常

> ​	C++只会析构已经完成的对象，对象只有 在其构造函数执行完毕才算是完全构造完成。在构造函数中发生异常，控制权转出构造函数之外。因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此可能造成内存泄漏。
>
> ​	用智能指针来管理指针成员，可以有效解决抛出异常时发生资源泄漏的危机。
>
> ​	如果控制权基于异常的因素离开，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束；
>
> ​	如果异常从析构函抛出，而且没有在当地进行捕捉，那这个析构函数便是执行不全的。如果析构函数执行不全，可能发生内存泄漏的风险。

# 数据库引擎，`innodb`和`myisam`的特点与区别

> 	1) `innodb`引擎提供了对数据库`ACID`事务的支持，并且实现了SQL标准的四种隔离级别。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统。MySQL运行时`innodb`会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持`fulltext`类型，而且它没有保存表的行数，当`select count(*) from tabel;`时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用`innodb`引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，`innodb`表同样会锁定全表。
> 	1) `MyISAM`是MySQL默认的引擎，但是它没有提供对数据库事务的支持，**也不支持行级锁和外键约束，**因此当`insert`或`update`数据时需要锁定整个表，效率便会低一些。不过和`innodb`不同，**`MyISAM`中存储了表的行数**，于是`select count(*) from table;`时只需要读取已经保存好的值而不需要进行全表扫描。**如果表的读操作远远多于写操作且不需要数据库的事务的支持，那么`MyISAM`也是很好的选择。**
> 	1) `MyISAM`和`InnoDB`都是使用的B+树索引，`MyISAM`的主键索引和辅助索引的DATA域都是保存的行数据记录的地址。但是`InnoDB`的主键索引的DATA域存储的是行数据内容，而辅助索引的DATA域则保存的是主键ID。

# 设计模式的六大原则

> 1) **开闭原则：**一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。
> 1) **里氏代换原则**：所有引用基类（父类）的地方必须能透明地使用其子类对象。因此在程序中将使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。
> 1) **依赖倒转原则：**抽象不应该依赖于细节，细节应当依赖于抽象。换言之，**要针对接口编程，而不是针对实现编程。**
> 1) **接口隔离原则：**使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。即每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。
> 1) **迪米特法则：**一个软件实体应当尽可能少地与其它实体发生相互作用。即当其中一个模块发生修改时，尽量少的影响其它模块。
> 1) **合成复用原则：**尽量使用对象组合，而不是继承来达到复用的目的。

# 排序算法总结

> ![image-20230812153606761](https://pic1.xuehuaimg.com/proxy/https://cdn.jsdelivr.net/gh/moshang1314/myBlog@main/image/image-20230812153606761.png)

# 进程调度算法

## 先来先服务（FCFS)调度算法

> ​	先来先服务调度算法是最简单的调度算法。其基本原则是，按照进程进入就绪队列的先后次序进行选择。对于进程调度来说，一旦一个进程得到处理机，它就一直运行下去，直到该进程完成任务或者因等待某事件而不能继续运行，才会让出处理机。先来先服务调度算法属于非剥夺方式。
>
> ​	从表面上看，这个方法对于所有进程都是公平的，并且一个进程的等待时间是可以预先估计的。但是从另一方面来说，这个方法并非公平，因为当一个大进程到达就绪状态时，就会使许多小进程等待很长时间，增加的进程的平均周转时间，会引起许多小进程用户的不满。
>
> ​	先来先服务调度算法已经很少用作主要的调度算法，尤其是分时和实时操作系统中。但它通常被结合在其它的调度算法中使用。例如，在使用优先级作为调度依据的系统中，往往对许多具有相同优先级的进程使用先来先服务的原则。

## 优先级调度算法

> ​	按照继承的优先级高低来进行调度，使高优先级进程优先得到处理机的调度算法称为优先级调度算法。进程的优先级可以由操作系统按一定的原则赋予，也可以在操作系统外部安排，甚至可由用户支付高额费用来购买。
>
> ​	但在许多采用优先级调度算法的系统中，通常使用动态优先级。一个进程的优先级不是固定的，可能会随许多因素的变化而变化，例如，进程的等待时间、已使用的处理机时间或其它资源的使用情况。
>
> ​	优先级调度算法又可以分为下述两种：
>
> * 非剥夺的优先级调度算法。一旦某个高优先级的进程得到处理机，就一直运行下去，直到由于自身的原因（任务完成或等待事件）而主动让出处理机，才让另一个高优先级进程运行。
> * 可剥夺的优先级调度算法。任何时刻都严格按照优先级高的进程在处理机上运行的原则进行调度，或者说，在处理机上运行的进程永远是就绪进程队列中优先级最高的进程。在进程运行过程中，一旦有另一个优先级更高的进程出现（如一个高优先级的等待状态进程因事件的到来而成为了就绪状态），进程调度程序就迫使原运行的进程让出处理机给更高优先级的进程使用，或称为抢占处理机。在UNIX系统中其进程调度算法属于“可剥夺的优先级调度算法”。每个进程的优先级都是动态优先级，由系统为各进程每隔一个时间间隔计算一次优先级。

## 时间片轮转调度算法

> ​	采用此算法的操作系统中，其进程就绪队列往往按进程到达时间来排序。进程调度程序总是选择就绪队列中的第一个进程，也就是说，按先来先服务原则进行调度，但进程仅占用处理机的一个时间片。在使用完一个时间片后，即使进程还没有完成其运行，它也必须让出（被剥夺）处理机给下一个就绪的进程。而被剥夺的进程返回就绪队列的末尾重新排队，等候再次运行。时间片轮转调度算法特别适合分时操作系统使用。当多个进程驻留主存时，在进程间转接的开销一般不是很大。
>
> ​	由于时间片值对计算机系统的有效操作影响很大，所以在设计此算法时，要考虑下列问题：时间片值如何选择？它是固定值还是可变值？它对所有用户都相同还是随不同用户而不同？显然，如果时间片很大，大到一个进程足以完成其全部任务所需的时间，那么此时间片轮转调度算法就退化为了先来先服务调度算法了。如果时间片很小，那么处理机在进程间的切换工作过于频繁，使处理机的开销变得很大，而处理机真正用于运行用户程序的时间将会减少。通常，最佳时间片值应能使分时用户得到好的响应时间，因此时间片值应大于大多数分时用户的询问时间，即当一个交互进程正在执行时，给它的时间片值相对来说略大一些，使它足以产生一个IO请求；或者时间片值略大于大多数进程从计算到IO请求之间的间隔时间。这样可使用户进程工作在最高速度上，并且也减少了进程切换的不必要的开销，提高了处理机和I/O设备的利用率，同时也能提供友好的响应时间。
>
> ​	特别要注意的是，时间片是否用完的判定是由时钟中断处理程序激活的，因此时间片值必须大于时钟中断间隔。

## 短进程优先（SPF）调度算法

> 短进程优先调度算法从进程就绪队列中挑选那些运行时间（估计时间）最短的进程进入主存运行。这是一个非剥夺算法。它一旦选中某个短进程，就应该保证该进程尽可能快地完成运行并退出系统。这样减少了在就绪队列中等待的进程数，同时野缩短了进程的平均等待时间，提高了系统的吞吐量。但从另一方面来说，各进程的等待时间的变化范围较大，并且进程（尤其是大进程）的等待时间难以预先估计。也就是说，用户对他的进程什么时候完成心里没底。这样，当后续短进程过多时，大进程可能没有机会运行，导致“饿死”。而在先来先服务调度算法中，进程的等待和完成时间是可以预期的。
>
> 短进程优先调度算法要求事先能正确地了解一道作业或进程将运行多长时间。但通常一个进程没有这方面可供使用的信息，只能估计。在生产环境中，对于一道类似的作业可以提供大致合理的估计；而在程序开发环境中，用户难以知道他的程序大致将运行多长时间。
> 正因为此算法明显偏向短进程，而且进程的运行时间是估计的，所以用户可能把他的进程运行时间估计得过短，从而争取优先运行。为此，当一个进程的运行时间超过所估计的时间时，系统将停止这个进程，或对超时部分加价收费。
> 短进程优先调度算法和先来先服务调度算法都是非剥夺算法，因此均不适用于分时系统，因为不能保证对用户及时响应。

# 数据库中的函数依赖

> **部分函数依赖**
>
> ​	设$X, Y$是关系$R$的两个属性集合，存在$X->Y$，若$X'$是$X$的真子集，存在$X'->Y$，则称$Y$部分函数依赖于$X$。
>
> ​	例如：通过$AB$能得到$C$，通过$A$也能得出$C$，通过$B$也能得出$C$，那么说$C$部分依赖于$AB$。
>
> **完全函数依赖**
>
> ​	设$X, Y$是关系$R$的两个属性集合，存在$X->Y$，若$X'$是$X$的真子集，对于每一个$X'$都有$X'!->Y$，则称$Y$完全函数依赖于$X$。
>
> ​	例如：通过$AB$能得出$C$，但单独通过$A$和$B$都不能得出$C$，那么说$C$完全函数依赖于$AB$。
>
> **传递函数依赖**
>
> ​	设$X,Y,Z$是关系$R$中互不相同的属性集合，存在$X->Y (Y!->X), Y->Z$则称$Z$传递函数依赖于$X$。
>
> ​	例如：通过$A$能得到$B$，通过$B$能得到$C$，但通过$C$不能得到$B$，通过$B$不能得到$A$，那么$C$传递依赖于$A$。

# 数据库范式

> **范式**，简称NF。要想设计一个好的关系，必须使关系满足一定的约束条件，此约束已经形成了规范，分成几个等级，一级比一级要求严格。满足这些规范的数据是简洁的、结构清晰的，同时，不会发生插入、删除和更新操作异常。反之则是乱七八糟，不仅给数据库的编程人员制造麻烦，而且面目可憎，可能存储了大量的冗余信息。关系型数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯·科德范式（BCNF）、第四范式（4NF）、第五范式（5NF，又称完美范式）。满足最低要求的方式是第一范式（1NF）。在第一范式的基础上进一步满足更多要求的称为第二范式，其余范式以此类推。一般来说，数据库只需要满足了第三范式或者BC范式就可以了。
>
> **第一范式**
>
> ​	若关系模式$R$的每一个分量是不可再分的数据项，属性值都是不可再分的原子值，则关系模式$R$满足第一范式。如下图不属于第一范式。
>
> ![image-20230820133917779](C:/Users/pc/AppData/Roaming/Typora/typora-user-images/image-20230820133917779.png)
>
> **第二范式**：若关系模式$R\in1NF$，且**每一个非主属性完全依赖于主键时**，则关系式$R$满足第二范式（2NF）。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。如果关系模式不符合第二范式，就要拆分为多个关系模式。
>
> **第三范式：**若关系模式$R\in2NF$，即当2NF消除了非主属性对码的传递依赖，则称为3NF，**也就是说非主属性之间不能相互依赖**。
>
> 超键：唯一标识元组的属性或属性集合。
>
> 候选键：超键去除冗余。
>
> 主键：从候选键中选出的一个唯一标识元组。
>
> 外键：其它实体的主键，表示实体间的联系。
>
> 主属性：候选码的诸属性称为主属性。
>
> 非主属性：指不包含在任何一个候选键中的属性。

