# 1 字符串数字乘法

> [43. 字符串相乘 - 力扣（LeetCode）](https://leetcode.cn/problems/multiply-strings/description/)
>
> ```c++
> #include <iostream>
> #include <string>
> 
> using namespace std;
> string multiplyStrings(string num1, string num2){
> 	int len1 = num1.size();
> 	int len2 = num2.size();
> 	string result(len1 + len2, '0');
> 	
> 	for(int i = len1 - 1; i >= 0; i--){
> 		int carry = 0;
> 		int n1 = num1[i] - '0';
> 		
> 		for(int j = len2 - 1; j >= 0; j--){
> 			int n2 = num2[j] - '0';
> 			int product = (result[i + j + 1] - '0') + n1 * n2 + carry;
> 			result[i + j + 1] = product % 10 + '0';
> 			carry = product / 10;
> 		}
>         result[i] += carry;
> 	}
> 	// 移除结果字符串前面的零
>     int startPos = result.find_first_not_of('0');
>     if(startPos != string::npos){
>         return result.substr(startPos);
>     }
>     return "0";
> }
> 
> int main(){
>     string num1 = "123";
>     string num2 = "456";
>     std::string result = multiplyStrings(num1, num2);
>     
>     cout << num1 << " * " << num2 << " = " << result << endl;
> }
> ```

# 2 三数之和



> [LCR 007. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/1fGaJU/)
> 
> ```c++
> #include <iostream>
>#include <vector>
> #include <algorithm>
> 
> using namespace std;
> vector<vector<int>> threeSum( std::vector<int> &nums ) {
>  vector<vector<int>> result;
>  if (nums.size() < 3) {
>      return result;
>     }
>     sort( nums.begin() , nums.end() );
>    
>     for (int i = 0; i < nums.size() - 2; ++i) {
>         if (i > 0 && nums[i] == nums[i - 1]) {
>          continue;
>         }
>    
>         int left = i + 1;
>         int right = nums.size() - 1;
>      while (left < right) {
>             int sum = nums[i] + nums[left] + nums[right];
>             if (sum == 0) {
>                 result.push_back( { nums[i], nums[left], nums[right] } );
>                 while (left < right && nums[left] == nums[left + 1]) {
>                     left++;
>                 }
>                 while (left < right && nums[right] == nums[right - 1]) {
>                     right--;
>                 }
>                 left++;
>                 right--;
>             }
>             else if (sum < 0) {
>                 left++;
>             }
>             else {
>                 right--;
>             }
>         }
>     }
>     return std::move( result );
>    }
>    ```

## 2.1 四数之和

> [力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台](https://leetcode.cn/problems/4sum/submissions/)
>
> ```c++
> class Solution {
> public:
>     vector<vector<int>> fourSum(vector<int>& nums, int target) {
>         sort(nums.begin(), nums.end());
>         vector<vector<int>> result;
>         int n = nums.size();
>         for(int i = 0; i < n; i++){
>             if(i > 0 && nums[i] == nums[i - 1]){
>                 continue;
>             }
>             for(int j = i + 1; j < n; j++){
>                 if(j > i + 1 && nums[j] == nums[j - 1]){
>                     continue;
>                 }
>                 int left = j + 1;
>                 int right = n - 1;
>                 long sum = target - ((long)nums[i] + nums[j]);
>                 while(left < right){
>                     if(nums[left] + nums[right] == sum){
>                         result.push_back({nums[i], nums[j], nums[left], nums[right]});
>                         while(left < right && nums[left] == nums[left + 1]){
>                             left++;
>                         }
>                         while(left < right && nums[right] == nums[right - 1]){
>                             right--;
>                         }
>                         left++;
>                         right--;
>                     }
>                     else if(nums[left] + nums[right] < sum){
>                         left++;
>                     }
>                     else{
>                         right--;
>                     }
>                 }
>             }
>         }
>         return result;
>     }
> };
> ```
>
> **优化**
>
> ```c++
> class Solution {
> public:
>     vector<vector<int>> fourSum(vector<int>& nums, int target) {
>         sort(nums.begin(), nums.end());
>         vector<vector<int>> result;
>         int n = nums.size();
>         if(nums.size() < 4){
>             return result;
>         }
>         for(int i = 0; i < n - 3; i++){
>             if(i > 0 && nums[i] == nums[i - 1]){
>                 continue;
>             }
>             if((long)nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target){
>                 break;
>             }
>             if((long)nums[i] + nums[n - 3] + nums[n - 2] + nums[n - 1] < target){
>                 continue;
>             }
>             for(int j = i + 1; j < n - 2; j++){
>                 if(j > i + 1 && nums[j] == nums[j - 1]){
>                     continue;
>                 }
>                 if((long)nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target){
>                     break;
>                 }
>                 if((long)nums[i] + nums[j] + nums[n - 2] + nums[n - 1] < target){
>                     continue;
>                 }
>                 int left = j + 1;
>                 int right = n - 1;
>                 long sum = target - ((long)nums[i] + nums[j]);
>                 while(left < right){
>                     if(nums[left] + nums[right] == sum){
>                         result.push_back({nums[i], nums[j], nums[left], nums[right]});
>                         while(left < right && nums[left] == nums[left + 1]){
>                             left++;
>                         }
>                         while(left < right && nums[right] == nums[right - 1]){
>                             right--;
>                         }
>                         left++;
>                         right--;
>                     }
>                     else if(nums[left] + nums[right] < sum){
>                         left++;
>                     }
>                     else{
>                         right--;
>                     }
>                 }
>             }
>         }
>         return result;
>     }
> };
> ```

# 3 最长递增子序列问题

> [300. 最长递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence/description/)

## 3.1 动态规划O(n * n)复杂度

> ```c++
> #include <iostream>
> #include <vector>
> using namespace std;
> 
> class Solution {
> public:
>     int lengthOfLIS( vector<int> &nums ) {
>         int n = nums.size();
>         int result = 1;
>         vector<int> dp( n );
>         dp[0] = 1;
>         for (int i = 1; i < n; i++) {
>             dp[i] = 1;
>             for (int j = 0; j < i; j++) {
>                 if (nums[j] < nums[i]) {
>                     dp[i] = max( dp[i] , dp[j] + 1 );
>                 }
>             }
>             result = max( result , dp[i] );
>         }
>         return dp[n - 1];
>     }
> };
> 
> int main() {
>     Solution s;
>     vector<int> vec = { 10, 9, 2, 5, 3, 7, 101, 18 };
>     cout << s.lengthOfLIS( vec ) << endl;
>     return 0;
> }
> ```

## 3.2 优化的动态规划O(n * logn)复杂度（贪心+二分查找）

> 贪心思路：使用一个数组记录每个长度下递增子序列的最后一个元素的最小值，该数组将是一个有序数组，因为长度较长的递增子序列包含了长度较短的递增子序列，因此可以使用二分查找来优化。每个长度下都维护该长度下的最后一个元素为最小值策略，得到的递增子序列长度最长。
>
> ```c++
> #include <iostream>
> #include <vector>
> using namespace std;
> 
> class Solution {
> public:
>     int lengthOfLIS( vector<int> &nums ) {
>         int n = nums.size();
>         int result = 1;
>         vector<int> dp( n + 1);
>         dp[1] = nums[0];
>         int len = 1;
>         for (int i = 1; i < n; i++) {
>             if (nums[i] > dp[len]) {
>                 dp[++len] = nums[i];
>             }
>             int left = 0;
>             int right = len;
>             int pos = 0;
>             int mid = 0;
>             while (left <= right) {
>                 mid = left + ( ( right - left ) >> 1 );
>                 if (nums[mid] < nums[i]) {
>                     pos = mid;
>                     left = mid + 1;
>                 }
>                 else {
>                     right = mid - 1;
>                 }
>             }
>             dp[pos + 1] = nums[i];
>         }
>         return len;
>     }
> };
> 
> int main() {
>     Solution s;
>     vector<int> vec = { 10, 9, 2, 5, 3, 7, 101, 18 };
>     cout << s.lengthOfLIS( vec ) << endl;
>     return 0;
> }
> ```

# 4 有效的括号字符串

> [678. 有效的括号字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-parenthesis-string/description/)

## 4.1 贪心 时间复杂度O(n) 空间复杂度O(n)

> ```c++
> class Solution {
> public:
>     bool checkValidString(string s) {
>         int l_max = 0;
>         int l_min = 0;
>         for(int i = 0; i < s.size(); i++){
>             if(s[i] == '('){
>                 l_max++;
>                 l_min++;
>             }
>             else if(s[i] == ')'){
>                 l_max--;
>                 l_min = max(0, l_min - 1);
>                 if(l_max < 0){
>                     return false;
>                 }
>             }
>             else if(s[i] == '*'){
>                 l_max++;
>                 l_min = max(0, l_min - 1);;
>             }
>         }
>         return l_min == 0;
>     }
> };
> ```

## 4.2 栈

> ```c++
> class Solution {
> public:
>     bool checkValidString(string s) {
>         stack<int> s1;
>         stack<int> s2;
>         for(int i = 0; i < s.size(); i++){
>             if(s[i] == '('){
>                 s1.push(i);
>             }
>             else if(s[i] == ')'){
>                 if(!s1.empty()){
>                     s1.pop();
>                 }
>                 else if(!s2.empty()){
>                     s2.pop();
>                 }
>                 else{
>                     return false;
>                 }
>             }
>             else if(s[i] == '*'){
>                 s2.push(i);
>             }
>         }
>         if(s1.empty()){
>             return true;
>         }
>         else{
>             while(!s1.empty()){
>                 int index1 = s1.top();
>                 if(s2.empty()){
>                     return false;
>                 }
>                 int index2 = s2.top();
>                 if(index2 < index1){
>                     return false;
>                 }
>                 s1.pop();
>                 s2.pop();
>             }
>             return true;
>         }
>     }
> };
> ```

# 5 最长有效括号

> [32. 最长有效括号 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-valid-parentheses/description/)

## 5.1 动态规划

> ```c++
> class Solution {
> public:
>     int longestValidParentheses(string s) {
>         int n = s.size();
>         vector<int> dp(n);
>         int result = 0;
>         for(int i = 1; i < n; i++){
>             if(s[i] == ')' && s[i - 1] == '('){
>                 dp[i] = i > 1 ? dp[i - 2] + 2 : 2;
>             }
>             else if(s[i] == ')' && s[i] == ')'){
>                 if(i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '('){
>                     dp[i] = dp[i - 1] + 2 + (i - dp[i - 1] >= 2 ? dp[i - dp[i - 1] - 2] : 0);
>                 }
>             }
>             result = max(result, dp[i]);
>         }
>         return result;
>     }
> };
> ```

## 5.2 基于栈

> ​	当出现了一个无法匹配的')'时，则有效的括号子串无法跨越该字符。
>
> ```c++
> class Solution {
> public:
>     int longestValidParentheses(string s) {
>         int result = 0;
>         stack<int> st;
>         st.push(-1);
>         for(int i = 0; i < s.size(); i++){
>             if(s[i] == '('){
>                 st.push(i);
>             }
>             else{
>                 st.pop();
>                 if(st.empty()){
>                     st.push(i);
>                 }
>                 else{
>                     result = max(result, i - st.top());
>                 }
>             }
>         }
>         return result;
>     }
> };
> ```

## 5.3 空间优化

> ```c++
> class Solution {
> public:
>     int longestValidParentheses(string s) {
>         int left = 0, right = 0, maxlength = 0;
>         for (int i = 0; i < s.length(); i++) {
>             if (s[i] == '(') {
>                 left++;
>             } else {
>                 right++;
>             }
>             if (left == right) {
>                 maxlength = max(maxlength, 2 * right);
>             } else if (right > left) {
>                 left = right = 0;
>             }
>         }
>         left = right = 0;
>         for (int i = (int)s.length() - 1; i >= 0; i--) {
>             if (s[i] == '(') {
>                 left++;
>             } else {
>                 right++;
>             }
>             if (left == right) {
>                 maxlength = max(maxlength, 2 * left);
>             } else if (left > right) {
>                 left = right = 0;
>             }
>         }
>         return maxlength;
>     }
> };
> ```

# 6 判断一个括号字符串是否有效

## 6.1 双栈 + 贪心

> [2116. 判断一个括号字符串是否有效 - 力扣（LeetCode）](https://leetcode.cn/problems/check-if-a-parentheses-string-can-be-valid/discussion/)
>
> ​	双栈 + 贪心 优先选择1的进行匹配
>
> ```c++
> class Solution {
> public:
>     bool canBeValid(string s, string locked) {
>         stack<int> st1;
>         stack<int> st2;
>         for(int i = 0; i < s.size(); i++){
>             if(locked[i] == '0'){
>                 st2.push(i);
>             }
>             else{
>                 if(s[i] == '('){
>                     st1.push(i);
>                 }
>                 else if(s[i] == ')'){
>                     if(!st1.empty()){
>                         st1.pop();
>                     }
>                     else if(!st2.empty()){
>                         st2.pop();
>                     }
>                     else{
>                         return false;
>                     }
>                 }
>             }
>         }
>         while(!st1.empty() && !st2.empty()){
>             int index1 = st1.top();
>             st1.pop();
>             int index2 = st2.top();
>             st2.pop();
>             if(index2 < index1){
>                 return false;
>             }
>         }
>         if(!st2.empty()){
>             return st2.size() % 2 == 0;
>         }
>         return st1.empty() && st2.empty();
>     }
> };
> ```

## 6.2 维护左括号的可变范围

> ```c++
> class Solution {
> public:
>     bool canBeValid(string s, string locked) {
>         int n = s.size();
>         if((n & 1) == 1) return false;
>         int mn = 0, mx = 0;
>         for(int i = 0; i < s.size(); i++){
>             if(locked[i] == '0'){
>                 mx++;
>                 mn = max(0, mn - 1);
>             }
>             else{
>                 if(s[i] == '('){
>                     mx++;
>                     mn++;
>                 }
>                 else{
>                     mx--;
>                     mn = max(0, mn - 1);
>                 }
>             }
>             if(mx < 0){
>                 return false;
>             }
>             // cout << "mn = " << mn << endl;
>             // cout << "mx = " << mx << endl;
>         }
>         return mn == 0;
>     }
> };
> ```

# 7 使括号有效的最少添加

> [921. 使括号有效的最少添加 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/description/)
>
> ```c++
> class Solution {
> public:
>     int minAddToMakeValid(string s) {
>         int result = 0;
>         int left = 0;
>         for(int i = 0; i < s.size(); i++){
>             if(s[i] == '('){
>                 left++;
>             }
>             if(s[i] == ')'){
>                 if(left == 0){
>                     result++;
>                 }
>                 else{
>                     left--;
>                 }
>             }
>         }
>         result += left;
>         return result;
>     }
> };
> ```

# 8 第K个最小的素数分数

> [786. 第 K 个最小的素数分数 - 力扣（LeetCode）](https://leetcode.cn/problems/k-th-smallest-prime-fraction/description/)

## 优先级队列（小根堆）

> ```c++
> class Solution {
> public:
>     vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {
>         int n = arr.size();
>         auto cmp = [&](const pair<int, int> &p1, const pair<int, int> &p2){
>             return arr[p1.first] * arr[p2.second] > arr[p2.first] * arr[p1.second];
>         };
>         priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> q(cmp);
>         for(int i = 1; i < n; ++i){
>             q.emplace(0, i);
>         }
>         for(int i = 1; i < k; ++i){
>             auto [x, y] = q.top();
>             q.pop();
>             if(x + 1 < y){
>                 q.emplace(x + 1, y);
>             }
>         }
>         return {arr[q.top().first], arr[q.top().second]};
>     }
> };
> ```

# 9 岛屿数量

> [200. 岛屿数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-islands/description/)

## 9.1 深度优先遍历

> ```c++
> class Solution{
> private:
> 	void dfs(vector<vector<char>> &grid, int r, int c){
> 		int nr = grid.size();
> 		int nc = grid[0].size();
> 		grid[r][c] = '0';
> 		if(r - 1 >= 0 && grid[r - 1][c] == '1') dfs(grid, r - 1, c);
> 		if(r + 1 < nr && grid[r + 1][c] == '1') dfs(grid, r + 1, c);
> 		if(c - 1 >= 0 && grid[r][c - 1] == '1') dfs(grid, r, c - 1);
> 		if(c + 1 < mr && grid[r][c + 1] == '1') dfs(grid, r, c + 1);
> 	}
> public:
> 	int numIslands(vector<vector<char> &grid){
> 		int nr = grid.size();
> 		if(!nr) return 0;
> 		int nc = grid[0].size();
> 		
> 		int num_islands = 0;
> 		for(int r = 0; r < nr; ++r){
> 			for(int c = 0; c < nc; ++c){
> 				if(grid[r][c] == '1'){
> 					++num_islands;
> 					dfs(grid, r, c);
> 				}
> 			}
> 		}
> 		
> 		return num_islands;
> 	}
> }
> ```

## 9.2 广度优先遍历

> ```c++
> class Solution {
> public:
>     void bfs(vector<vector<char>> &grid, int x, int y, vector<vector<bool>> &visited){
>         int n = grid.size();
>         int m = grid[0].size();
>         queue<pair<int, int>> q;
>         q.push({x, y});
>         visited[x][y] = true;
>         while(!q.empty()){
>             auto [i, j] = q.front();
>             q.pop();
>             if(i - 1 >= 0 && grid[i - 1][j] == '1' && !visited[i - 1][j]){
>                 q.push({i - 1, j});
>                 visited[i - 1][j] = true;
>             }
>             if(i + 1 < n && grid[i + 1][j] == '1' && !visited[i + 1][j]){
>                 q.push({i + 1, j});
>                 visited[i + 1][j] = true;
>             }
>             if(j - 1 >= 0 && grid[i][j - 1] == '1' && !visited[i][j - 1]){
>                 q.push({i, j - 1});
>                 visited[i][j - 1] = true;
>             }
>             if(j + 1 < m && grid[i][j + 1] == '1' && !visited[i][j + 1]){
>                 q.push({i, j + 1});
>                 visited[i][j + 1] = true;
>             }
>         }
>     }
>     int numIslands(vector<vector<char>>& grid) {
>         int result = 0;
>         int n = grid.size();
>         if(n == 0){
>             return result;
>         }
>         int m = grid[0].size();
>         vector<vector<bool>> visited(n, vector<bool>(m, false));
>         for(int i = 0; i < n; i++){
>             for(int j = 0; j < m; j++){
>                 if(grid[i][j] == '1' && !visited[i][j]){
>                     result++;
>                     bfs(grid, i, j, visited);
>                 }
>             }
>         }
>         return result;
>     }
> };
> ```

# 10 岛屿的最大面积

> [695. 岛屿的最大面积 - 力扣（LeetCode）](https://leetcode.cn/problems/max-area-of-island/description/)

## 10.1 广度优先遍历

> ```c
> class Solution {
> public:
>     int maxAreaOfIsland(vector<vector<int>>& grid) {
>         int result = 0;
>         int n = grid.size();
>         if(!n){
>             return result;
>         }
>         int m = grid[0].size();
>         for(int i = 0; i < n; i++){
>             for(int j = 0; j < m; j++){
>                 if(grid[i][j] == 1){
>                     int count = 1;
>                     grid[i][j] = 0;
>                     queue<pair<int, int>> q;
>                     q.push({i, j});
>                     while(!q.empty()){
>                         auto [x, y] = q.front();
>                         q.pop();
>                         if(x - 1 >= 0 && grid[x - 1][y] == 1){
>                             count++;
>                             grid[x - 1][y] = 0;
>                             q.push({x - 1, y});
>                         }
>                         if(x + 1 < n && grid[x + 1][y] == 1){
>                             count++;
>                             grid[x + 1][y] = 0;
>                             q.push({x + 1, y});
>                         }
>                         if(y - 1 >= 0 && grid[x][y - 1] == 1){
>                             count++;
>                             grid[x][y - 1] = 0;
>                             q.push({x, y - 1});
>                         }
>                         if(y + 1 < m && grid[x][y + 1] == 1){
>                             count++;
>                             grid[x][y + 1] = 0;
>                             q.push({x, y + 1});
>                         }
>                     }
>                     result = max(result, count);
>                 }
>             }
>         }
>         return result;
>     }
> };
> ```

## 10.2 深度优先遍历

> ```c++
> class Solution {
> private:
>     void dfs(vector<vector<int>> &grid, int x, int y, int &count){
>         int n = grid.size();
>         int m = grid[0].size();
>         count++;
>         grid[x][y] = 0;
>         if(x - 1 >= 0 && grid[x - 1][y] == 1){
>             dfs(grid, x - 1, y, count);
>         }
>         if(x + 1 < n && grid[x + 1][y] == 1){
>             dfs(grid, x + 1, y, count);
>         }
>         if(y - 1 >= 0 && grid[x][y - 1] == 1){
>             dfs(grid, x, y - 1, count);
>         }
>         if(y + 1 < m && grid[x][y + 1] == 1){
>             dfs(grid, x, y + 1, count);
>         }
>     }
> public:
>     int maxAreaOfIsland(vector<vector<int>>& grid) {
>         int result = 0;
>         int n = grid.size();
>         if(!n){
>             return result;
>         }
>         int m = grid[0].size();
>         for(int i = 0; i < n; i++){
>             for(int j = 0; j < m; j++){
>                 if(grid[i][j] == 1){
>                     int count = 0;
>                     dfs(grid, i, j, count);
>                     result = max(result, count);
>                 }
>             }
>         }
>         return result;
>     }
> };
> ```

# 11 二叉树的遍历

## 11.1 前序遍历

> [144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
>
> ```c++
> /**
>  * Definition for a binary tree node.
>  * struct TreeNode {
>  *     int val;
>  *     TreeNode *left;
>  *     TreeNode *right;
>  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
>  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
>  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
>  * };
>  */
> class Solution{
> public:
> 	vector<int> preorderTraversal(TreeNode *root){
> 		stack<TreeNode*> st;
>         vector<int> result;
>         if(root == nullptr) return result;
>         st.push(root);
>         while(!st.empty()){
>             TreeNode *node = st.top();
>             result.push_back(node->val);
>             st.pop();
>             if(node->right)
>                 st.push(node->right);
>             if(node->left)
>                 st.push(node->left);
>         }
>         return result;
> 	}
> };
> ```

## 11.2 中序遍历

> [题库 - 力扣 (LeetCode) 全球极客挚爱的技术成长平台](https://leetcode.cn/problemset/all/?search=94&page=1)
>
> ```c++
> class Solution{
> public:
> 	vector<int> inorderTraversal(TreeNode *root){
>         stack<TreeNode*> st;
>         vector<int> result;
>         if(root == nullptr) return result;
>         TreeNode *cur = root;
>         while(cur != nullptr || !st.empty()){
>             if(cur != nullptr){
>                 st.push(cur);
>                 cur = cur->left;
>             }
>             else{
>                 cur = st.top();
>                 st.pop();
>                 result.push_back(cur->val);
>                 cur = cur->right;
>             }
>         }
>         return result;
>     }
> };
> ```

## 11.3 后序遍历

> [145. 二叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/)
>
> ```c++
> class Solution{
> public:
> 	vector<int> postorderTraversal(TreeNode *root){
> 		vector<int> result;
>         if(root == nullptr) return result;
>         TreeNode *cur = root;
>         TreeNode *pre = nullptr;
>         stack<TreeNode*> st;
>         while(cur != nullptr || !st.empty()){
>             if(cur != nullptr){
>                 st.push(cur);
>                 cur = cur->left;
>             }
>             else{
>                 cur = st.top();
>                 if(cur->right == nullptr || cur->right == pre){
>                     result.push(cur->val);
>                     pre = cur;
>                     st.pop();
>                 }
>                 else{
>                     cur = cur->right;
>                 }
>             }
>         }
> 	}
> };
> ```

## 11.4 标记法统一迭代

> **中序遍历**
>
> ```c++
> class Solution{
> public:
> 	vector<int> inorderTraversal(TreeNode *root){
> 		vector<int> result;
> 		stack<TreeNode*> st;
> 		if(root != nullptr) st.push(root);
>         while(!st.empty()){
>             TreeNode *node = st.top();
>             if(node != NULL){
>                 // 将该节点弹出，避免重复操作，下面再将右、中、左节点添加到栈中
>                 st.pop();
>                 if(node->right) st.push(node->right);
>                 st.push(node);	// 添加中节点
>                 st.push(NULL);	// 中节点访问过，但没有处理，加入空节点作为标记
>                 if(node->left) st.push(node->left);
>             }
>             else{	// 只有遇到空节点的时候，才将下一个节点放入结果集
>                 st.pop();
>                 node = st.top();
>                 st.pop();
>                 result.push_back(node->val);
>             }
>         }
>         return result;
> 	}
> }
> ```
>
> **前序遍历**
>
> ```c++
> class Solution{
> public:
> 	vector<int> preorderTraversal(TreeNode *root){
> 		vector<int> result;
>         stack<TreeNode*> st;
>         if(root != NULL) st.push(root);
>         while(!st.empty()){
>             TreeNode *node = st.top();
>             if(node != NULL){
>                 st.pop();
>                 if(node->right) st.push(node->right);
>                 if(node->left) st.push(node->left);
>                 st.push(node);
>                 st.push(NULL);
>             }
>             else{
>                 st.pop();
>                 node = st.top();
>                 st.pop();
>                 result.push_back(node->val);
>             }
>         }
>         return result;
> 	}
> }
> ```
>
> **后序遍历**
>
> ```c++
> class Solution{
> public:
>     vector<int> postorderTraversal(TreeNode *root){
>         vector<int> result;
>         stack<TreeNode*> st;
>         if(root != NULL) st.push(root);
>         while(!st.empty()){
>             TreeNode *node = st.top();
>             if(node != NULL){
>             	st.pop();
>             	st.push(node);
>             	st.push(NULL);
>             	if(node->right) st.push(node->right);
>             	if(node->left) st.push(node->left);  
>             }
>            	else{
>             	st.pop();
>                 node = st.top();
>                 st.pop();
>                 result.push_back(node->val);
>            	}
>         }
>         return result;
>     }
> }
> ```

# 12 数组中两个数的最大异或和

> [421. 数组中两个数的最大异或值 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/description/)

## 12.1 基于哈希表

> ```c++
> class Solution {
>     static const int HIGH_BIT = 30;
> public:
>     int findMaximumXOR(vector<int>& nums) {
>         int x = 0;
>         for(int i = HIGH_BIT; i >= 0; i--){
>             unordered_set<int> uset;
>             for(auto val : nums){
>                 uset.insert(val >> i);
>             }
>             int x_next = (x << 1) + 1;
>             bool found = false;
>             for(auto val : uset){
>                 if(uset.count(val ^ x_next)){
>                     found = true;
>                     break;
>                 }
>             }
>             if(!found){
>                 x = x_next - 1;
>             }
>             else{
>                 x = x_next;
>             }
>         }
>         return x;
>     }
> };
> ```

## 12.2 基于字典树(前缀树)

> ```c++
> class Solution {
> private:
>     static constexpr int HIGH_BIT = 30;
>     struct TrieNode{
>         shared_ptr<TrieNode> left;
>         shared_ptr<TrieNode> right;
>     };
> private:
>     void add(int num){
>         shared_ptr<TrieNode> cur = root;
>         for(int k = HIGH_BIT; k >= 0; --k){
>             int bit = (num >> k) & 1;
>             if(bit == 0){
>                 if(cur->left == nullptr){
>                     cur->left = make_shared<TrieNode>();
>                 }
>                 cur = cur->left;
>             }
>             else{
>                 if(cur->right == nullptr){
>                     cur->right = make_shared<TrieNode>();
>                 }
>                 cur = cur->right;
>             }
>         }
>     }
> 
>     int check(int num){
>         shared_ptr<TrieNode> cur = root;
>         int x = 0;
>         for(int k = HIGH_BIT; k >= 0; --k){
>             int bit = (num >> k) & 1;
>             if(bit == 0){
>                 if(cur->right){
>                     cur = cur->right;
>                     x = x * 2 + 1;
>                 }
>                 else{
>                     cur = cur->left;
>                     x = x * 2;
>                 }
>             }
>             else{
>                 if(cur->left){
>                     cur = cur->left;
>                     x = x * 2 + 1;
>                 }
>                 else{
>                     cur = cur->right;
>                     x = x * 2;
>                 }
>             }
>         }
>         return x;
>     }
> public:
>     Solution(){
>         root = make_shared<TrieNode>();
>     }
>     int findMaximumXOR(vector<int> &nums){
>         int n = nums.size();
>         int x = 0;
>         for(int i = 1; i < n; ++i){
>             add(nums[i - 1]);
>             x = max(x, check(nums[i]));
>         }
>         return x;
>     }
> private:
>     shared_ptr<TrieNode> root;
> };
> ```

# 13 实现`Trie`（前缀树）

> [208. 实现 Trie (前缀树) - 力扣（LeetCode）](https://leetcode.cn/problems/implement-trie-prefix-tree/solutions/717239/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/)
>
> `Trie`或者说前缀树是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。
>
> 请你实现`Trie`类：
>
> * `Trie()`初始化前缀树对象
> * `void insert(string word)`向前缀树中插入字符串`word`。
> * `bool search(string word)`如果字符串`word`在前缀树中，返回`true`（即，在检索之前已经插入）；否则，返回`false`。
> * `bool startsWith(string prefix)`如果之前已经插入的字符串`word`的前缀之一为`prefix`，返回`true`；否则，返回`false`。
>
> ```c++
> class Trie {
> private:
>     static const int CHILD_NUM = 26;
>     struct Node{
>         vector<shared_ptr<Node>> data;
>         bool isEnd;
>         Node() : isEnd(false), data(CHILD_NUM){}
>     };
> private:
>     shared_ptr<Node> searchPrefix(string prefix){
>         shared_ptr<Node> cur = root;
>         for(auto c : prefix){
>             int index = c - 'a';
>             if(cur->data[index] != nullptr){
>                 cur = cur->data[index];
>             }
>             else{
>                 return nullptr;
>             }
>         }
>         return cur;
>     }
> public:
>     Trie() {
>         root = make_shared<Node>();
>     }
>     
>     void insert(string word) {
>         shared_ptr<Node> cur = root;
>         for(auto c : word){
>             int index = c - 'a';
>             if(cur->data[index] == nullptr){
>                 cur->data[index] = make_shared<Node>();
>             }
>             cur = cur->data[index];
>         }
>         cur->isEnd = true;
>     }
>     
>     bool search(string word) {
>         shared_ptr<Node> node = searchPrefix(word);
>         return node != nullptr && node->isEnd;
>     }
>     
>     bool startsWith(string prefix) {
>         shared_ptr<Node> node = searchPrefix(prefix);
>        class Trie {
> private:
>     static const int CHILD_NUM = 26;
>     struct Node{
>         vector<shared_ptr<Node>> data;
>         bool isEnd;
>         Node() : isEnd(false), data(CHILD_NUM){}
>     };
> private:
>     shared_ptr<Node> searchPrefix(string prefix){
>         shared_ptr<Node> cur = root;
>         for(auto c : prefix){
>             int index = c - 'a';
>             if(cur->data[index] != nullptr){
>                 cur = cur->data[index];
>             }
>             else{
>                 return nullptr;
>             }
>         }
>         return cur;
>     }
> public:
>     Trie() {
>         root = make_shared<Node>();
>     }
>     
>     void insert(string word) {
>         shared_ptr<Node> cur = root;
>         for(auto c : word){
>             int index = c - 'a';
>             if(cur->data[index] == nullptr){
>                 cur->data[index] = make_shared<Node>();
>             }
>             cur = cur->data[index];
>         }
>         cur->isEnd = true;
>     }
>     
>     bool search(string word) {
>         shared_ptr<Node> node = searchPrefix(word);
>         return node != nullptr && node->isEnd;
>     }
>     
>     bool startsWith(string prefix) {
>         shared_ptr<Node> node = searchPrefix(prefix);
>         return node != nullptr;
>     }
> private:
>     shared_ptr<Node> root;
> }; return node != nullptr;
>     }
> private:
>     shared_ptr<Node> root;
> };
> ```
>

# 14 找出强数对的最大亦或值II

> [2935. 找出强数对的最大异或值 II - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-strong-pair-xor-ii/description/)

## 14.1 基于哈希表

> 注意！！！如果提前把前缀表生成，则相同前缀的数，靠后的数的`val`会把前面的覆盖掉。
>
> 因此，应该先排序，边遍历边生成前缀表，因为此时，前缀表中存储的是相同前缀下的最大值，即最有可能与当前数构成强数对的数。
>
> ```c++
> class Solution {
> private:
>     static const int HIGH_BIT = 19;
> public:
>     int maximumStrongPairXor(vector<int>& nums) {
>         sort(nums.begin(), nums.end());
>         int x = 0;
>         for(int k = HIGH_BIT; k >= 0; k--){
>             unordered_map<int, int> mp;
>             int x_next = (x << 1) + 1;
>             bool found = false;
>             for(auto val : nums){
>                 auto it = mp.find((val >> k) ^ x_next);
>                 if(it != mp.end() && it->second * 2 >= val){
>                     found = true;
>                     break;
>                 }
>                 mp[val >> k] = val;
>             }
>             if(!found)
>                 x_next = x_next - 1;
> 
>             x = x_next;
>         }
> 
>         return x;
>     }
> };
> ```

## 14.2 基于`trie`（前缀树）

> ```c++
> class Solution {
> private:
>     static const int HIGH_BIT = 19;
>     struct TrieNode{
>         vector<TrieNode*> child;
>         int lcount;
>         int rcount;
>         TrieNode() : child(2), lcount(0), rcount(0){}
>     };
> 
>     void add(int val){
>         TrieNode *cur = root;
>         for(int k = HIGH_BIT; k >= 0; k--){
>             int bit = val & (1 << k);
>             if(bit == 0){
>                 if(cur->child[0] == nullptr){
>                     cur->child[0] = new TrieNode;
>                 }
>                 cur->lcount++;
>                 cur = cur->child[0];
>             }
>             else{
>                 if(cur->child[1] == nullptr){
>                     cur->child[1] = new TrieNode;
>                 }
>                 cur->rcount++;
>                 cur = cur->child[1];
>             }
>         }
>     }
> 
>     void remove(int val){
>         TrieNode *cur = root;
>         for(int k = HIGH_BIT; k >= 0; k--){
>             int bit = val & (1 << k);
>             if(bit == 0){
>                 cur->lcount--;
>                 if(cur->lcount == 0){
>                     delete cur->child[0];
>                     cur->child[0] = nullptr;
>                     break;
>                 }
>                 else{
>                     cur = cur->child[0];
>                 }
>             }
>             else{
>                 cur->rcount--;
>                 if(cur->rcount == 0){
>                     delete cur->child[1];
>                     cur->child[1] = nullptr;
>                     break;
>                 }
>                 else{
>                     cur = cur->child[1];
>                 } 
>             }
>         }
>     }
> 
>     int search(int val){
>         TrieNode *cur = root;
>         int x = 0;
>         for(int k = HIGH_BIT; k >= 0; k--){
>             int bit = val & (1 << k);
>             if(bit == 0){
>                 if(cur->child[1] != nullptr){
>                     x += (1 << k);
>                     cur = cur->child[1];
>                 }
>                 else{
>                     cur = cur->child[0];
>                 }
>             }
>             else{
>                 if(cur->child[0] != nullptr){
>                     x += (1 << k);
>                     cur = cur->child[0];
>                 }
>                 else{
>                     cur = cur->child[1];
>                 }
>             }
>         }
>         return x;
>     }
> private:
>      TrieNode *root;
> public:
>     Solution(){
>         root = new TrieNode();
>     }
>     int maximumStrongPairXor(vector<int>& nums) {
>         int n = nums.size();
>         sort(nums.begin(), nums.end());
>         int result = 0;
>         int left = 0;
>         int right = 0;
>         while(right < n){
>             add(nums[right]);
>             while(nums[left] *2 < nums[right]){
>                 remove(nums[left++]);
>             }
>             result = max(result, search(nums[right]));
>             right++;
>         }
>         return result;
>     }
> };
> 
> ```

# 15 区域和检索 - 数组可修改

> [307. 区域和检索 - 数组可修改 - 力扣（LeetCode）](https://leetcode.cn/problems/range-sum-query-mutable/solutions/1389182/qu-yu-he-jian-suo-shu-zu-ke-xiu-gai-by-l-76xj/)

# 16 数位和相等数对的最大和

> [2342. 数位和相等数对的最大和 - 力扣（LeetCode）](https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/)

# 17 三个无重叠子数组的最大和

> [689. 三个无重叠子数组的最大和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-sum-of-3-non-overlapping-subarrays/?envType=daily-question&envId=2023-11-19)

## 17.1 动态规划

> ```c++
> class Solution {
> public:
>     vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {
>         vector<int> result;
>         int n = nums.size();
>         if(n < 3 * k){
>             return result;
>         }
>         result.resize(3);
>         int sum = 0;
>         int l = 0;
>         int r = 0;
>         vector<int> vec;
>         for(r = 0; r < k; r++){
>             sum += nums[r];
>         }
>         vec.push_back(sum);
>         l = 1;
>         while(l <= n - k){
>             sum = sum - nums[l - 1] + nums[r];
>             vec.push_back(sum);
>             l++;
>             r++;
>         }
>         int m = vec.size();
>         vector<vector<int>> dp(n, vector<int>(3, -1));
>         dp[0][0] = vec[0];
>         for(int i = 1; i < vec.size(); i++){
>             dp[i][0] = max(dp[i - 1][0], vec[i]);
>             if(i - k >= 0){
>                 dp[i][1] = max(dp[i - 1][1], dp[i - k][0] + vec[i]);
>                 if(dp[i - k][1] != -1){
>                     dp[i][2] = max(dp[i - 1][2], dp[i - k][1] + vec[i]);
>                 }
>             }
>             else {
>                 dp[i][1] = dp[i - 1][1];
>                 dp[i][2] = dp[i - 1][2];
>             }
>         }
>         int target = dp[m - 1][2];
>         int index = 0;
>         for(int i = 0; i < m; i++){
>             if(dp[i][2] == target){
>                 index = i;
>                 break;
>             }
>         }
>         result[2] = index;
>         target -= vec[index];
>         for(int i = 0; i < m; i++){
>             if(dp[i][1] == target){
>                 index = i;
>                 break;
>             }
>         }
>         result[1] = index;
>         target -= vec[index];
>         for(int i = 0; i < m; i++){
>             if(dp[i][0] == target){
>                 index = i;
>                 break;
>             }
>         }
>         result[0] = index;
>         return result;
>     }
> };
> ```

## 17.2 滑动窗口

> ```c++
> class Solution {
> public:
>     vector<int> maxSumOfThreeSubarrays(vector<int> &nums, int k) {
>         vector<int> ans;
>         int sum1 = 0, maxSum1 = 0, maxSum1Idx = 0;
>         int sum2 = 0, maxSum12 = 0, maxSum12Idx1 = 0, maxSum12Idx2 = 0;
>         int sum3 = 0, maxTotal = 0;
>         for (int i = k * 2; i < nums.size(); ++i) {
>             sum1 += nums[i - k * 2];
>             sum2 += nums[i - k];
>             sum3 += nums[i];
>             if (i >= k * 3 - 1) {
>                 if (sum1 > maxSum1) {
>                     maxSum1 = sum1;
>                     maxSum1Idx = i - k * 3 + 1;
>                 }
>                 if (maxSum1 + sum2 > maxSum12) {
>                     maxSum12 = maxSum1 + sum2;
>                     maxSum12Idx1 = maxSum1Idx;
>                     maxSum12Idx2 = i - k * 2 + 1;
>                 }
>                 if (maxSum12 + sum3 > maxTotal) {
>                     maxTotal = maxSum12 + sum3;
>                     ans = {maxSum12Idx1, maxSum12Idx2, i - k + 1};
>                 }
>                 sum1 -= nums[i - k * 3 + 1];
>                 sum2 -= nums[i - k * 2 + 1];
>                 sum3 -= nums[i - k + 1];
>             }
>         }
>         return ans;
>     }
> };
> ```
