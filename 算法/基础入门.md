# 1 异或运算

**看成是无进位加法**

> 1) **0 ^ N = N	N ^ N = 0**
>
> 2) **异或运算满足交换律和结合律**

交换两个数（内存独立）：

> a = a ^ b
>
> b = a ^ b
>
> b = a ^ b

**提取一个数最右侧的1**

> **N & (~N + 1)**

【例，应用】计算一个数二进制位为1的个数

```c
int bit1counts(int num)
{
	int count = 0;
	while(num != 0)
	{
		int rightone = num & (~num + 1)
		count++;
		num ^= rightone;
	}
	return count;
}
```

> 2 * i + 1 ====》 (i << 1) | 1

# 2 递归调用复杂度

> Master公式：
>
> 形如：
>
> T(N) = a * T(N/b) + O(N^d)（其中a、b、d都是常数）的递归函数，可以直接通过Master公式来确定时间复杂度
>
> **如果log(b, a) < d，复杂度为O(N^d)**
>
> **如果log(b, a) > d，复杂度为O(N ^ log(b, a))**
>
> **如果log(b, a) == d，复杂度为O(N ^ d * logN)**

![](https://cdn.jsdelivr.net/gh/moshang1314/myBlog@main/image/image-20220919110438392.png)

# 3  排序   算法

> 垃圾三排组（复杂度为O(n^2)）：
>
> * 冒泡排序
> * 插入排序
> * 选择排序

## 3.1 归并排序

> 时间复杂度：O(nlogn)

### 3.1.1 递归版

```c++
#include <iostream>
#include <cstdlib>
#include <ctime>

using namespace std;

void pro_arr(int arr[], int len)
{
	srand(time(0));
	for(int i = 0; i < len; i++)
	{
		arr[i] = rand() % 1000;
		cout << arr[i] << " ";
	}
	cout << endl;
}


void merge(int arr[], int L, int mid, int R)
{
	int *p = new int[R - L + 1];
	int l = L;
	int r = mid + 1;
	int i = 0;
	while(l <= mid && r <= R)
	{
		p[i++] = arr[l] > arr[r] ? arr[r++] : arr[l++];
	}
	if(l <= mid)
	{
		while(l <= mid)
		{
			p[i++] = arr[l++];
		}
	}
	else if(r <= R)
	{
		while(r <= R)
		{
			p[i++] = arr[r++];
		}
	 }
	int j = L;
	for(i = 0; i < R - L + 1; i++)
	{
		arr[j++] = p[i];
	}
	delete p;
	p = NULL;
}

void divide(int arr[], int L, int R)
{
	if(L == R)
	{
		return ;
	}
	int mid = L + ((R - L) >> 1);
	divide(arr, L,  mid);
	divide(arr, mid+1, R);
	merge(arr, L, mid, R);
}

int mergeSort(int arr[], int len)
{
	divide(arr, 0, len-1);
}
int main(int argc, char *argv[])
{
	const int len = 33;
	int arr[len];
	pro_arr(arr, len); 
	mergeSort(arr, len);
	for(int i = 0; i < len; i++)
	{
		cout << arr[i] << " ";
	}
	return 0;
}
```

### 3.1.2  非递归版本

```C++
#include <iostream>
#include <cstdlib>
#include <ctime>

using namespace std;

void pro_arr(int arr[], int len)
{
	srand(time(0));
	for(int i = 0; i < len; i++)
	{
		arr[i] = rand() % 10;
		cout << arr[i] << " ";
	}
	cout << endl;
}

void merge(int arr[], int L, int mid, int R)
{
	int *p = new int[R - L + 1];
	int l = L;
	int r = mid + 1;
	int i = 0;
	while(l <= mid && r <= R)
	{
		p[i++] = arr[l] > arr[r] ? arr[r++] : arr[l++];
	}
	if(l <= mid)
	{
		while(l <= mid)
		{
			p[i++] = arr[l++];
		}
	}
	else if(r <= R)
	{
		while(r <= R)
		{
			p[i++] = arr[r++];
		}
	 }
	int j = L;
	for(i = 0; i < R - L + 1; i++)
	{
		arr[j++] = p[i];
	}
	delete p;
	p = NULL;
}

void mergeSort(int arr[], int len)
{
	if(arr == NULL || len < 2)
	{
		return;
	}
	int s = 2;
	while(s < 2 * len)
	{
		int l = 0;
		int n = s >> 1;
		while(l < len)
		{
			if(len - l <= n)
			{
				break;
			}
			if(l + s > len )
			{
				merge(arr, l, l + n - 1, len - 1);
			}
			else
			{
				merge(arr, l, l + n - 1, l + s - 1);
			}
			l = l + s > len - 1 ? len - 1 : l + s;
		}
		if(s > len) //预防溢出产生错误 
			break;
		s = s << 1;
	}
}
int main(int argc, char *argv[])
{
	const int len = 30;
	int arr[len];
	pro_arr(arr, len); 
	mergeSort(arr, len);
	for(int i = 0; i < len; i++)
	{
		cout << arr[i] << " ";
	}
	return 0;
}
```

### 3.1.3 归并应用：

#### 3.1.3.1 求数组小和

在一个数组中，一个数左边比它小的数的总和，叫数的小和，所有数的小和累加起来，叫数组小和。求数组小和。

例如：[1, 3, 4, 2, 5]的小和为16

```c++
#include <iostream>
#include <cstdlib>
#include <ctime>

using namespace std;
//时间复杂度为 n^2 
int low_minSum(int *arr, int len)
{
	int sum = 0;
	for(int i = 0; i < len; i++)
	{
		int j = i;
		while(j >= 0)
		{
			if(arr[j] < arr[i])
			{
				sum += arr[j];
			}
			j--;
		}
	}
	return sum;
}

void pro_arr(int arr[], int len)
{
	srand(time(0));
	for(int i = 0; i < len; i++)
	{
		arr[i] = rand() % 1000;
		cout << arr[i] << " ";
	}
	cout << endl;
}


int merge(int arr[], int L, int mid, int R)
{
	int sum = 0;
	int s = R - mid;
	int *p = new int[R - L + 1];
	int l = L;
	int r = mid + 1;
	int i = 0;
	while(l <= mid && r <= R)
	{
		if(arr[r] > arr[l])
		{
			p[i++] = arr[l];
			sum += arr[l] * s;
			l++;
		}
		else if(arr[r] == arr[l])
		{
			p[i++] = arr[l++];
			p[i++] = arr[r++];
			s--;
		}
		else
		{
			p[i++] = arr[r++];
			s--;
		}
	}
	if(l <= mid)
	{
		while(l <= mid)
		{
			p[i++] = arr[l++];
		}
	}
	else if(r <= R)
	{
		while(r <= R)
		{
			p[i++] = arr[r++];
		}
	 }
	int j = L;
	for(i = 0; i < R - L + 1; i++)
	{
		arr[j++] = p[i];
	}
	delete p;
	p = NULL;
	
	return sum;
}

int divide(int arr[], int L, int R)
{
	static int minsum = 0;
	if(L == R)
	{
		return 0;
	}
	int mid = L + ((R - L) >> 1);
	divide(arr, L,  mid);
	divide(arr, mid+1, R);
	minsum += merge(arr, L, mid, R);
	
	return minsum;
}

//时间复杂度为 nlogn 
int minSum(int arr[], int len)
{
	return divide(arr, 0, len-1);
}
int main(int argc, char *argv[])
{
	const int len = 7;
	int arr[len];
	pro_arr(arr, len); 
	cout << low_minSum(arr, len) << endl;
	cout << minSum(arr, len) << endl;
	return 0;
}
```

#### 3.1.3.2  求数组逆序对

## 3.2 快速排序

> Partition算法：
>
> 1）给定一个数组arr，和一个整数num。把小于等于num的数放在数组的左边，大于num的数放在数组的右边。
>
> 要求额外空间复杂度O(1)，时间复杂度O(N)
>
> 2）三划分，小于num的数放在数组左边，等于num的数放在中间，大于num的数放在数组的右边。返回等于区域的左右边界（荷兰国旗划分问题）

1）第一种划分：

```c++
#include <iostream>
#include <cstdlib>
#include <ctime>

using namespace std;

void pro_arr(int arr[], int len)
{
	srand(time(0));
	for(int i = 0; i < len; i++)
	{
		arr[i] = rand() % 100;
		cout << arr[i] << " ";
	}
	cout << endl;
}

void part(int *arr, int len)
{
	int left = -1;
	int num = arr[0];
	for(int i = 0; i < len; i++)
	{
		int temp = 0;
		if(arr[i] <= num)
		{
			temp = arr[i];
			arr[i] = arr[++left];
			arr[left] = temp;
		}
	}
}
int main()
{
	const int len = 20;
	int arr[len] = {};
	pro_arr(arr, len);
	part(arr, len);
	for(int i = 0; i < len; i++)
	{
		cout << arr[i] << " ";
	}
	return 0;
}
```

2）第二种划分：（荷兰国旗划分）

```C++
#include <iostream>
#include <cstdlib>
#include <ctime>

using namespace std;

void pro_arr(int arr[], int len)
{
	srand(time(0));
	for(int i = 0; i < len; i++)
	{
		arr[i] = rand() % 10;
		cout << arr[i] << " ";
	}
	cout << endl;
}

int* dutchflag_part(int *arr, int len)
{
	int left = -1;
	int right = len;
	int num = arr[len - 1];
	int i = 0;
	int *p = new int[2];
	while(i < right)
	{
		int temp = 0;
		if(arr[i] < num)
		{
			temp = arr[i];
			arr[i] = arr[++left];
			arr[left] = temp;
			i++;
		}
		else if(arr[i] > num)
		{
			temp = arr[i];
			arr[i] = arr[--right];
			arr[right] = temp;
		}
		else
		{
			i++;
		}
	}
	p[0] = left;
	p[1] = right;
	return p;
}
int main()
{
	const int len = 20;
	int arr[len] = {};
	pro_arr(arr, len);
	int *p = dutchflag_part(arr, len);
	for(int i = 0; i < len; i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
	cout << "left = " << p[0] << "  right = " << p[1] << endl;
	return 0;
}
```

### 3.2.1 基于第一种划分的快速排序

> 最优时间复杂度nlogn
>
> 极端情况下(数组原本有序时)时间复杂度为n^2
>
> 平均空间复杂度为logn
>
> 极端情况下空间复杂度为n，为递归调用的深度

```C++
#include <iostream>
#include <cstdlib>
#include <ctime>
using namespace std;

void pro_arr(int arr[], int len)
{
	srand(time(0));
	for(int i = 0; i < len; i++)
	{
		arr[i] = rand() % 100;
		cout << arr[i] << " ";
	}
	cout << endl;
}

int part(int *arr, int L, int R)
{
	if(L == R)
	{
		return L;
	}
	int left = L + 1;
	int right = R;
	while(left <= right)
	{
		while(arr[left] <= arr[L] && left <= right)
		{
			left++;
		}
		if(left > right)
		{
			break;
		}
		while(arr[right] > arr[L] && right >= left)
		{
			right--;
		}
		if(left > right)
		{
			break;
		}
		arr[left] = arr[right] ^ arr[left];
		arr[right] = arr[left] ^ arr[right];
		arr[left] = arr[right] ^ arr[left];
		left++;
		right--;	
	}
	if(--left == L)
		return left;
	arr[left] = arr[left] ^ arr[L];
	arr[L] = arr[left] ^ arr[L];
	arr[left] = arr[left] ^ arr[L];
	return left;
}

void process(int *arr, int L, int R)
{
	if(L >= R)
	{
		return ;
	}
	int left = part(arr, L, R);
	process(arr, L, left - 1);
	process(arr, left + 1, R);	
}

void quickSort(int *arr, int len)
{
	process(arr, 0, len - 1);
}

int main()
{
	const int len = 11;
	int arr[len] = {};
	pro_arr(arr, len);
	quickSort(arr, len);
	//part(arr, 0, len - 1);
	for(int i = 0; i < len; i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
	return 0;
}
```

### 3.2.2 基于荷兰国旗划分的快速排序算法

```C++
#include <iostream>
#include <cstdlib>
#include <ctime>

using namespace std;

void pro_arr(int arr[], int len)
{
	srand(time(0));
	for(int i = 0; i < len; i++)
	{
		arr[i] = rand() % 10;
		cout << arr[i] << " ";
	}
	cout << endl;
}

int* dutchflag_part(int *arr, int L, int R)
{
	int left = L - 1;
	int right = R + 1;
	int num = arr[R];
	int i = L;
	int *p = new int[2];
	while(i < right)
	{
		int temp = 0;
		if(arr[i] < num)
		{
			temp = arr[i];
			arr[i] = arr[++left];
			arr[left] = temp;
			i++;
		}
		else if(arr[i] > num)
		{
			temp = arr[i];
			arr[i] = arr[--right];
			arr[right] = temp;
		}
		else
		{
			i++;
		}
	}
	p[0] = left;
	p[1] = right;
	return p;
}

void process(int *arr, int L, int R)
{
	if(L >= R)
	{
		return ;
	}
	int *p = dutchflag_part(arr, L, R);
	cout << endl;
	process(arr, L, p[0]);
	process(arr, p[1], R);	
}

void quickSort(int *arr, int len)
{
	process(arr, 0, len - 1);
}

int main()
{
	const int len = 9;
	int arr[len] = {};
	pro_arr(arr, len);
	quickSort(arr, len);
	for(int i = 0; i < len; i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
	return 0;
}
```

### 3.2.3 随机快排，即将情况随机化

> 每次选择num时，从数组中随机选择。
>
> 1）通过分析知道，划分值越靠中间，性能越好；越靠两边，性能越差
>
> 2）随机选一个数进行划分的目的就是让好情况和差情况都变成概率事件
>
> 3）把每一种情况都列出来，会有每种情况下的时间复杂度，但概率都是1/N
>
> 4）那么所有情况都考虑，时间复杂度就是这种概率模型下的长期期望！
>
> 时间复杂度O(n*logn)，额外空间复杂度O(logn)都是这么来的。

```C++
#include <iostream>
#include <cstdlib>
#include <ctime>

using namespace std;

void pro_arr(int arr[], int len)
{
	srand(time(0));
	for(int i = 0; i < len; i++)
	{
		arr[i] = rand() % 10;
		cout << arr[i] << " ";
	}
	cout << endl;
}

int* dutchflag_part(int *arr, int L, int R)
{
	int left = L - 1;
	int right = R + 1;
	int temp = 0;
	//随机化极端情况 
	int index = rand() % (R - L + 1) + L;
	temp = arr[index];
	arr[index] = arr[R];
	arr[R] = temp;
	int num = arr[R];
	int i = L;
	int *p = new int[2];
	while(i < right)
	{
		if(arr[i] < num)
		{
			temp = arr[i];
			arr[i] = arr[++left];
			arr[left] = temp;
			i++;
		}
		else if(arr[i] > num)
		{
			temp = arr[i];
			arr[i] = arr[--right];
			arr[right] = temp;
		}
		else
		{
			i++;
		}
	}
	p[0] = left;
	p[1] = right;
	return p;
}

void process(int *arr, int L, int R)
{
	if(L >= R)
	{
		return ;
	}
	int *p = dutchflag_part(arr, L, R);
	cout << endl;
	process(arr, L, p[0]);
	process(arr, p[1], R);	
}

void quickSort(int *arr, int len)
{
	process(arr, 0, len - 1);
}

int main()
{
	const int len = 9;
	int arr[len] = {};
	pro_arr(arr, len);
	quickSort(arr, len);
	for(int i = 0; i < len; i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
	return 0;
}
```

# 4 堆结构

> 堆结构
>
> 1）堆结构就是用数组实现的完全二叉树结构
>
> 2）完全二叉树中如果每颗子树的最大值都在顶部就是大根堆
>
> 3）完全二叉树如果每颗子树的最小值都在顶部就是小根堆
>
> 4）堆结构的heapInsert（logn）与heapify（logn）操作
>
> 5）堆结构的增大与减少
>
> 6）优先级队列结构，就是堆结构
>
> **当在数组中从0计数时，**
>
> 左子：2 * i + 1
>
> 右子：2 * i + 2
>
> 父：（i - 1) / 2
>
> **当在数组中从1计数时，**
>
> 左子：2 * i	==> i << 1
>
> 右子：2 * i + 1	==> i << 1 | 1
>
> 父：i / 2	==> i >> 1

## 4.1 堆排序

> 1 先让整个数组都变成大根堆结构，建立堆的过程：
>
> 1) 从上到下的方法，时间复杂度为O(NlogN)，heapinsert
> 2) 从下到上的方法，时间复杂度为O(N)，heapify
>
> 2 把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为O(N*logN)
>
> 3 堆的大小减小成0之后，排序完成，

## 4.2 构建大根堆

```C++
#include <iostream>
#include <cstdlib>
#include <ctime>

using namespace std;
void pro_arr(int arr[], int len)
{
	srand(time(0));
	for(int i = 0; i < len; i++)
	{
		arr[i] = rand() % 10;
		cout << arr[i] << " ";
	}
	cout << endl;
}

//把数组index索引处的数字纳入堆中 
void heapInsert(int arr[], int index)
{	//整数除法向零取整 （arr[0] > arr[0] ?） 
	while(arr[index] > arr[(index - 1) / 2])
	{
		int temp = arr[(index - 1) >> 1];
		arr[(index - 1) >> 1] = arr[index];
		arr[index] = temp;
		index = (index - 1) >> 1;
	 } 
}

void heapify(int arr[], int index, int heapsize)
{
	int temp = arr[index];
	int left = (index << 1) | 1;
	while(left < heapsize)
	{
		int maxindex = left + 1 < heapsize && arr[left + 1] > arr[left] ? left + 1 : left;
		maxindex = temp > arr[maxindex] ? index : maxindex;
		if(maxindex == index)
		{
			break;
		}
		arr[index] = arr[maxindex];
		index = maxindex;
		left = (index << 1) | 1;
	}
	arr[index] = temp;
}

int main(int argc, char *argv[])
{
	const int len = 9;
	int arr[len] = {};
	pro_arr(arr, len); 
	//从上往下插入元素后调整构建大根堆，时间复杂度为O(NlogN) 
//	for(int i = 0; i < len; i++)
//	{
//		heapInsert(arr, i);
//	}
	
	//由下往上调整构建大根堆，时间复杂度为O(N) 
	for(int j = (len - 2) / 2; j >= 0; j--)
	{
		heapify(arr, j, len);
	}
	
	for(int i = 0; i < len; i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
	return 0;
 } 
```

## 4.3 基于大根堆的堆排序

```c++
#include <iostream>
#include <cstdlib>
#include <ctime>

using namespace std;
void pro_arr(int arr[], int len)
{
	srand(time(0));
	for(int i = 0; i < len; i++)
	{
		arr[i] = rand() % 20;
		cout << arr[i] << " ";
	}
	cout << endl;
}

//把数组index索引处的数字纳入堆中 
void heapInsert(int arr[], int index)
{	//整数除法向零取整 （arr[0] > arr[0] ?） 
	while(arr[index] > arr[(index - 1) / 2])
	{
		int temp = arr[(index - 1) >> 1];
		arr[(index - 1) >> 1] = arr[index];
		arr[index] = temp;
		index = (index - 1) >> 1;
	 } 
}

void heapify(int arr[], int index, int heapsize)
{
	int temp = arr[index];
	int left = (index << 1) | 1;
	while(left < heapsize)
	{
		int maxindex = left + 1 < heapsize && arr[left + 1] > arr[left] ? left + 1 : left;
		maxindex = temp > arr[maxindex] ? index : maxindex;
		if(maxindex == index)
		{
			break;
		}
		arr[index] = arr[maxindex];
		index = maxindex;
		left = (index << 1) | 1;
	}
	arr[index] = temp;
}

void heapSort(int arr[], int len)
{
	while(len > 1)
	{
		int temp = arr[len - 1];
		arr[len - 1] = arr[0];
		arr[0] = temp;
		len--;
		heapify(arr, 0, len);
	}
 } 

int main(int argc, char *argv[])
{
	const int len = 9;
	int arr[len] = {};
	pro_arr(arr, len); 
	//从上往下插入元素后调整构建大根堆，时间复杂度为O(NlogN) 
//	for(int i = 0; i < len; i++)
//	{
//		heapInsert(arr, i);
//	}
	
	//由下往上调整构建大根堆，时间复杂度为O(N) 
	for(int j = (len - 2) / 2; j >= 0; j--)
	{
		heapify(arr, j, len);
	}
	heapSort(arr, len);
	for(int i = 0; i < len; i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
	return 0;
 } 
```

## 4.4 堆的应用

### 4.4.1几乎有序数组排序策略

> 已知一个几乎有序的数组。几乎有序是指，如果把数组排好序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。
>
> 请选择一个合适的排序策略，对这个数组进行排序。
>
> 策略：假设k=5，则最小值只可能存在于索引为0-5的元素中，否则移动将超过看，对0-5号元素构建小根堆，找出最小值，然后后续元素依次入堆，并调整堆，找到堆中最小值即为第2,3,4小的数。
>
> 时间复杂度为：O(N * logk)

# 5 前缀树

> 1) 单个字符串中，字符从前到后地添加到一棵多叉树上
> 2) 字符放在路上，每个节点上有专属的数据项（常见的是pass和end值）
> 3) 所有样本都这样添加，如果路没有就新建，如有路就复用
> 4) 沿途节点的pass值增加1，每个字符串结束时来到的节点end值增加1

![image-20221002151546148](https://cdn.jsdelivr.net/gh/moshang1314/myBlog@main/image/image-20221002151546148.png)

```c++
#include <iostream>
#include <cstdlib>
#include <string.h>
#include <ctime>

using namespace std;

struct Node
{
	int pass;
	int end;
	struct Node *path[26];
};

class PreTree
{
public:
	PreTree();	
	struct Node root;
	void Insert(const char* str);
	int Search(const char* str);
	void Delete(const char* str);
};

PreTree::PreTree()
{
	root.pass = 0;
	root.end = 0;
	memset(root.path, 0, sizeof(root.path));
}

void PreTree::Insert(const char* str)
{
	if(nullptr == str)
	{
		return;
	}
	root.pass++;
	cout << str << root.pass << endl;
	int i = 0;
	struct Node* temp = &root;
	while(str[i] != 0)
	{
		int index = str[i] - 'a';
		if(temp->path[index] == nullptr)
		{
			temp->path[index] = new struct Node;
			temp->path[index]->pass = 1;
			temp->path[index]->end = 0;
			memset(temp->path[index]->path, 0, sizeof(temp->path[index]->path));
		}
		else
		{
			temp->path[index]->pass++;
		}
		temp = temp->path[index];
		i++;
	}
	temp->end++;
}	

int PreTree::Search(const char* str)
{
	int i = 0;
	struct Node *temp = &root;
	while(str[i] != 0)
	{
		int index = str[i] - 'a';
		if(temp->path[index] == nullptr)
		{
			return false;
		}
		temp = temp->path[index];
		i++;
	}
	return temp->end;
}

void PreTree::Delete(const char* str)
{
	if(0 >= Search(str))
	{
		return;
	}
	int i = 0;
	root.pass--;
	struct Node* temp = &root;
	struct Node* p = nullptr;
	while(str[i] != 0)
	{
		int index = str[i] - 'a';
		temp->path[index]->pass--;
		p = temp;
		temp = temp->path[index];
		if(temp->pass == 0)
		{
			p->path[index] = nullptr;
		}
		if(p->pass == 0 && p != &root)
		{
			delete p;
			p = nullptr;
		}
		i++;
	}
	if(temp != &root && temp->pass == 0)
	{
		delete temp;
		temp = nullptr;
	}
	temp->end--;
}

int main()
{
	PreTree PTree;
	PTree.Insert("music");
	PTree.Insert("music");
	PTree.Insert("music");
	PTree.Insert("music");
	PTree.Delete("music");
	cout << PTree.Search("music") << endl;
	return 0;
}
```



## 5.1 应用

### 5.1.1 检查word这个单词之前加入过几次

```c++
int PreTree::Search(const char* str)
{
	int i = 0;
	struct Node *temp = &root;
	while(str[i] != 0)
	{
		int index = str[i] - 'a';
		if(temp->path[index] == nullptr)
		{
			return false;
		}
		temp = temp->path[index];
		i++;
	}
	return temp->end;
}
```

### 5.1.2 所有加入的字符串中，有几个以pre这个字符串作为前缀的

# 6 不基于比较的排序

> 桶排序思想下的排序：计数排序 & 基数排序
>
> 1) 桶排序思想的排序都是不基于比较的排序
> 2) 时间复杂度为O(N)，额外空间负载度为O(M)
> 3) 应用范围有限，需要样本的数据状况满足桶的划分

> **计数排序：**
> 比如：对人类的年龄进行排序，年龄范围在（0-200）
>
> 则定义一个空间为200的计数数组，用于计数其索引对应的的数，遍历原数组，对每个数当做索引对数组元素加1.
>
> 适用情境：
>
> 只能应用于数据范围集中分布在一个有限的小区间内，否则将消耗很大空间。

> **基数排序（只针对于非负值）：**
>
> 思想：先对个位进行排序，然后是十位，再然后依次对后续所有位数排序。
>
> 算法流程，依次从个位到最高位，从左到右，入桶，然后出桶

```c++
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <cstring>

using namespace std;

void pro_arr(int arr[], int len)
{
	srand(time(0));
	for(int i = 0; i < len; i++)
	{
		arr[i] = rand() % 1000;
		cout << arr[i] << " ";
	}
	cout << endl;
}

//计算最高数位 
int maxbits(int *arr, int len)
{
	int max = arr[0];
	int bits = 0;
	for(int i = 1; i < len; i++)
	{
		max = max > arr[i] ? max : arr[i];
	}
	while(max)
	{
		max = max / 10;
		bits++;
	}
	return bits;
}

void radixSort(int *arr, int len, int maxbits)
{
	//用于统计对应位数小于等于索引值的个数 
	int count[10] = {};
	int bucket[len] = {};
	for(int i = 0; i < maxbits; i++)
	{
		memset(count, 0, 10 * sizeof(int));
		for(int j = 0; j < len; j++)
		{
			int radix = (arr[j] / (int)pow(10, i)) % 10;
			count[radix]++;
		}
		for(int j = 1; j < 10; j++)
		{
			count[j] = count[j] + count[j - 1];
		}
		for(int j = len - 1; j >= 0; j--)
		{
			int radix = (arr[j] / (int)pow(10, i)) % 10;
			bucket[--count[radix]] = arr[j];
		}
		for(int j = 0; j < len; j++)
		{
			arr[j] = bucket[j];
		}
	}
}

void radixSort(int *arr, const int len)
{
	radixSort(arr, len, maxbits(arr, len));
}

int main()
{
	const int len = 7;
	int arr[len] = {};
	pro_arr(arr, len);
	radixSort(arr, len);
	for(int i = 0; i < len; i++)
	{
		cout << arr[i] << " ";
	}
	return 0;
}
```

# 7 排序算法的稳定性

> 稳定性是指同样大小的样本在排序之后不会改变相对次序
>
> 对基本类型来说，稳定性毫无意义
>
> **但对非基本类型来说，稳定性具有重要意义，比如先对学生按学号排序，再按年龄大小排序**
>
> 有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的

1) **选择排序是不稳定的**

   > 如 5 5 5 5 1 5 5 5 5
   >
   > 1的归位，会破坏第一个5的次序

2) 冒泡排序可以实现成稳定的

   > 当相等的数进行比较时，不进行交换，则此时的冒泡排序是稳定的。

3) 插入排序是稳定的

   > 当遇到相等的数时，则即刻插入

4) 归并排序可以实现成稳定的

   > 当左右指针指向相等的值时，先拷贝左边的值，再拷贝右边的值，则此时归并排序是稳定的

5) **快速排序是不稳定的**

   > partion过程会改变相等数据的次序

6) **堆排序是不稳定的**

   > 不管是heapify还是heapinsert都会破坏相等数据的次序

![image-20221006214350939](https://cdn.jsdelivr.net/gh/moshang1314/myBlog@main/image/image-20221006214350939.png)

## 7.1 排序总结

> 1) 不基于比较的排序，对样本数据有严格要求，不易改写
> 2) 基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用
> 3) 基于比较的排序，时间复杂度的极限是O(N*logN)
> 4) **时间复杂度O(N*logN)，额外空间复杂度低于O(N)，且稳定的基于比较的排序是不存在的**
> 5) **为了绝对的速度选择快排，为了省空间选堆排，为了稳定性选归并。**

**常见的坑**

> 1) 归并排序的额外空间复杂度可以变成O(1)，“归并排序 内部缓存法”，但是将变得不再稳定。
> 2) “原地归并排序”是垃圾贴，会让时间复杂度变成O(N^2)。
> 3) 快速排序稳定性改进，“01 stable sort”，但是会对样本数据要求更多。
>
> 在整型数组中，请把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间的原始相对次序不变，所有偶数之间原始相对次序不变。
>
> 要求复杂度做到O(N)，额外空间复杂度做到O(1)
>
> 无解，若有解，则快排partion过程将可实现成稳定版，且时间复杂度为O(N)

# 8 链表问题

```c++
struct node
{
	char data;
	node *next;	
};

//头插法 
bool headinsert(node **head, char data)
{
	node *p = new node;
	p->data = data;
	if(!p)
	{
		perror("new");
		exit(EXIT_FAILURE);
	}
	p->next = *head;
	*head = p;
	
	return true;
}

//尾插法
bool tailinsert(node **head, char data)
{
	node *p = new node;
	p->data = data;
	p->next = nullptr;
	if(*head == nullptr)
	{
		*head = p;
		
		return true;
	}
	node *q = *head;
	while(q->next)
	{
		q = q->next;	
	}
	q->next = p;
	
	return true;
 } 

print(node *head)
{
	node *p = head;
	while(p)
	{
		cout << p->data << " ";
		p = p->next;
	 } 
}
```



> 面试时链表解题的方法论
>
> 1) 对于笔试，不用太在乎空间复杂度，一切为了时间复杂度
> 2) 对于面试，时间复杂度依然放在第一位，但一定要找到空间最省的方法

## 8.1 快慢指针

> 1) 输入链表头节点，奇数长度返回中点，偶数长度返回上中点
> 2) 输入链表头节点，奇数长度返回中点，偶数长度返回下中点
> 3) 输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个
> 4) 输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个

```c++
#include <iostream>
#include <cstdlib>
#include <string.h>
#include <ctime>

using namespace std;

void pro_arr(int arr[], int len)
{
	srand(time(0));
	for(int i = 0; i < len; i++)
	{
		arr[i] = rand() % 1000;
		cout << arr[i] << " ";
	}
	cout << endl;
}

struct node
{
	int data;
	node *next;	
};

//头插法 
bool headinsert(node **head, int data)
{
	node *p = new node;
	p->data = data;
	if(!p)
	{
		perror("new");
		exit(EXIT_FAILURE);
	}
	p->next = *head;
	*head = p;
	
	return true;
}

//尾插法
bool tailinsert(node **head, int data)
{
	node *p = new node;
	p->data = data;
	p->next = nullptr;
	if(*head == nullptr)
	{
		*head = p;
		
		return true;
	}
	node *q = *head;
	while(q->next)
	{
		q = q->next;	
	}
	q->next = p;
	
	return true;
 } 

print(node *head)
{
	node *p = head;
	while(p)
	{
		cout << p->data << " ";
		p = p->next;
	 } 
}

//输入链表头节点，奇数长度返回中点，偶数长度返回上中点
int sfp1(const node* const head)
{
	if(head == nullptr)
	{
		return -1;
	}
	if(head->next == nullptr || head->next->next == nullptr)
	{
		return head->data;
	} 
	node *slow = head->next;
	node *fast = head->next->next;
	while(slow->next && fast->next && fast->next->next)
	{
		slow = slow->next;
		fast = fast->next->next;
	}
	return slow->data;
}

//输入链表头节点，奇数长度返回中点，偶数长度返回下中点
int sfp2(const node* const head)
{
	if(head == nullptr)
	{
		return -1;
	}
	if(head->next == nullptr)
	{
		return head->data;
	}
	node *slow = head->next;
	node *fast = head->next;
	while(slow->next && fast->next && fast->next->next)
	{
		slow = slow->next;
		fast = fast->next->next;
	}
	return slow->data;
}

int main()
{
	node *head = nullptr;
	const int len = 10;
	int arr[len] = {};
	pro_arr(arr, len);
	for(int i = 0; i < len; i++)
	{
		tailinsert(&head, arr[i]);
	}
	print(head);
	cout << endl;
	cout << sfp2(head) << endl;
	return 0;
}
```

## 8.2 链表判断是否为回文串

### 8.2.1 借助于栈与快慢指针

> 先利用快慢指针找到链表的中点（偶数长度为上中点），然后把下半链表数据进栈，最后依次出栈与链表从头开始比较直到栈空。

```c++
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <stack>

using namespace std;

void pro_arr(int arr[], int len)
{
	srand(time(0));
	for(int i = 0; i < len; i++)
	{
		arr[i] = rand() % 1;
		cout << arr[i] << " ";
	}
	cout << endl;
}

struct node
{
	char data;
	node *next;	
};

//头插法 
bool headinsert(node **head, char data)
{
	node *p = new node;
	p->data = data;
	if(!p)
	{
		perror("new");
		exit(EXIT_FAILURE);
	}
	p->next = *head;
	*head = p;
	
	return true;
}

//尾插法
bool tailinsert(node **head, char data)
{
	node *p = new node;
	p->data = data;
	p->next = nullptr;
	if(*head == nullptr)
	{
		*head = p;
		
		return true;
	}
	node *q = *head;
	while(q->next)
	{
		q = q->next;	
	}
	q->next = p;
	
	return true;
 } 

print(node *head)
{
	node *p = head;
	while(p)
	{
		cout << p->data << " ";
		p = p->next;
	 } 
}

bool ishw(const node * const head)
{
	stack<char> s;
	if(head == nullptr)
	{
		return false;
	}
	if(head->next == nullptr)
	{
		return true;
	}
	if(head->next->next == nullptr)
	{
		if(head->data == head->next->data)
		{
			return true;
		}
		return false;
	}
	node *slow = head->next;
	node *fast = head->next->next;
	while(fast->next && fast->next->next)
	{
		slow = slow->next;
		fast = fast->next->next;
	}
	const node* p = slow->next;
	//将下半段数据进栈 
	while(p)
	{
		s.push(p->data);
		p = p->next;		
	}
	const node* q = head;
	//出栈与前半段对比 
	while(!s.empty())
	{
		if(q->data != s.top())
		{
			return false;
		}
		s.pop();
		q = q->next;
	}
	return true;
}

int main()
{
	node *head = nullptr;
	const int len = 10;
	char str[len] = "abcddcbad";
	//pro_arr(arr, len);
	int i = 0;
	while(str[i])
	{
		tailinsert(&head, str[i++]);
	}
	print(head);
	cout << endl;
	cout << ishw(head) << endl;
	return 0;
}
```

### 8.2.2 不借用额外空间

> 利用快慢指针找到链表中点（偶数长度为上中点），然后将**后半段节点反向(重点，难点)**，分别从头节点和为节点向中点进行对比。

```c++
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <ctime>

using namespace std;

void pro_arr(int arr[], int len)
{
	srand(time(0));
	for(int i = 0; i < len; i++)
	{
		arr[i] = rand() % 1;
		cout << arr[i] << " ";
	}
	cout << endl;
}

struct node
{
	char data;
	node *next;	
};

//头插法 
bool headinsert(node **head, char data)
{
	node *p = new node;
	p->data = data;
	if(!p)
	{
		perror("new");
		exit(EXIT_FAILURE);
	}
	p->next = *head;
	*head = p;
	
	return true;
}

//尾插法
bool tailinsert(node **head, char data)
{
	node *p = new node;
	p->data = data;
	p->next = nullptr;
	if(*head == nullptr)
	{
		*head = p;
		
		return true;
	}
	node *q = *head;
	while(q->next)
	{
		q = q->next;	
	}
	q->next = p;
	
	return true;
 } 

print(node *head)
{
	node *p = head;
	while(p)
	{
		cout << p->data << " ";
		p = p->next;
	 } 
}

bool ishw(node * const head)
{
	if(head == nullptr || head->next == nullptr)
	{
		return true;
	}
	node *slow = head;
	node *fast = head;
	//找到中点（偶数长度为上中点）
	while(fast->next && fast->next->next)
	{
		slow = slow->next;
		fast = fast->next->next;
	}
	node* p = slow;
	node* h = p->next;
	//将下半段结点反向 
	while(h)
	{
		node* m = p;
		p = h;
		h = h->next;
		p->next = m;
	}
	//记录尾节点 
	h = p;
	slow->next = nullptr;
	const node* q = head;
	//后半段与前半段对比 
	while(q)
	{
		if(p->data != q->data)
		{
			//还原链表
	 		p = h->next;
	 		h->next = nullptr;
	 		while(p)
	 		{
	 			node *m = h;
	 			h = p;
	 			p = p->next;
	 			h->next = m;
	  		} 
	  		return false;
		}
		q = q->next;
		p = p->next; 
	}
	//还原链表
	 p = h->next;
	 h->next = nullptr;
	 while(p)
	 {
	 	node *m = h;
	 	h = p;
	 	p = p->next;
	 	h->next = m;
	  }   
	return true;
}

int main()
{
	node *head = nullptr;
	const int len = 10;
	char str[len] = "abccba";
	//pro_arr(arr, len);
	int i = 0;
	while(str[i])
	{
		tailinsert(&head, str[i++]);
	}
	print(head);
	cout << endl;
	cout << ishw(head) << endl;
	print(head);
	return 0;
}
```

## 8.3 链表partition

> 将单向链表按某值划分成左边小，中间相等、右边大的形式
>
> 1) 把链表放入数组里，在数组上做partition（笔试用）
> 2) 分成小、中、大三部分，再把各个部分串起来（面试用）

方法2code：

```c++
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <stack>

using namespace std;

void pro_arr(int arr[], int len)
{
	srand(time(0));
	for(int i = 0; i < len; i++)
	{
		arr[i] = rand() % 100;
		cout << arr[i] << " ";
	}
	cout << endl;
}

struct node
{
	int data;
	node *next;	
};

//头插法 
bool headinsert(node *&head, int data)
{
	node *p = new node;
	p->data = data;
	if(!p)
	{
		perror("new");
		exit(EXIT_FAILURE);
	}
	p->next = head;
	head = p;
	
	return true;
}

//尾插法
bool tailinsert(node *&head, int data)
{
	node *p = new node;
	p->data = data;
	p->next = nullptr;
	if(head == nullptr)
	{
		head = p;
		
		return true;
	}
	node *q = head;
	while(q->next)
	{
		q = q->next;	
	}
	q->next = p;
	
	return true;
 } 

print(node *head)
{
	node *p = head;
	while(p)
	{
		cout << p->data << " ";
		p = p->next;
	 } 
}

void listPartition(node*& head, int pivot)
{
	node* lh = nullptr; //less head
	node* lt = nullptr; //less tail
	node* eh = nullptr; //equal head
	node* et = nullptr; //equal tail
	node* mh = nullptr; //more head
	node* mt = nullptr; //more tail
	
	node *p = head;

	while(p)
	{
		//链子会断开，提前记录下个节点 
		node* temp = p->next;
		if(p->data < pivot)
		{
			if(!lh)
			{
				lh = lt = p;
				p->next = nullptr;
			}
			else
			{
				lt->next = p;
				lt = p;
				p->next = nullptr;
			}
		}
		else if(p->data == pivot)
		{
			if(!eh)
			{
				eh = et = p;
				p->next = nullptr;
			}
			else
			{
				et->next = p;
				et = p;
				p->next = nullptr;
			}
		}
		else
		{
			if(!mh)
			{
				mh = mt = p;
				p->next = nullptr;
			}
			else
			{
				mt->next = p;
				mt = p;
				p->next = nullptr;
			}
		}
		p = temp;
	}
	//合并三个区域，注意有的区域为空 
	if(!lh)
	{
		if(!eh)
		{
			head = mh;
		}
		else
		{
			et->next = mh;
			head = eh;
		}
	}
	else
	{
		if(!eh)
		{
			lt->next = mh;
			head = lh;
		}
		else
		{
			lt->next = eh;
			et->next = mh;
			head = lh;
		}
	}
}
int main()
{
	node *head = nullptr;
	const int len = 15;
	int arr[len]; 
	pro_arr(arr, len);
	for(int i = 0; i < len; i++)
	{
		tailinsert(head, arr[i]);
	}
	print(head);
	cout << endl;
	listPartition(head, 50);
	print(head);
	return 0;
}
```

## 8.4 特殊链表的拷贝

> 一种特殊的单链表类描述如下：
>
> ```c++
> class Node
> {
> public:
> 	int value;
> 	Node* next;
> 	Node* rand;
> 	Node(int val){value=val;}	
> };
> ```
>
> rand指针时单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，有可能指向null。
>
> 给定一个由Node节点类型组成的无环单链表的头节点，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。
>
> 【要求】
>
> 时间复杂度O(N)，额外空间复杂度O(1)
>
> 思路1，借助于哈希表：
>
> 先遍历一边链表，拷贝链表节点，此时指针为浅拷贝，同时用哈希表存储旧链表各节点与新链表各节点的映射关系。
>
> 然后根据映射设置next与rand指针。
>
> 思路2:
>
> 把拷贝出的新节点连接在旧节点后面，这样，旧节点就能很方便找到其对应的新节点，然后再设置新节点的rand指针，最后将旧节点与新节点分离出来。

方法2code：

```c
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <stack>

using namespace std;

void pro_arr(int arr[], int len)
{
	srand(time(0));
	for(int i = 0; i < len; i++)
	{
		arr[i] = rand() % 100;
		cout << arr[i] << " ";
	}
	cout << endl;
}

class node
{
public: 
	int data;
	node *next;
	node *rand;
 }; 

//头插法 
bool headinsert(node *&head, int data)
{
	node *p = new node;
	p->data = data;
	if(!p)
	{
		perror("new");
		exit(EXIT_FAILURE);
	}
	p->next = head;
	head = p;
	
	return true;
}

//尾插法
bool tailinsert(node *&head, int data, node** addr)
{
	static int i = 0;
	node *p = new node;
	addr[i++] = p;
	p->data = data;
	p->next = nullptr;
	if(head == nullptr)
	{
		head = p;
		
		return true;
	}
	node *q = head;
	while(q->next)
	{
		q = q->next;	
	}
	q->next = p;
	
	return true;
 } 

print(node *head)
{
	node *p = head;
	while(p)
	{
		cout << p->data << " ";
		p = p->next;
	 }
	 cout << endl;
	 p = head;
	 while(p)
	{
		cout << p->rand->data << " ";
		p = p->next;
	 }  
}

void copylist(node*& head, node*& newhead)
{
	node* p = head;
	while(p)
	{
		node *q = new node;
		q->data = p->data;
		q->next = p->next;
		p->next = q;
		
		p = p->next->next;
	}
	node* s = head;
	//设置新链表的rand指针 
	while(s)
	{
		node *f = s->next;
		f->rand = s->rand->next;
		s = s->next->next;
	} 
	//分离出新链表
	s = head;
	node *ns = nullptr;
	while(s)
	{
		node *f = s->next;
		s->next = f->next;
		if(newhead == nullptr)
		{
			newhead = f;
			ns = f;
			f->next = nullptr;
		}
		else
		{
			ns->next = f;
			f->next = nullptr;
			ns = f; 
		}
		s = s->next;
	}
}
int main()
{
	node *head = nullptr;
	const int len = 15;
	int arr[len];
	//记录各节点地址，方便设置randn 
	node *addr[len] = {}; 
	pro_arr(arr, len);
	//构建链表 
	for(int i = 0; i < len; i++)
	{
		tailinsert(head, arr[i], addr);
	}
	//初始化随机指针
	node *p = head;
	while(p)
	{
		int i = 0;
		i = rand() % len;
		p->rand = addr[i];
		p = p->next;
	 }
	//print(head);
	node* newhead = nullptr;
	copylist(head, newhead);
	print(newhead);
	return 0;
}
```

## 8.5 判断链表是否有环，并求环的起点

> **判断一个链表是否有环，有环则返回环的起点。**
>
> 方法一：借用哈希表
>
> 方法二：借用快慢指针，快指针分别从第一个节点和第三个节点出发，快指针一次迈两步，慢指针一次迈一步，如果存在环，快指针和慢指针会相遇，相遇后，快指针回到头节点变为一步一步前进，慢指针则依旧在原地一次迈一步，快慢指针再次相遇时即为环的起点。

方法二code：

```c
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <stack>

using namespace std;

void pro_arr(int arr[], int len)
{
	srand(time(0));
	for(int i = 0; i < len; i++)
	{
		arr[i] = rand() % 100;
		cout << arr[i] << " ";
	}
	cout << endl;
}

class node
{
public: 
	int data;
	node *next;
 }; 

//头插法 
bool headinsert(node *&head, int data)
{
	node *p = new node;
	p->data = data;
	if(!p)
	{
		perror("new");
		exit(EXIT_FAILURE);
	}
	p->next = head;
	head = p;
	
	return true;
}

//尾插法
bool tailinsert(node *&head, int data, node** addr)
{
	static int i = 0;
	node *p = new node;
	p->data = data;
	p->next = nullptr;
	addr[i++] = p;
	if(head == nullptr)
	{
		head = p;
		
		return true;
	}
	node *q = head;
	while(q->next)
	{
		q = q->next;	
	}
	q->next = p;
	
	return true;
 } 

print(node *head, int len)
{
	node *p = head;
	for(int i = 0; i < len; i++)
	{
		cout << p->data << " ";
		p = p->next;
	}
	 cout << endl;  
}

node* isLooped(node *head)
{
	if(!head)
	{
		return nullptr;
	}
	node* s = head;
	node* f = head;
	while(f->next && f->next->next)
	{
		s = s->next;
		f = f->next->next;
		if(s == f)
		{
			break;
		}
	}
	// 无环 
	if(!f->next || !f->next->next)
	{
		return nullptr;
	}
	//有环
	f = head;
	while(f != s)
	{
		f = f->next;
		s = s->next;
	 } 
	 return s;
}

int main()
{
	node *head = nullptr;
	const int len = 5;
	int arr[len];
	//记录各节点地址
	node *addr[len] = {}; 
	pro_arr(arr, len);
	//构建链表 
	for(int i = 0; i < len; i++)
	{
		tailinsert(head, arr[i], addr);
	}
	//构建环
	int start = 0;
	start = rand() % (len + 1);
	if(start < len)
	{
		cout << start << endl;
		addr[len - 1]->next = addr[start];
	 } 
	//print(head, len);
	//判断是否有环。
	node *p = isLooped(head);
	if(!p)
	{
		cout << "无环！" << endl; 
	 }
	 else
	 {
	 	cout << p->data << endl;
	  } 
	return 0;
}
```



## 8.6 判断两个链表是否相交

> 给定两个可能有环有可能无环的单链表，头节点head1和head2。
>
> 请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交，返回null
>
> 【要求】
>
> 如果两个链表长度之和为N，时间复杂度为O(N)，额外空间复杂度为O(1)
>
> > **当链表1和链表2都无环时，**若两链表相交，则自相交的节点起后面都是两链表的公共部分，此时分别遍历两链表找到最后的一个结点对比，若其地址相同，则说明两链表相交，否则不相交。若相交，则从长链表中可能是公共部分的节点开始遍历，与另一链表的节点对比找相交点。
> >
> > 当一个链表有环，另外一个链表无环时，两链表不可能相交。
> >
> > **当两个链表都有环时**，存在三种情况，1）不相交，2）相交，且入环节点相同，3）相交，且入环节点不一样，则有两个起始相交节

```C
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <stack>

using namespace std;

void pro_arr(int arr[], int len)
{
	static int i = 0;
	srand(time(0) + i);
	for(int i = 0; i < len; i++)
	{
		arr[i] = rand() % 100;
	}
	cout << endl;
	i += 100;
}

class node
{
public: 
	int data;
	node *next;
 }; 

//尾插法
bool tailinsert(node *&head, int data, node** addr, int i)
{
	node *p = new node;
	p->data = data;
	p->next = nullptr;
	addr[i++] = p;
	if(head == nullptr)
	{
		head = p;
		
		return true;
	}
	node *q = head;
	while(q->next)
	{
		q = q->next;	
	}
	q->next = p;
	
	return true;
 } 

print(node *head, int len)
{
	node *p = head;
	for(int i = 0; i < len; i++)
	{
		cout << p->data << " ";
		p = p->next;
	}
	 cout << endl;  
}

node* isLooped(node *head)
{
	if(!head)
	{
		return nullptr;
	}
	node* s = head;
	node* f = head;
	while(f->next && f->next->next)
	{
		s = s->next;
		f = f->next->next;
		if(s == f)
		{
			break;
		}
	}
	// 无环 
	if(!f->next || !f->next->next)
	{
		return nullptr;
	}
	//有环
	f = head;
	while(f != s)
	{
		f = f->next;
		s = s->next;
	 } 
	 return s;
}

node* isCrossed(node* &head1, node* &head2)
{
	node* p1 = isLooped(head1);
	node* p2 = isLooped(head2);
	//两链表都无环时 
	if(!p1 && !p2)
	{
		node* t1 = head1;
		node* t2 = head2;
		int len = 0;
		while(t1->next)
		{
			t1 = t1->next;
			len++;
		}
		while(t2->next)
		{
			t2 = t2->next;
			len--;
		}
		//尾节点非共同节点，说明两链表不相交 
		if(t1 != t2)
		{
			return nullptr; 
		}
		t1 = len >= 0 ? head1 : head2;
		t2 = len >=0 ? head2 : head1;
		len = abs(len);
		//寻址到可能为相交点的节点 
		while(len)
		{
			t1 = t1->next;
			len--;
		}
		while(t1 != t2)
		{
			t1 = t1->next;
			t2 = t2->next;	
		}
		return t1;	
	}
	//当两链表有环，且入环节点相同时 
	else if(p1 == p2)
	{
		node* t1 = head1;
		node* t2 = head2;
		int len = 0;
		while(t1 != p1)
		{
			t1 = t1->next;
			len++;
		}
		while(t2 != p2)
		{
			t2 = t2->next;
			len--;	
		}
		t1 = len >= 0 ? head1 : head2;
		t2 = len < 0 ? head1 : head2;
		len = abs(len);
		while(len)
		{
			t1 = t1->next;
			len--;
		}
		while(t1 != t2)
		{
			t1 = t1->next;
			t2 = t2->next;
		}
		return t1;	
	} 
	//两链表都有环，且入环节点不一样 ， 
	else if( !p1 && !p2 && (p1 != p2))
	{
		node* q = p1;
		while(1)
		{
			if(q != p2)
			{
				q = q->next;
			}
			else
			{
				return q;
			}
			if(q == p1)
			{
				return nullptr;	
			} 
		} 
	}
	//一个链表有环，一个链表无环，则两链表不可能相交 
	else
	{
		return nullptr;
	 } 
}

int main()
{
	//构建链表1 
	node *head1 = nullptr;
	const int len = 20;
	int arr[len];
	//记录各节点地址，方便设置randn 
	node *addr[len] = {}; 
	pro_arr(arr, len);
	//构建链表 
	for(int i = 0; i < len; i++)
	{
		tailinsert(head1, arr[i], addr, i);
	}
	print(head1, len); 
	//构建环
//	int start = 0;
//	start = rand() % (len + 1);
//	if(start < len)
//	{
//		cout << start << endl;
//		addr[len - 1]->next = addr[start];
//	 } 
	
	//构建链表2 
	node* head2 = nullptr;
	const int len2 = 10;
	int arr2[len2] = {};
	node *addr2[len2] = {}; 
	pro_arr(arr2, len2);
	for(int i = 0; i < len2 - 3; i++)
	{
		tailinsert(head2, arr2[i], addr2, i);
	}
	addr2[len2 - 4]->next = addr[len - 3];
	print(head2, len2);
	
	//判断两个链表是否相交
	cout << isCrossed(head1, head2)->data << endl;
	return 0;
}
```

## 8.6 删除任意节点

> 在不知单链表的头节点的情况下，只给想要删除的节点，把该节点删除？
>
> 不能

# 9 二叉树

## 9.1 二叉树基础

> 结构描述：
>
> ```c
> struct Node
> {
> 	int value;
> 	Node* left;
> 	Node* right;
> };
> ```
>
> ​	二叉树的先序、中序、后序遍历：
>
> > 先序：任何子树的处理顺序都是，先头节点，再左子树，然后右子树
> >
> > 中序：任何子树的处理顺序都是，先左子树，再头节点，然后右子树
> >
> > 后序：任何子树的处理顺序都是，先左子树，再右子树，然后头节点
> >
> > 递归方式实现二叉树的先序、中序和后序遍历：
> >
> > 1) 理解递归序
> > 2) 先序、中序、后序都可以在递归序的基础上加工出来
> > 3) 第一次到达一个节点就打印就是先序、第二次到达打印即中序，第三次到达打印即为后序
> >
> > ![image-20221030221132251](https://cdn.jsdelivr.net/gh/moshang1314/myBlog@main/image/image-20221030221132251.png)
> >
> > 递归形式遍历代码如下：
> >
> > ```c
> > #include <iostream>
> > #include <string>
> > #include <cmath>
> > 
> > using namespace std;
> > 
> > class Node
> > {
> > public:
> > 	int m_data;
> > 	Node* m_left;
> > 	Node* m_right;
> > 	Node(int data, Node* left = nullptr, Node* right = nullptr)
> > 	{
> > 		m_data = data;
> > 		m_left = left;
> > 		m_right = right;
> > 	}
> > };
> > 
> > void pre(Node *head)
> > {
> > 	if(head == nullptr)
> > 	{
> > 		return;
> > 	}
> > 	cout << head->m_data << " ";
> > 	pre(head->m_left);
> > 	pre(head->m_right);
> > }
> > 
> > void in(Node *head)
> > {
> > 	if(head == nullptr)
> > 	{
> > 		return;
> > 	}
> > 	in(head->m_left);
> > 	cout << head->m_data << " ";
> > 	in(head->m_right);
> > }
> > 
> > void pos(Node *head)
> > {
> > 	if(head == nullptr)
> > 	{
> > 		return;
> > 	}
> > 	pos(head->m_left);
> > 	pos(head->m_right);
> > 	cout << head->m_data << " ";
> > }
> >  
> > int main()
> > {
> > 	//构建二叉树
> > 	Node *head = nullptr;
> > 	Node *p7 = new Node(7);
> > 	Node *p6 = new Node(6);
> > 	Node *p5 = new Node(5);
> > 	Node *p4 = new Node(4);
> > 	Node *p3 = new Node(3, p6, p7);
> > 	Node *p2 = new Node(2, p4, p5);
> > 	Node *p1 = new Node(1, p2, p3);
> > 	head = p1;
> > 	
> > 	cout << "先序遍历为："; 
> > 	pre(head);
> > 	cout << endl;
> > 	
> > 	cout << "中序遍历为："; 
> > 	in(head);
> > 	cout << endl;
> > 	
> > 	cout << "后序遍历为："; 
> > 	pos(head);
> > 	cout << endl; 
> > 	return 0;
> > }
> > ```
> >
> > 非递归方式实现二叉树的先序、中序和后序遍历
> >
> > 1) 任何递归函数都可以改成非递归形式
> > 2) 自己设计压栈来实现
> >
> > > **如先序遍历（头左右）：**
> > >
> > > 1) 弹出打印
> > > 2) 如有右孩子，压入右孩子
> > > 3) 如有左孩子，压入左孩子
> > >
> > > **后序遍历（左右头）：**
> > >
> > > 方法一：
> > >
> > > 先以（头右左）序遍历，后反转过来就是后序遍历：
> > >
> > > 1) 准备两个栈
> > > 2) 弹出压入第二个栈
> > > 3) 如有左孩子，压入左孩子（第一个栈）
> > > 4) 如有右孩子，压入右孩子（第一个栈）
> > > 5) 最后依次出第二个栈
> > >
> > > **中序遍历（左头右）：** 
> > >
> > > 1) 将左孩子依次压入栈，直到节点的左孩子为空时
> > > 2) 出栈打印，然后遍历其右孩子，即重复1)
> > >
> > > ```c
> > > #include <iostream>
> > > #include <string>
> > > #include <cmath>
> > > #include <stack>
> > > 
> > > using namespace std;
> > > 
> > > class Node
> > > {
> > > public:
> > > 	int m_data;
> > > 	Node* m_left;
> > > 	Node* m_right;
> > > 	Node(int data, Node* left = nullptr, Node* right = nullptr)
> > > 	{
> > > 		m_data = data;
> > > 		m_left = left;
> > > 		m_right = right;
> > > 	}
> > > };
> > > /*
> > > 1) 弹出打印
> > > 2) 如有右孩子，压入右孩子
> > > 3) 如有左孩子，压入左孩子
> > > */
> > > void pre(Node* head)
> > > {
> > > 	stack<Node*> s;
> > > 	s.push(head);
> > > 	while(s.size() > 0)
> > > 	{
> > > 		Node* temp = s.top();
> > > 		cout << temp->m_data << " ";
> > > 		s.pop();
> > > 		if(temp->m_right)
> > > 		{
> > > 			s.push(temp->m_right);
> > > 		}
> > > 		if(temp->m_left)
> > > 		{
> > > 			s.push(temp->m_left);
> > > 		}	
> > > 	}
> > > }
> > > 
> > > void in(Node* head)
> > > {
> > > 	stack<Node*> s;
> > > 	while(s.size() > 0 || head)
> > > 	{
> > > 		if(head)
> > > 		{
> > > 			s.push(head);
> > > 			head = head->m_left;
> > > 		}
> > > 		else
> > > 		{
> > > 			head = s.top();
> > > 			s.pop();
> > > 			cout << head->m_data << " ";
> > > 			head = head->m_right;
> > > 		}
> > > 	}
> > > }
> > > 
> > > void pos(Node* head)
> > > {
> > > 	stack<Node*> s1;
> > > 	stack<Node*> s2;
> > > 	s1.push(head);
> > > 	while(s1.size() > 0)
> > > 	{
> > > 		Node* temp = s1.top();
> > > 		s1.pop();
> > > 		s2.push(temp);
> > > 		if(temp->m_left)
> > > 		{
> > > 			s1.push(temp->m_left);
> > > 		}
> > > 		if(temp->m_right)
> > > 		{
> > > 			s1.push(temp->m_right);
> > > 		}
> > > 	}
> > > 	while(s2.size() > 0)
> > > 	{
> > > 		cout << s2.top()->m_data << " ";
> > > 		s2.pop();
> > > 	 } 
> > > }
> > > 
> > > void pos2(Node* head)
> > > {
> > > 	Node* c = nullptr;
> > > 	Node* h = nullptr;
> > > 	stack<Node*> s;
> > > 	s.push(head);
> > > 	while(s.size() > 0)
> > > 	{
> > > 		c = s.top();
> > > 		if(c->m_left != nullptr && h != c->m_left && h != c->m_right)
> > > 		{
> > > 			s.push(c->m_left);
> > > 		}
> > > 		else if(c->m_right != nullptr && h != c->m_right)
> > > 		{
> > > 			s.push(c->m_right);
> > > 		}
> > > 		else
> > > 		{
> > > 			s.pop();
> > > 			cout << c->m_data << " ";
> > > 			h = c;
> > > 		}
> > > 	}
> > > }
> > > 
> > > void pos3(Node* head)
> > > {
> > > 	stack<Node*> s;
> > > 	Node* c = nullptr;
> > > 	Node* h = nullptr;
> > > 	s.push(head);
> > > 	while(s.size() > 0)
> > > 	{
> > > 		c = s.top();
> > > 		if(c->m_right != nullptr && h != c->m_right && h != c->m_left)
> > > 		{
> > > 			s.push(c->m_right);
> > > 		}
> > > 		if(c->m_left != nullptr && h != c->m_right && h != c->m_left)
> > > 		{
> > > 			s.push(c->m_left);
> > > 		}
> > > 		if((c->m_right == nullptr && c->m_left == nullptr) || (c->m_right && h == c->m_right) || (!c->m_right && h == c->m_left))
> > > 		{
> > > 			s.pop();
> > > 			h = c;
> > > 			cout << c->m_data << " ";
> > > 		}
> > > 	}
> > > }
> > >  
> > > int main()
> > > {
> > > 	//构建二叉树
> > > 	Node *head = nullptr;
> > > 	Node *p11 = new Node(11);
> > > 	Node *p10 = new Node(10);
> > > 	Node *p9 = new Node(9);
> > > 	Node *p8 = new Node(8);
> > > 	Node *p7 = new Node(7);
> > > 	Node *p6 = new Node(6);
> > > 	Node *p5 = new Node(5, p10, p11);
> > > 	Node *p4 = new Node(4, p8, p9);
> > > 	Node *p3 = new Node(3, p6, p7);
> > > 	Node *p2 = new Node(2, p4, p5);
> > > 	Node *p1 = new Node(1, p2, p3);
> > > 	head = p1;
> > > 	
> > > 	cout << "先序遍历为："; 
> > > 	pre(head);
> > > 	cout << endl;
> > > 	
> > > 	cout << "中序遍历为："; 
> > > 	in(head);
> > > 	cout << endl;
> > > 	
> > > 	cout << "后序遍历为："; 
> > > 	pos(head);
> > > 	cout << endl; 
> > > 	
> > > 	cout << "后序遍历为："; 
> > > 	pos2(head);
> > > 	cout << endl; 
> > > 	
> > > 	cout << "后序遍历为："; 
> > > 	pos3(head);
> > > 	cout << endl; 
> > > 	return 0;
> > > }
> > > ```
>
> 实现二叉树的按层遍历：
>
> > 1) 其实就是宽度优先遍历，用队列
> > 2) 可以通过设置flag变量的方式，来实现某一层的结束
