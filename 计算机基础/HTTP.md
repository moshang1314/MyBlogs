# 1 概述

## 1.1 事务

> 一个HTTP事务由一条（从客户端发往服务器）请求命令和一个（从服务器发回客户端的）响应结果组成。这种通信是通过名为HTTP报文（HTTP message）的格式化数据块进行的，如下图所示：
>
> ![image-20230309185049322](https://pic1.xuehuaimg.com/proxy/https://cdn.jsdelivr.net/gh/moshang1314/myBlog@main/image/image-20230309185049322.png)

## 1.2 方法

> ​	HTTP支持几种不同的请求命令，这些命令被称为HTTP方法（HTTP method）。每条HTTP请求报文都包含一个方法。这个方法会告诉服务器要执行什么动作（获取一个Web页面、运行一个网关程序、删除一个文件等）。下表列出了五种常见的HTTP方法。
>
> | HTTP方法 | 描述                                             |
> | -------- | ------------------------------------------------ |
> | GET      | 从服务器向客户端发送命名资源                     |
> | PUT      | 将来自客户端的数据存储到一个命名的服务器资源中去 |
> | DELETE   | 从服务器中删除命名资源                           |
> | POST     | 将客户端数据发送到一个服务器网关应用程序         |
> | HEAD     | 仅发送命名资源响应中的HTTP首部                   |

## 1.3 状态码

> ​	每条HTTP响应报文返回时都会携带一个状态码。状态码是一个三位数字的代码，告知客户端请求是否成功，或者是否需要采取其他动作。下表显示了几种常见的状态码。
>
> | HTTP状态码 | 描述                                     |
> | ---------- | ---------------------------------------- |
> | 200        | OK。文档正确返回                         |
> | 302        | Redirect（重定向）。到其他地方去获取资源 |
> | 404        | Not Found（没找到）。无法找到这个资源    |
>
> 伴随着每个数字状态码，HTTP还会发送一条解释性的“原因短语”文本。（参加图1-5中的响应报文）。包含文本短语主要是为了进行描述，所有的处理过程使用的都是数字码。

## 1.4 Web页面中可以包含多个对象

> ​	应用程序完成一项任务时通常会发布多个HTTP事务。比如，Web浏览器会发布一系列HTTP事务来获取并显示一个包含了丰富图片的Web页面。浏览器会执行一个事务来获取描述页面布局的HTML“框架”，然后发布另外的HTTP事务来获取每个嵌入式图片、图像面板、java小程序。这些嵌入式资源甚至可能位于不同的服务器上。因此，一个“Web页面”通常并不是单个资源，而是一组资源的集合。
>
> ![image-20230309221753721](https://pic1.xuehuaimg.com/proxy/https://cdn.jsdelivr.net/gh/moshang1314/myBlog@main/image/image-20230309221753721.png)

## 1.5 报文

> HTTP报文时由一行一行的简单字符串组成的。HTTP报文都是纯文本，不是二进制代码，所以人们可以很方便地对其进行读写。图1-7显示了一个简单事务所使用的HTTP报文。
>
> ![image-20230309222112765](https://pic1.xuehuaimg.com/proxy/https://cdn.jsdelivr.net/gh/moshang1314/myBlog@main/image/image-20230309222112765.png)
>
> 从客户端发往Web服务器的HTTP报文称为请求报文（request message）。从服务器发往客户端的报文称为响应报文（response message），此外没有其他类型的HTTP报文。
>
> HTTP报文包含以下三部分。
>
> * 起始行
>
>   报文的第一行就是起始行，在请求报文中用来说明要做些什么，在响应报文中说出现了什么情况。
>
> * 首部字段
>
>   起始行后面有零个或多个首部字段。每个首部字段都包含一个名字和一个值，为了便于解析，两者之间用冒号来分隔。首部以一个空行结束。添加一个首部字段和添加行一样简单。
>
> * 主体
>
>   空行之后就是可选的报文主体了，其中包含了所有类型的数据。请求主体包括了要发送给Web服务器的数据；响应主体中装载了要返回给客户端的数据。起始行和首部都是文本形式且都是结构化的，而主体则不同，主体中可以包含任意的二进制数据（比如图片、视频、音轨、软件程序）。当然，主体中也可以包含文本。

### 1.5.1 简单的报文实例

> ![image-20230309223304256](https://pic1.xuehuaimg.com/proxy/https://cdn.jsdelivr.net/gh/moshang1314/myBlog@main/image/image-20230309223304256.png)
>
> ![image-20230309223323368](https://pic1.xuehuaimg.com/proxy/https://cdn.jsdelivr.net/gh/moshang1314/myBlog@main/image/image-20230309223323368.png)

## 1.6 连接

> 我们来讨论一下报文是如何通过传输控制协议（Transmission Control Protocol, TCP）连接从一个地方搬移到另一个地方去的。
>
> [TCP数据传输 - 简书 (jianshu.com)](https://www.jianshu.com/p/c31d67c4043a)[TCP数据传输 - 简书 (jianshu.com)](https://www.jianshu.com/p/c31d67c4043a)

### 1.6.1 TCP/IP

> HTTP是个应用层协议。HTTP无需操心网络通信的具体细节；它把联网的细节都交给了通用、可靠的因特网传输协议TCP/IP。
>
> TCP提供了：
>
> * 无差错的数据传输；
>
> * 按序传输（数据总是会按照发送的顺序到达）；
>
> * 未分段的数据流（可以在任意时刻以任意尺寸将数据发送出去）。
>
>   因特网自身就是基于TCP/IP的，TCP/IP是全世界的计算机和网络设备常用的层次化分组交换网络协议集。TCP/IP隐藏了各种网络和硬件的特点及弱点，使各种类型的计算机和网络都能够进行可靠地通信。
>
> ​	只要建立了TCP连接，客户端和服务器之间的报文交换就不会丢失、不会被破坏，也不会在接收时出现错序了。
>
> ​	用网络术语来说，HTTP协议位于TCP的上层。HTTP使用TCP来传输其报文数据。与之类似，TCP则位于IP的上层。
>
> ![image-20230310194727142](https://pic1.xuehuaimg.com/proxy/https://cdn.jsdelivr.net/gh/moshang1314/myBlog@main/image/image-20230310194727142.png)

### 1.6.2 连接、IP地址及端口

> ​	在HTTP客户端向服务器发送报文之前，需要用网际协议（Internet Protocol, IP)地址和端口号在客户端和服务器之间建立一条TCP/IP连接。
>
> ​	在TCP中，你需要知道服务器的IP地址，以及与服务器上运行的特定软件相关的TCP端口号。
>
> ​	这就行了，但最初怎么获得HTTP服务器的IP地址和端口号呢？当然是通过URL了！URL就是资源的地址，所以自然能够为我们提供存储资源的机器的IP地址。我们来看几个URL：
>
> ![image-20230310202219152](https://pic1.xuehuaimg.com/proxy/https://cdn.jsdelivr.net/gh/moshang1314/myBlog@main/image/image-20230310202219152.png)
>
> 第一个URL使用了机器的IP地址，207.200.83.29以及端口号80.
>
> 第二个URL没有使用数字形式的IP地址，它使用的是文本形式的域名，或者称为主机名(www.netscape.com)。主机名就是IP地址比较人性化的别称。可以通过一种域名服务(Domain Name Service, DNS)的机制方便地将主机名转换为IP地址，这样所有问题就都解决了。
>
> 最后一个URL没有端口号。HTTP的URL中没有端口号时，可以假设默认端口时80.有了IP地址和端口号，客户端就可以很方便地通过TCP/IP进行通信了。下图显示了浏览器时怎样通过HTTP显示位于远端服务器中的某个简单HTML资源的。
>
> ![image-20230310202836177](https://pic1.xuehuaimg.com/proxy/https://cdn.jsdelivr.net/gh/moshang1314/myBlog@main/image/image-20230310202836177.png)
>
> 步骤如下：
>
> 1) 浏览器从URL中解析出服务器的主机名；
> 2) 浏览器将服务器的主机名转换成服务器的IP地址；
> 3) 浏览器将端口号（如果有的话）从URL中解析出来；
> 4) 浏览器建立一条与Web服务器的TCP连接；
> 5) 浏览器向服务器发送一条HTTP请求报文；
> 6) 服务器向浏览器回送一条HTTP响应报文；
> 7) 关闭连接，浏览器显示文档。

### 1.6.3 使用Telnet实例

> Telnet程序可以将键盘连接到某个目标TCP端口，并将此TCP端口的输出回送到显示屏上。Telnet常用于远程终端会话，但它几乎可以连接所有的TCP服务器，包括HTTP服务器。
>
> 可以通过Telnet程序直接与Web服务器进行对话。通过Telnet可以打开一条到某台机器上某个端口的TCP连接，然后直接向那个端口输入一些字符。Web服务器会将Telnet程序作为一个Web客户端来处理，所有回送给TCP连接的数据都会显示在屏幕上。
>
> 我们用Telnet与一个实际的Web服务器进行交互。我们要用Telnet获取URL http://www.joes-hardware.com:80/tools.html所指向的文档。
>
> 我们来看看会发生什么情况。
>
> * 首先，查找www.joes-hardware.com的IP地址，打开一条到那台机器端口80的TCP连接。Telnet会为我们完成那些“跑腿儿”的工作。
> * 一旦打开了TCP连接，就要输入HTTP请求了。
> * 请求结束（由一个空行表示）之后，服务器会在一条HTTP响应中将内容回送并关闭连接。
>
> 下图显示了对http://www.joes-hardware.com:80/tools.html的HTTP请求实例。我们输入的内容用粗体字表示。
>
> ![image-20230310204143577](https://pic1.xuehuaimg.com/proxy/https://cdn.jsdelivr.net/gh/moshang1314/myBlog@main/image/image-20230310204143577.png)
>
> Telnet会查找主机名并打开一条连接，连接到www.joes-hardware.com的端口80上监听的Web服务器。这条命令之后的三行内容时Telnet的输出，告诉我们已经建立了连接。
>
> 然后我们输入最基本的请求命令GET /tools.html HTTP/1.1,发送一个提供了源主机名的Host首部，后面跟上一个空行，请求从服务器www.joes-hardware.com上获取资源tools.html。随后，服务器会以一个响应行、几个响应首部、一个空行和最后面的HTML文档主体来应答。
>
> 要明确的是，Telnet可以很好的模拟HTTP客户端，但不能作为服务器使用。而且对Telnet做脚本自动化是很繁琐乏味的。如果想要更灵活的工具，可以去看看nc（netcat）。通过nc可以很方便地操纵基于UDP和TCP的流量（包括HTTP)，还可以为其编写脚本。更多细节可以参见http://www.bgw.org/tutorials/utilities/nc.php。

## 1.7 协议版本

> 现在使用的HTTP协议有几个版本。HTTP应用程序要尽量强健地处理各种不同的HTTP协议变体。目前仍在使用的版本如下。
>
> * HTTP/0.9
>
>   > HTTP的1991原型版本称为HTTP/0.9。这个协议有很多严重的设计缺陷，只应该用于与老客户端的交互。HTTP/0.9支持GET方法，不支持多媒体内容的MIME类型、各种HTTP首部，或者版本号。HTTP/0.9定义的初衷是为了获取简单的HTML对象，它很快就被HTTP/1.0取代了。
>
> * HTTP/1.0
>
>   > 1.0是第一个广泛使用的HTTP版本。**HTTP/1.0添加了版本号、各种HTTP首部、一些额外的方法，以及对多媒体对象的处理**。HTTP/1.0使得包含生动图片的Web页面和交互式表格成为可能，而这些页面和表格促使万维网为人们广泛地接受。
>
> * HTTP/1.0+
>
>   > 在20世纪90年代中叶，很多流行的Web客户端和服务器都在飞快地向HTTP中添加各种特性，以满足快速扩张且在商业上十分成功的万维网的需要。其中很多特性，包括**持久的keep-alive连接、虚拟主机支持，以及代理连接支持都被加入到HTTP之中**，并成为非官方的事实标准。这种非正式的HTTP扩展版本通常称为HTTP/1.0+
>
> * HTTP/1.1
>
>   > HTTP/1.1重点关注的是校正HTTP设计中的结构性缺陷，明确语义，引入重要的性能优化措施，并删除一些不好的特性。HTTP/1.1是当前使用的HTTP版本。
>
> * HTTP-NG(又名HTTP/2.0)

## 1.8 Web的结构组件

> 在因特网上，要与很多Web应用程序进行交互。如：
>
> * 代理
>
>   > 位于客户端和服务器之间的HTTP中间实体。
>
> * 缓存
>
>   > HTTP的仓库，使常用的页面的副本可以保存在离客户端更近的地方。
>
> * 网关
>
>   > 连接其他应用程序的特殊Web服务器
>
> * 隧道
>
>   > 对HTTP通信报文进行盲转发的特殊代理。
>
> * Agent 代理
>
>   > 发起自动HTTP请求的半智能Web客户端。

### 1.8.1 代理

> ​	如下图所示，代理位于客户端和服务器之间，接收所有客户端的HTTP请求，并将这些请求转发给服务器（可能会对请求进行修改之后转发）。对用户来说，这些应用程序就是应该代理，代表用户访问服务器。
>
> ![image-20230312130145155](https://pic1.xuehuaimg.com/proxy/https://cdn.jsdelivr.net/gh/moshang1314/myBlog@main/image/image-20230312130145155.png)
>
> ​	出于安全考虑，通常会将代理作为转发所有Web流量的可信任中间节点使用。代理还可以对请求和响应进行过滤。比如，在企业中对下载的应用程序进行病毒检测，或者对小学生屏蔽一些成人才能看的内容。

### 1.8.2 缓存

> Web缓存（Web cache）或者代理缓存（proxy cache）是一种特殊的HTTP代理服务器，可以将经过代理传送的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了，如下图所示：
>
> ![image-20230312132143219](https://pic1.xuehuaimg.com/proxy/https://cdn.jsdelivr.net/gh/moshang1314/myBlog@main/image/image-20230312132143219.png)
>
> 客户端从附近的缓存下载文档会比从远程Web服务器下载快得多。HTTP定义了很多功能，使得缓存更加高效，并规范了文档的新鲜度和缓存内容的隐私性。

### 1.8.3 网关

> ​	网关（gateway）是一种特殊的服务器，作为服务器的中间实体使用。通常用于将HTTP流量转换成其他的协议。网关接受请求时就好像时自己时资源的源端服务器一样。客户端可能并不知道自己正在与一个网关进行通信。
>
> ​	例如，一个HTTP/FTP网关会通过HTTP请求接收对FTP URI的请求，但通过FTP协议来获取文档（如下图所示）。得到的文档会被封装成一条HTTP报文，发送给客户端。
>
> ![image-20230312140005007](https://pic1.xuehuaimg.com/proxy/https://cdn.jsdelivr.net/gh/moshang1314/myBlog@main/image/image-20230312140005007.png)

### 1.8.4 隧道

> ​	隧道（tunnel）时建立起来之后，就会在两条连接之间对原始数据进行盲转发的HTTP应用程序。HTTP隧道通常用来在一条或多条HTTP连接上转发非HTTP数据，转发时不会窥探数据。
>
> ​	HTTP隧道的一种常见用途时通过HTTP连接承载加密的安全套接字层（SSL，Secure Sockets Layer）流量，这样SSL流量就可以穿过只允许Web流量通过的防火墙了。如图所示，HTTP/SSL隧道收到一条HTTP请求，要求建立一条到目的地址和端口的输出连接，然后再HTTP信道上通过隧道传输加密的SSL流量，这样就可以将其盲目转发到目的服务器上去了。
>
> ![image-20230312143947633](https://pic1.xuehuaimg.com/proxy/https://cdn.jsdelivr.net/gh/moshang1314/myBlog@main/image/image-20230312143947633.png)

### 1.8.5 Agent 代理

> ​	用户Agent代理（或者简称为Agent代理）是代表用户发起HTTP请求的客户端程序。所有发布Web请求的应用程序都是Agent代理。到目前为止，我们只提到过一种HTTP Agent代理：Web浏览器，但用户Agent代理还有很多其他类型。
>
> ​	比如，有些自己会在Web上闲逛的自动用户Agent代理，可以在无人监视的情况下发布HTTP事务并获取内容。这些自动代理的名字通常都很生动，比如“网络蜘蛛”（spiders）或者“Web机器人”（Web robots）。网络蜘蛛会在Web上闲逛，搜集信息以构建有效的Web内容档案，比如一个搜索引擎的数据库或者为比较机器人生成的产品目录。
>
> ![image-20230312152610534](https://pic1.xuehuaimg.com/proxy/https://cdn.jsdelivr.net/gh/moshang1314/myBlog@main/image/image-20230312152610534.png)

# 2 URL和资源

> ​	URL是浏览器寻找信息时所需的资源位置。通过URL，人类和应用程序才能找到、使用并共享因特网上大量的数据资源。
>
> ​	URI是一类更通用的资源标识符，URL实际上是它的一个子集。URI是一个通用的概念，由两个主要的子集URL和URN构成，URL是通过描述资源的位置来标识资源的，而URN则是通过名字来识别资源的，与它们当前所处位置无关。但实际上，HTTP应用程序处理的只是URI的URL子集。
>
> 比如说，你想要获取URL http:www.joes-hardware.com/seasonal/index-fall.html。
>
> 那么URL分为以下三部分。
>
> * URL的第一部分（http)是URL方案。方案可以告知Web客户端怎样访问资源。在这个例子中，URL说明要使用HTTP协议。
> * URL的第二部分（www.joes-hardware.com)指的是服务器的位置。这部分告知Web客户端资源位于何处。
> * URL的第三部分（/seasonal/index-fall.html）是资源路径。路径说明了请求的是服务器上哪个特定的本地资源。
>
> 对此的说明如下图所示：
>
> ![image-20230313130834497](https://pic1.xuehuaimg.com/proxy/https://cdn.jsdelivr.net/gh/moshang1314/myBlog@main/image/image-20230313130834497.png)
>
> **URL可以通过HTTP之外的其他协议来访问资源。它们可以指向因特网上的任意资源**，比如个人的E-mail账户:
>
> ​	mailto:president@whitehouse.gov
>
> 或者其他协议，比如通过文件传输协议（File Transfer Protocol, FTP）才能获取的各种文件：
>
> ​	ftp://ftp.lots-o-books.com/pub/complete-price-list.xls
>
> 或者从流视频服务器上下载电影：
>
> ​	rtsp://www.joes-hardware.com:554/interview/cto_video
>
> ​	URL提供了一种统一的资源命名方式。大多数URL都有同样的：”方案://服务器位置/路径“结构。因此，对网络上的每个资源以及获取这些资源的每种方式来说，命名资源的方法都只有一种，这样不管是谁都可以用名字来找到这个资源了。

> ​	有了Web浏览器，就不再需要用新闻阅读器因特网新闻，或者FTP客户端来访问FTP服务器上的文件了，而且也无需用电子邮件程序来收发E-mail报文了。URL告知浏览器如何对资源进行访问和处理，这有助于简化复杂的网络世界。应用程序可以使用URL来简化信息的访问过程。浏览器通常会用其他应用程序来处理特殊的资源。比如，Interneet Explorer就装载了一个E-mail应用程序来处理那些表示E-mail资源的URL。
>
> ​	URL为用户及他们的浏览器提供了找到信息所需的所有条件。URL定义了用户所需的特定资源，它位于何处以及如何获取它。

## 2.1 URL语法

> ​	URL提供了一种定位因特网上任意资源的手段，但这些资源时可以通过各种不同的方案（比如HTTP、FTP、SMTP）来访问，因此URL语法会随方案的不同而有所不同。
>
> ​	这是不是意味着每种不同的URL方案都会有完全不同的语法呢？实际上，不是的。大部分URL都遵循通用的URL语法，而且不同URL方案的风格和语法都有不少重叠。
>
> ​	大多数URL方案的URL语法都建立在这个由9部分构成的通用格式上：
>
> ```html
> <scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>
> ```
>
> 几乎没有哪个URL中包含了所有这些组件。URL最重要的3个部分是方案(scheme)、主机(host)和路径(path)。下表对各种组件进行了总结。
>
> | 组件 | 描述                                                         | 默认值       |
> | ---- | ------------------------------------------------------------ | ------------ |
> | 方案 | 访问服务器以获取资源时使用哪种协议                           | 无           |
> | 用户 | 某些方案访问资源时需要的用户名                               | 匿名         |
> | 密码 | 用户名后面可能要包含的密码，中间由冒号(:)分隔                | <E-mail地址> |
> | 主机 | 资源宿主服务器的主机名或点分IP地址                           | 无           |
> | 端口 | 资源宿主服务器正在监听的端口号。很多方案都有默认端口号（HTTP的默认端口号为80） | 每个方案特有 |
> | 路径 | 服务器上资源的本地名，由一个斜杠(/)将其与前面的URL组件分隔开来。路径组件的语法是与服务器和方案有关的（URL路径可以分为若干个段，每个段都可以有其特有的组件） | 无           |
> | 参数 | 某些方案会用这个组件来指定输入参数。参数为名/值对。URL中可以包含多个参数字段，他们相互之间以及与路径的其余部分之间用分号(;)分隔。 | 无           |
> | 查询 | 某些方案会用这个组件传递参数以激活应用程序（比如数据库、公告板、搜索引擎以及其他因特网网关）。查询组件的内容没有通用格式。用字符"?"将其与URL的其余部分分隔开来。 | 无           |
> | 片段 | 一小片或者一部分资源的名字。引用对象时，不会将frag字段送给服务器；这个字段时在客户端内部使用的。通过字符"#"将其与URL的其余部分分隔开来。 | 无           |
>

## 2.1.1 方案————使用什么协议

> ​	方案实际上时规定如何访问指定资源的主要标识符，它会告诉负责解析URL的应用程序应该使用什么协议。
>
> ​	方案组件必须以一个字母符号开始，由第一个“：”符号将其与URL的其余部分分隔开来。方案名是大小写无关的，因此URL "http://www.joes-hardware.com"和"HTTP://www.joes-hardware.com"是等价的。

### 2.1.2 主机和端口

> ​	要想在因特网上找到资源，应用程序要知道是哪台机器装载了资源，以及在哪台机器的什么地方可以找到能对目标资源进行访问的服务器。URL的主机和端口组件提供了这两组信息。
>
> ​	主机组件标识了因特网上能够访问资源的宿主机器。可以用上述主机名（www.joes-hardware.com），或者IP地址来表示主机名。比如，下面两个URL就指向同一个资源————第一个是通过主机名，第二个是通过IP地址指向服务器的：
>
> ```bash
> http://www.joes-hardware.com:80/index.html
> http://161.58.228.45:80/index.html
> ```
>
> ​	端口组件标识了服务器正在监听的网络端口。对下层使用了TCP协议的HTTP来说，默认端口号为80.

### 2.1.3 用户名和密码

> 很多服务器都要求输入用户名和密码才会允许用户访问数据。FTP服务器就是这样一个常见的实例。这里有几个例子：
>
> ```shell
> ftp://ftp.prep.ai.mit.edu/pub/gnu
> ftp://anonymous@ftp.prep.ai.mit.edu/pub/gnu
> ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu/pub/gnu
> http://joe:joespasswd@www.joes-hardware.com/sales_info.txt
> ```
>
> ​	第一个例子没有用户或密码组件，只有标准的方案、主机和路径。如果某应用程序使用的URL方案要求输入用户名和密码，比如FTP，但用户没有提供，它通常会插入一个默认的用户名和密码。比如，如果向浏览器提供一个FTP URL，但没有指定用户名和密码，它就会插入anonymous（匿名用户）作为你的用户名，并发送一个默认的密码（Internet Explorer会发送IEUser, Netscape Navigator则会发送mozillla）。
>
> ​	第二个例子显示了一个指定为anonymous的用户名。这个用户名与主机组件组合在一起，看起来就像E-mail地址一样。字符”@“将用户名和密码组件与URL的其余部分分隔开来。
>
> ​	在第三个例子中，指定了用户名（anonymous）和密码（my_passwd），两者之间由字符”：“分隔。

### 2.1.4 路径

> URL的路径组件说明了资源位于服务器的什么地方。路径通常很像一个分级的文件系统路径。比如：
>
> ```
> http://www.joes-hardware.com:80/seasonal/index-fall.html
> ```
>
> ​	这个URL中的路径为/seasonal/index-fall.html，就像UNIX文件系统中的文件系统路径。路径是服务器定位资源时所需的信息。可以用字符"/"将HTTP URL的路径组件划分成一些路径段（path segment)(还是与UNIX文件系统中的文件路径类似).每个路径段都有自己的参数（param)组件。

