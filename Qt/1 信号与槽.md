#  1 信号与槽

当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的。类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect)函数，意思是，用自己的一个的一个函数（成为槽（slot）来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似于观察者模式：当发生了感兴趣的事件，某一个操作就会自动触发。

```c++
#include <QApplication>
#include <QPushButton>

int main(int argc, char *argv[])
{
	QApplication app(argc, argv);
	QPushButton button("Quit");
	QObject::connect(&button, &QPushButton::clicked, &QApplication::quit);
	button.show();
	
	return app.exec();
}
```

## 1.1 QObject.connect()

在Qt5中，QObject::connect有五个重载：

```c++
QMetaObject::Connection connect(const QObject *, const char *, const QObject *, const char *, Qt::ConnectionType);

QMetaObject::Connection connect(const QObject *, const QMetaMethod &, const QObject *, const QMetaMethod &, Qt::ConnectionType);

QMetaObject::Connection connect(const QObject *, const char *, const char *, Qt::ConnectionType)const;

QMetaObject::Connection connect(const QObject *, PointerToMemberFunction, const QObject *, PointerToMemberFunction, Qt::ConnectionType);

QMetaObject::Connection connect(const QObject *, PointerToMemberFunction, Functor);

```

connect(sender, signal, receiver, slot);

这是最常用的形式。第一个参数是发出信号的对象，第二个是发送对象发出的信号，第三个是接收信号的对象，第四个是接收对象在接收到信号之后需要调用的函数。也就是说，当sender发出了signal信号之后，会自动调用receiver的slot函数。

**五个重载函数参数解析**

上面五个重载connect函数。第一个，sender类型是const QObject *，signal的类型是const char*，receiver类型是 const QObject *，slot类型是const char *。这个函数将signal和slot作为字符串处理。第二个，signal和slot都是const QMetaMethod &。我们可以把每个函数看做是QMetaMethod的子类。因此，这种写法可以使用QMetaMethod进行类型比对。第三个，缺少了reciiver，这个函数其实是将this作为receiver。第四个，signa和slot类型则是PointerToMemberFunction。指的是指向成员函数的指针。**第五个，最后一个参数是Functor类型，这个类型可以接收static函数、全局函数以及Lambda表达式。**

由此可以看出，我们的connect（）函数显然是使用的是第五个重载，最后一个参数是QApplication的static函数quit()。也就是说，当我们的button发出了clicked（）信号时，会调用QApplication的quit（）函数，使程序退出。

借助Qt5的信号槽语法，我们可以将一个对象的信号连接到Lambda表达式，例如：

```c++
#include <QApplication>
#include <QPushButton>
#include <QDebug>

int main(int argc, char *argv[])
{
	QApplication app(argc, argv);
	
	QPushButton button("Quit");
	QObject::connect(&button, &QPushButton::clicked, [](bool){
		qDebug() << "You clicked me!";
	});
	button.show();
	
	return app.exec();
}
```

这里的Lambda表达式接收一个bool参数，是因为QPushButton的clicked()信号实际上有一个参数的。Lambda表达式中的qDebug()类似于cout，将后面的字符串打印到标准输出。如果要编译上面的代码，你需要正在pro文件中添加这么一句：

QMAKE_CXXFLAGS += -std==c++0x



```c++
#include <QApplication>
#include <QPushButton>

int main(int argc, char *argv[])
{
	QApplication app(argc, argv);
	
	QPushButton button("Quit");
	QObject::connect(&buuton, SIGNAL(clicked()), &app, SLOT(quit()));
	
	button.show();
	
	return app.exec();
}
```

这里使用了SIGNAL和SLOT两个宏，将两个函数名装换成了字符串。注意，即使quit（）是QApplication的static函数，也必须传入一个对象指针。这也是Qt4的信号槽语法的局限之处。注意到connect函数的signal和slot都是接收字符串，因此，不能将全局函数或者Lambda表达式传入connect()。一旦出现连接不成功的情况，Qt4是没有编译错误（因为编译期不检查字符串是否匹配），而是运行时给出错误。SIGNAL和SLOT的宏参数并不是函数指针，而是除去返回值的函数声明，并且const这种参数修饰符是忽略不计的。

## 1.2 自定义信号与槽

信号槽不是GUI模块提供的，而是Qt核心特性之一。因此我们可以在普通的控制台程序使用信号槽。

有一个报纸类Newspaper，有一个订阅者类Subscriber。Subscriber可以订阅Newspaper。这样，当Newspaper有了新的内容时，Subscriber可以立即得到通知。

```c++
#include <QObject>
//// newspaper.h
class Newspaper() : public QObject
{
	Q_OBJECT
public:
	Newspaper(const QString &name): m_name(name)
	{
	
	}
	
	void send()
	{
		emit newPaper(m_name);
	}
	
	signals:
		void newPaper(const QString &name);
		
	private:
		QString m_name;
};

//// reader.h
#include<QObject>
#include<QDebug>

class Reader : public QObject
{
	Q_OBJECT
public:
	Reader(){}
	
	void receiveNewspaper(const QString &name)
	{
		qDebug() << "Receives Newspaper: " << name;
	}
};

////main.h
#include "newspaper.h"
#include "reader"

int main(int argc, char *argv)
{
	QCoreApplication app(argc, argv);
	
	Newspaper newspaper("Newspaper A");
	Reader reader;
	QObject::connect(&newspaper, &Newspaper::newPaper, &reader, &Reader::reciveNewspaper);
	
	newspaper.send();
	
	return app.exec();
}
```

当我们运行上面的程序时，会看到终端输出Receives Newspaper：Newspaper A这样的字样。

首先看Newspaper这个类。这个类继承了QObject类。只有继承了QObject类的类，才具有信号槽的能力。所以，为了使用信号槽，必须继承QObject。凡是QObject类（不管是直接子类还是间接子类），都应该在第一行代码写上Q_OBJECT。不管是不是使用信号槽，都应该添加这个宏。这个宏的展开将为我们的类提供信号槽机制、国际化机制以及Qt提供的不基于C++RTTI的反射能力。因此，如果你觉得你的类不需要使用信号槽，就不添加这个宏，就是错误的。其它很多操作都会依赖于这个宏。注意，这个宏将有moc（可以理解为一种预处理器，是比C++预处理器更早执行的预处理器）做特殊处理，不仅仅是宏展开这么简单。moc会读取标记了Q_OBJECT的头文件，生成以moc\_为前缀的文件，比如newspaper.h将生成moc\_newspaper.cpp。你可以到构建目录查看这个文件，看看到底增加了什么内容。注意，由于moc只处理头文件中的Q_OBJECT的类声明，不会处理cpp文件中的类似声明。因此，如果我们的Newspaper和Reader类位于main.cpp中，是无法得到moc的处理的。解决方法是，我们手动调用moc工具处理main.cpp，并且将main.cpp中的#include "moc_newspaper.h"就可以了。不过，这是相当繁琐的步骤，为了避免这样修改，我们还是将其放在头文件中。



signal块所列出的，就是该类的信号。信号就是一个个函数名，返回值是void（因为无法活动信号返回值，所以也就无需返回任何值），参数是该类需要让外界知道的数据。信号作为函数名，不需要在cpp文件中添加任何实现（**Qt程序能够使用普通的make进行编译。没有实现的函数名怎么会通过编译？原因还是在moc会帮我们实现信号函数所需要的函数体，所以说，moc并不是单纯的将Q_OBJECT展开，而是做了很多额外的操作**）。



emit是Qt对C++的扩展，是一个关键字（其实也是一个宏）。emit的含义是发出，也就是发出newPaper()信号。感兴趣的接受者会关注这个信号，可能还需要知道是哪份报纸发出的信号？所以，我们将实际的报纸名字m_name当做参数传给了这个信号。当接收者连接这个信号时，就可以通过槽函数获得实际值。这样就完成了数据从发出者到接收者的一个转移。

## 1.3 总结

* 发送者和接收者都需要是QObject的子类（当然，槽函数是拳击函数、Lambda表达式等无需接收者的时候除外）；
* 使用signal标记信号函数，信号是一个函数的声明，返回void，不需要实现函数代码
* 槽函数是普通成员函数，会受到public、provate、protected的影响。
* 使用emit在恰当的位置发送信号
* 使用QObject::connect()函数连接信号和槽

# 2 Qt 模块简介

Qt5模块分为Essentials Modules 和 Add-on Modules两部分。前者是基础模块，在所有平台上都可用；后者是扩展模块，建立在基础模块之上，在能够运行Qt的平台之上可以酌情引入。

## 2.1 Qt基础模块

Qt基础模块分为以下几个：

* Qt Core，提供核心的非GUI功能，所有模块都需要这个模块。这个模块的类包括了动画框架，定时器、各个容器类、时间日期类、事件、IO、JSON、插件机制、智能指针、图形（矩形、路径等）、线程、XML等。所有这些类都可以通过\<QtCore\>头文件引入。
* Qt Gui，提供了GUI程序的基本功能，包括与窗口系统的集成、事件处理、OpenGL和OpenGL ES集成、2D图像、字体、拖放等。这些类一般由Qt用户界面类内部使用，当然也可以用于访问底层的OpenGL ES图像API。Qt Gui模块提供了的是所有图形用户界面程序都需要的通用功能。
* Qt Multimedia，提供了视频、音频、收音机以及摄像头等功能。这些类可以通过\<QtMultimedia\>引入，而且需要在pro文件中添加QT += multimedia。
* Qt NetWork，提供跨平台的网络功能。这些类可以通过\<QtNetWork\>引入，而且需要在pro文件中添加QT += network。
* Qt Qml，提供QML(一种脚本语言，也提供javaScript的交互机制)使用的C++API。这些类可以通过\<QtQml\>引入，需要在pro文件中添加QT += qml。
* **Qt Quick**，允许在 Qt/C++ 程序中嵌入 Qt Quick（一种基于 Qt 的高度动画的用户界面，适合于移动平台开发）。这些类可以通过 \<QtQuick\> 引入，而且需要在 pro 文件中添加 QT += quick。
* **Qt Test**，提供 Qt 程序的单元测试功能。这些类可以通过 \<QtTest\> 引入，而且需要在 pro 文件中添加 QT += testlib。\
* **Qt Webkit**，基于 WebKit2 的实现以及一套全新的 QML API（顺便说一下，Qt 4.8 附带的是 QtWebkit 2.2）。

## 2.2 Qt扩展模块

- **Qt 3D**，提供声明式语法，在 Qt 程序中可以简单地嵌入 3D 图像。Qt 3D 为 Qt Quick 添加了 3D 内容渲染。Qt 3D 提供了 QML 和 C++ 两套 API，用于开发 3D 程序。
- **Qt Bluetooth**，提供用于访问蓝牙无线设备的 C++ 和 QML API。
- **Qt Contacts**，用于访问地址簿或者联系人数据库的 C++ 和 QML API。
- **Qt Concurrent**，封装了底层线程技术的类库，方便开发多线程程序。
- **Qt D-Bus**，这是一个仅供 Unix 平台使用的类库，用于利用 D-Bus 协议进行进程间交互。
- **Qt Graphical Effects**，提供一系列用于实现图像特效的类，比如模糊、锐化等。
- **Qt Image Formats**，支持图片格式的一系列插件，包括 TIFF、MNG、TGA 和 WBMP。
- **Qt JS Backend**，该模块没有公开的 API，是 V8 JavaScript 引擎的一个移植。这个模块仅供 QtQml 模块内部使用。
- **Qt Location**，提供定位机制、地图和导航技术、位置搜索等功能的 QML 和 C++ API。
- **Qt OpenGL**，方便在 Qt 应用程序中使用 OpenGL。该模块仅仅为了程序从 Qt 4 移植到 Qt 5 的方便才保留下来，如果你需要在新的 Qt 5 程序中使用 OpenGL 相关技术，需要使用的是 QtGui 模块中的 QOpenGL。
- **Qt Organizer**，使用 QML 和 C++ API 访问组织事件（organizer event）。organizer API 是 Personal Information Management API 的一部分，用于访问 Calendar 信息。通过 Organizer API 可以实现：从日历数据库访问日历时间、导入 iCalendar 事件或者将自己的事件导出到 iCalendar。
- **Qt Print Support**，提供对打印功能的支持。
- **Qt Publish and Subscribe**，为应用程序提供对项目值的读取、导航、订阅等的功能。
- **Qt Quick 1**，从 Qt 4 移植过来的 QtDeclarative 模块，用于提供与 Qt 4 的兼容。如果你需要开发新的程序，需要使用 QtQuick 模块。
- **Qt Script**，提供脚本化机制。这也是为提供与 Qt 4 的兼容性，如果要使用脚本化支持，请使用 QtQml 模块的 QJS* 类。
- **Qt Script Tools**，为使用了 Qt Script 模块的应用程序提供的额外的组件。
- **Qt Sensors**，提供访问各类传感器的 QML 和 C++ 接口。
- **Qt Service Framework**，提供客户端发现其他设备的服务。Qt Service Framework 为在不同平台上发现、实现和访问服务定义了一套统一的机制。
- **Qt SVG**，提供渲染和创建 SVG 文件的功能。
- **Qt System Info**，提供一套 API，用于发现系统相关的信息，比如电池使用量、锁屏、硬件特性等。
- **Qt Tools**，提供了 Qt 开发的方便工具，包括 Qt CLucene、Qt Designer、Qt Help 以及 Qt UI Tools 。
- **Qt Versit**，提供了对 Versit API 的支持。Versit API 是 Personal Information Management API 的一部分，用于 QContacts 和 vCard 以及 QOrganizerItems 和 iCalendar 之间的相互转换。
- **Qt Wayland**，仅用于 Linux 平台，用于替代 QWS，包括 Qt Compositor API（server）和 Wayland 平台插件（clients）。
- **Qt WebKit**，从 Qt 4 移植来的基于 WebKit1 和 QWidget 的 API。
- **Qt Widgets**，使用 C++ 扩展的 Qt Gui 模块，提供了一些界面组件，比如按钮、单选框等。
- **Qt XML**，SAX 和 DOM 的 C++ 实现。该模块已经废除，请使用 QXmlStreamReader/Writer。
- **Qt XML Patterns**，提供对 XPath、XQuery、XSLT 和 XML Schema 验证的支持。

这里需要强调一点，由于 Qt 的扩展模块并不是 Qt 必须安装的部分，因此 Qt 在未来版本中可能会提供更多的扩展模块，这里给出的也仅仅是一些现在确定会包含在 Qt 5 中的一部分，另外还有一些，比如 Qt Active、Qt QA 等，则可能会在 beta 及以后版本中出现。



# 3 MainWindow

QMainWindow是Qt框架带来的一个预定义好的主窗口类。所谓主窗口，就是普通意义上的应用程序（非游戏之类的那种）最顶层的窗口。

![](G:\images\mw-struct.png)

主窗口的最上面是Window Title，也就是标题栏，通常用于显示标题和控制按钮，比如最大化、最小化和关闭等。通常，各个图形界框架都会使用操作系统本地代码来生成一个窗口。所以，你会看到KDE上面，主窗口的标题栏是KDE样式的；在Windows平台上，标题是Windows风格的。如果你不喜欢本地样式，比如QQ这种，它其实是自己将标题栏绘制出来，这种技术称为DirectUI，也就是无句柄绘制。Window Title下面是Menu Bar，也就是菜单栏，用于显示菜单。窗口最底部是Status Bar，称为状态栏。当我们鼠标滑过某些组件时，可以在状态栏显示某些信息，比如浏览器中，鼠标滑过带有链接的文字，你会在底部看到链接的实际URL。



除了上面说的三个横向的栏，中间是以矩形域表示。我们可以看出，最外层为Tool Bar Area，用于显示工具条区域。之所以使矩形表示，是因为，Qt的主窗口支持多个工具条。你可以将工具条拖放到不同的位置。在工具条区域内部是Dock Widget Area，这是停靠窗口的显示区域。所谓停靠窗口，就像Photoshop的工具箱一样，可以停靠在主窗口的四周，也可以浮动显示。主窗口最中间是Central Widget，就是我们程序的工作区。通常我们会将程序最主要的工作区域放置在这里，类似Word的稿纸或者Photoshop的画布等等。



对于一般的Qt应用程序，我们所需要做的，就是编写我们的主窗口代码，主要是向其中添加各种组件，比如菜单、工具栏等，当然，最重要的就是当中的工作区。当我们将这些都处理完毕之后，基本上程序的工具也可以很好的实现。通常我们的程序主窗口继承自QMainWindow，以便获得QMainWindow提供的各种便利的函数。

# 4 添加动作

Qt使用QAction类作为动作。顾名思义，这个类就是代表窗口的一个动作，这个动作可能显示在菜单，作为一个菜单项，当用户点击该菜单项，对用户的点击做出响应；有可能在工具栏，作为一个工具栏按钮，用户点击这个按钮就可以执行相应的操作。有一点值得注意：无论出现在菜单栏还是工具栏，用户选择之后，所执行的动作应该都是一样的。因此，Qt并没有专门的菜单项类，只是使用QAction类，抽象出公共的动作。当我们把QAction对象添加到菜单，就显示成一个菜单项，添加到工具栏就显示成一个根据按钮。用户可以通过点击菜单项、点击工具栏按钮、点击快捷键来激活这个动作。

QAction包含了图标、菜单文字、快捷键、状态栏文字、浮动帮助等信息。当把一个QAction对象添加到程序中时，Qt自己选择使用哪个属性来显示，无需我们关心。同时，Qt能够保证把QAction对象添加到不同的菜单、工具栏，显示内容是同步的。也就是说，如果我们在菜单中修改了QAction的图标，那么在工具栏上面这个QAction所对应的按钮图标也会同步修改。



下面来看看如何在QMainWindow中使用QAction：

```c++
// mainwindow.h
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>

class MainWindow : public QMainWindow
{
	Q_OBJECT
public:
	MainWindow(QWidget *parent = 0);
	~MainWindow();
	
private:
	void open();

	QAction* openAction;
}

#endif

// mainwindow.cpp
#include<QAction>
#include<QMenuBar>
#include<QMessageBox>
#include<QStatusBar>
#include<QToolBar>

#include "mainwindow.h"

MainWindow::MainWindow(QWidget *parent) : QMainwindow(parent)
{
	setWindowTitle(tr("Main Window"));
	
	openAction = new QAction(QIcon(":/images/doc-open"), tr("&Open..."), this);
	openAction->setShortcuts(QKeySequence::Open);
	openAction->setStatustip(tr("Open an existing file"));
	connect(openAction, &QAction::triggered, this, &MainWindow::open);
	
	QMenu *file = menuBar()->addMenu(tr("&File"));
	file->addAction(openAction);
	
	QToolBar *toolBar = addToolBar(tr("&file"));
	toolBar->addAction(openAction);
	
	statusBar();
}

MainWindow::~MainWindow()
{

}

void MainWindow::open()
{
	QMessageBox::information(this, tr("Information"), tr("Open"));
}

// main.cpp

int main(int argc, char* argv[])
{
	QApplication app(argc, argv);
	
	MainWindow win;
	win.show();
	
	return app.exec();
}
```

运行结果：

![](G:\images\mw-action.png)

这是一个相对完整的程序。首先，我们在`MainWindow`类中添加了一个私有函数`open()`和一个私有变量`openAction`。在 MainWindow 的构造函数中，第一行我们调用了`setWindowTitle()`，设置主窗口的标题。注意我们的文本使用`tr()`函数，这是一个用于 Qt 国际化的函数。在后续章节中我们可以看到，我们可以使用 Qt 提供的国际化工具，将`tr()`函数的字符串提取出来，进行国际化。由于所需进行国际化的文本应该被大多数人认识，所以，`tr()`函数里面一般会是英文文本。

然后，我们在堆上创建了`openAction`对象。在`QAction`构造函数，我们传入了一个图标、一个文本和 this 指针。我们将在后面的文章中解释 this 指针的含义。

图标我们使用了`QIcon`，传入值是一个字符串，这个字符串对应于 Qt 资源文件中的一段路径。Qt 资源文件的后缀名是 qrc。如果我们使用 Qt Creator，我们可以在新建文件中看到 Qt 资源文件。Qt 资源文件其实是一个 XML 描述的文件，表示 Qt 应用程序所需要的各个资源。我们可以使用普通文本编辑器打开这个文件：

```
<RCC>
	<qresource prefix="/images">
		<file alias="doc-open">document-open.png</file>
	</qresource>
</RCC>
```

我们会在后面的章节中详细介绍 Qt 资源文件（注意，资源文件需要在 pro 文件中使用 RESOURCES 引入。）。这里只需要了解，`QIcon`的参数，以 : 开始，意味着从资源文件中查找资源。`:/images/doc-open`就是找到了这里的 document-open.png 这个文件。*（我们使用的是 png 格式的图片，这是 Qt 内置支持的图片格式。其他格式的图片，比如 jpg、gif 则需要插件支持。这些插件实际已经随着 Qt 一同发布。）*

`QAction`第二个参数中，**文本值前面有一个 &，意味着这将成为一个快捷键**。注意看截图中 File 的 F 有一个下划线。

下面一句，我们使用了`setShortcut()`函数，用于说明这个`QAction`的快捷键。Qt 的`QKeySequence`为我们定义了很多内置的快捷键，比如我们使用的 Open。你可以通过查阅 API 文档获得所有的快捷键列表。 这个与我们自己定义的有什么区别呢？简单来说，我们完全可以自己定义一个**tr("Ctrl+O")**来实现快捷键。原因在于，这是 Qt 跨平台性的体现。比如 PC 键盘和 Mac 键盘是不一样的，一些键在 PC 键盘上有，而 Mac 键盘上可能并不存在，或者反之。**使用`QKeySequence`类来添加快捷键，会根据平台的不同来定义相应的快捷键。**



**`setStatusTip()`则实现了当用户鼠标滑过这个 action 时，会在主窗口下方的状态栏显示相应的提示。**



下面的`menuBar()`、`toolBar()`和`statusBar()`三个是`QMainWindow`的函数，用于创建并返回菜单栏、工具栏和状态栏。我们可以从代码清楚地看出，我们向菜单栏添加了一个 File 菜单，并且把这个`QAction`对象添加到这个菜单；同时新增加了一个 File 工具栏，也把`QAction`对象添加到了这个工具栏。我们可以看到，在菜单中，这个对象被显示成一个菜单项，在工具栏变成了一个按钮。至于状态栏，则是出现在窗口最下方，用于显示动作对象的提示信息的。

至于`open()`函数中的内容，我们会在后文介绍。这里可以运行一下，你会看到，触发这个动作，程序会弹出一个提示框。

# 5 Qt资源



Qt资源系统是一个跨平台的资源机制，用于程序运行时所需要的资源以二进制形式存储于可执行文件内部。如果你的程序需要加载特定的资源（图标、文本翻译等），那么，将其放置在资源文件中，就再也不需要担心这些文件的丢失。也就是说，如果你将资源以资源文件形式存储，它会编译到可执行文件内部。

使用Qt Creator可以很方便地创建资源文件，我们可以在工程上右键，选择“添加文件.....",可以在Qt分类下找到”Qt资源文件":

![](G:\images\qtc-qrc-create.png)

点击“选择...”按钮，打开“新建Qt资源文件”对话框。在这里输入资源文件的名字和路径：

![](G:\images\qtc-qrc-name.png)

点击下一步，选择所需要的版本控制系统，然后直接选择完成。我们可以在Qt Creator的左侧文件列表看到“资源文件”一项，也就是我们新建的资源文件。

![](G:\images\qtc-qrc-ui.png)

右侧的编辑区有个“添加”，我们首先需要添加前缀，比如我们将前缀取名为images。然后选中这个前缀，继续点击添加文件，可以找到我们所需添加的文件。这里，我们选择document-open.png文件。当我们完成操作后，Qt Creator应该是这样子的：

![](G:\images\qtc-qrc-added.png)

接下来，我们就可以添加另外的前缀或者另外的文件。这取决于你的需要。当我们添加完成之后，我们就可以通过:开头的路径来找到这个文件。比如，我们的前缀是/images，文件时document-open.png，那么就可以使用:/images/document-open.png找到这个文件。

这么做带来的一个问题是，如果以后我们要更改文件名，比如将document-open.png改成docopen.png，那么，所有使用了这个名字的路径都需要更改。所以，更好的办法是，我们给这个文件取一个别名，以后就可以以这和别名来引用这个文件。具体做法是，选中这个文件，添加别名信息：

![](G:\images\qtc-qrc-alias.png)

这样，我们就可以直接使用:images/doc-open引用到这个资源，无需关心图片的真实文件名。

如果仔细观察，还会看到资源编辑窗口最下方有一个“语言”。这个可以对资源进行国际化。比如我们新建一个前缀，将语言设置为fr，再添加一个文件document-open-fr.png：

![](G:\images\qtc-qrc-lang.png)

我们可以使用:/images/fr/doc-open引用到document-open-fr.png这个文件。这个“语言”的作用是，如果Qt发现，本机的本地化信息是fr的话（QLocale::system().name返回fr_FR），则使用:/images/fr/doc-open这个图片；如果不是，则默认使用:/images/doc-open这个。

如果我们使用文本编辑器打开res.qrc文件，就会看到以下内容：

```xml
<RCC>
	<qresource prefix="/images">
		<file alias="doc-open">document-open.png</file>
	</qresource>
	<qresource prefix="/images/fr" lang="fr">
		<file alias="doc-open">document-open-fr.png</file>
	</qresource>
</RCC>
```

当我们编译工程之后，我们就可以在构建目录中找到qrc_res.cpp文件，这就是Qt将我们的资源编译成了C++代码。

**qt资源文件直接删怎么删也删不掉，去.pro文件中直接删，构建后自己就没了**

1. 选择项目文件*.pro
2. 找到   "RESOURCES +=\
3. 删除相关文件，全部资源都不要就把整个这一段都删除，构建
4. 保存
5. 去工程文件夹里把.qrc文件删掉

**删除资源中的图片后需要执行qmake**

# 6 对象模型

标准C++对象模型在运行时效率方面卓有成效，但是在某些特定问题域下的静态特性就显得捉襟见肘。GUI界面需要同时具有运行时的效率以及更高级别的灵活性。为了解决这一问题，Qt“扩展”了标准C++。所谓“扩展"，实际是在使用标准C++编译器编译Qt源程序之前，Qt先使用一个叫做moc（Meta Object Compiler，元对象编译器）的工具，先对源代码进行一次预处理（注意，这个预处理与标准C++的预处理有所不同。Qt的moc预处理发生在标准C++编译器工作之前，并且Qt的moc预处理不是递归的），生成标准C++源代码，然后再使用标准C++编译器进行编译。如果你曾经为信号函数这样的语法感到奇怪（现在我们已经编译过一些Qt程序，你当注意到了，信号函数是不需要编写实现代码的，那怎么可以通过标准C++的编译呢？），这其实就是moc进行了处理之后的效果。

Qt使用moc，为标准C++增加了一些特性：

* 信号槽机制，用于解决对象之间的通讯
* 可查询，并且可设计的对象属性
* 强大的事件机制以及事件过滤器
* 基于上下文的字符串翻译机制（国际化），也就是tr()函数
* 复杂的定时器实现，用于再事件驱动的GUI中嵌入能够精确控制的任务集成
* 层次化的可查询的对象树，提供一种自然的方式管理对象关系
* 智能指针（QPointer），在对象析构之后自动设为0，防止野指针
* 能够跨越库边界的动态转换机制

通过继承`QObject`类，我们可以很方便地获得这些特性。当然，这些特性都是由moc帮助我们实现的。moc其实实现的是一个叫做元对象系统（meta-object system)的机制。正如上面所说，这是一个标准C++的扩展，使得C++更适合于进行GUI编程。虽然利用模板可以达到类似的效果，但是Qt没有选择使用模板。按照Qt官方的说法，模板虽然是内置语言特性，但是其语法实在是复杂，并且由于GUI是动态的，利用静态的模板机制有时候很难处理。而自己使用moc生成代码更为灵活，虽然效率有些低（一个信号槽的调用大约相当于四个模板函数的调用），不过在现代计算机上，这点特性损耗实在是可以忽略。

## 6.1 对象树

QObject是以对象树的形式组织起来的。当你创建一个QObject对象时，会看到QObject的构造函数接收一个QObject指针作为参数，这个参数就是parent，也就是父对象指针。这相当于，在创建QObject对象时，可以提供一个其父对象，我们创建这个QObject对象会自动添加到其父对象的children()列表。当父对象析构的时候，这个列表中的所有对象也会被析构。（注意，这里的父对象并不是继承意义上的父类！）这种机制在GUI程序设计中相当有用。例如，一个按钮有一个QShortcut(快捷键)对象作为其子对象。当我们删除按钮的时候，这个快捷键也理应被删除。这是合理的。

QWidget是能够在屏幕上显示的一切组件的父类。QWidget继承自QObject，因此也继承了这种对象树关系。一个孩子自动地成为父组件的一个子组件。**因此，它会显示在父组件的坐标系统中，被父组件的边界裁剪。**例如，当用户关闭一个对话框的时候，应用程序将其删除，那么，我们希望属于这个对话框的按钮、图标等应该一起被删除。事实就是如此，因为这些都是对话框的子组件。

当然，我们也可以自己删除子对象，它们会自动从其父对象列表中删除。比如，当我们删除了一个工具栏时，其所在的主窗口会自动将该工具栏从其子对象列表中删除，并且自动调整屏幕显示。

我们可以使用QObject::dumpObjectTree()和QObject::dumpObjectInfo()这两个函数进行这方面的调试。

Qt引入对象树的概念，在一定程度上解决了内存的问题。

当一个QObject对象在堆上创建的时候，Qt会同时为其创建一个对象树。不过，对象树中的对象的顺序是没有定义的。这意味着，销毁这些对象的顺序也是为定义的。Qt保证的是，任何对象树的QObject对象delete的时候，如果这个对象有parent，则自动将其从parent的childern()列表中删除；如果有孩子，则自动delete每一个孩子。Qt保证没有QObject会被delete两次，这是析构顺序决定的。

如果QObject在栈上创建，Qt保持同样的行为。正常情况下，这也不会发生什么问题。来看下面的代码片段：

```c++
{
	QWidget window;
	QPushButton quit("Quit", &window);
}
```

作为父组件的window和作为子组件的quit都是QObject的子类（事实上，它们都是QWidget的子类，而QWidget是QObject的子类）。这段代码是正确的，quit的析构不会被调用两次，因为标准C++(ISO/IEC 14882:2003)要求，局部对象的析构顺序应该是按照创建顺序的相反过程。因此，这段代码在超出作用域是，会先调用quit的析构函数，将其从父对象window的子对象列表中删除，然后才会再调用window的析构函数。

但是，如果我们使用下面的代码：

```c++
{
	QPushButton quit("Quit");
    QWidget window;
    
    quit.setParent(&window);
}
```

情况又有所不同，析构顺序就有了问题。我们看到，再上面的代码中，作为父对象的window会首先被析构，因为它是最后一个创建的对象。再析构过程中，它会调用子对象列表中每一个对象的析构函数，也就是说，quit此时就被析构了。然后，代码继续执行，再window析构之后，quit也会被析构，因为quit也是一个局部变量，再超出作用域的时候当然也需要析构。但是，这时候已经是第二次调用quit的析构函数了，C++不允许调用两次析构函数，因此，程序崩溃了。

由此看来，Qt的对象树机制在一定程度上解决了内存问题，但是也引入了一些值得注意的事情。因此，在Qt中，尽量在构造的时候就指定parent对象，并且大胆在堆上创建。

# 7 布局管理

所谓GUI界面，归根结底，就是一堆组件的叠加。我们创建一个窗口，把按钮放上面，把图标放上面，这样就成了一个界面，在放置时，组件的位置尤其重要。我们必须要指定组件放在哪里，以便窗口能够按照我们需要的方式进行渲染。这就涉及到组件定位的机制。Qt提供了两中种组件定位机制：绝对定位和布局定位。

顾名思义，绝对定位就是一种最原始的定位方法：给出这个组件的坐标和长宽值。这样，Qt就知道该把组件放在哪里以及如何设置组件的大小。但是这样带来的一个问题是，如果用户改变了窗口的大小，比如点击最大化按钮或者使用鼠标拖动窗口边缘，采用绝对定位的组件不会有任何响应的。这也很自然，因为你并没有告诉Qt，在窗口变化时，组件是否要更新自己以及如何更新。如果你需要让组件自动更新——这是常见的需求，比如最大化时，Word总会把稿纸放大，把工具栏拉长——就要自己编写相应的函数来响应这些变化。或者，还有更简单的做法：禁止用户改变窗口大小。但这总不是长远之计。

针对这种变化的需求，Qt提供了另外一种机制——布局——来解决这个问题。你只要把组件放入某一种布局，布局由专门的布局管理器进行管理。当需要调整大小或者位置的时候，Qt使用对应的布局管理器进行调整。下面来看一个例子：

```
#include <QApplication>
#include <QSpinBox>
#include<QSlider>
#include<QHBoxLayout>
int main(int argc, char* argv[])
{
    QApplication app(argc, argv);

    QWidget window;
    window.setWindowTitle("Enter your age");

    QSpinBox *spinBox = new QSpinBox(&window);
    QSlider *slider = new QSlider(Qt::Horizontal, &window);
    spinBox->setRange(0, 130);
    slider->setRange(0, 130);

    QObject::connect(slider, &QSlider::valueChanged, spinBox, &QSpinBox::setValue);
    void (QSpinBox:: *spinBoxSignal)(int) = &QSpinBox::valueChanged;
    QObject::connect(spinBox, spinBoxSignal, slider, &QSlider::setValue);
    spinBox->setValue(35);

    QHBoxLayout *layout = new QHBoxLayout;
    layout->addWidget(spinBox);
    layout->addWidget(slider);
    window.setLayout(layout);

    window.show();

    return app.exec();
}
```

我们可以先来看看运行结果：

![](G:\images\layout-demo.png)

当我们拖动窗口时，可以看到组件自动有了变化：

![](G:\images\layout-demo-2-600x88.png)

我们在这段代码中引入了两个新的组件：QSpinBox和QSlider。QSpinBox就是只能输入数字的输入框，并且带有上下箭头的步进按钮。QSlider则是带有滑块的滑竿。我们可以从上面的截图中清楚的辨别出这两个组件。当我们创建了这两个组件的实例后，我们使用setRange()函数设置其范围。既然我们的窗口标题是“Ener your age”那么把range设置为0到130应该足够了。

将slider的valueChanged()信号同spinBox的setValue()函数相连。这是我们熟悉的。但是，当我们直接写

```c++
QObject::connect(spinBox, &QSpinBox::valueChanged, slider, &QSlider::setValue);
```

的时候，编译器却会报错：

```c++
no matching function for call to 'QObject::connect(QSpinBox*&, <unresolved overloaded function type>, QSlider*&, void (QAbstractSlider::*)(int))'
```

这是怎么回事呢？从出错的信息可以看出，编译器认为QSpinBox::valueChanged是一个overload的函数。我们看一下QSpinBox的文档发现，QSpinBox的确有两个信号：

* void valueChanged(int);
* void valueChanged(const QString&);

当我们使用&QSpinBox::valueChanged取函数指针时，编译器不知道应该取哪一个函数的地址，因此报错。解决的方法很简单，编译器不是不能确定哪一个函数吗？那么我们就显式指定一个函数。方法就是，我们创建一个函数指针，这个函数指针参数指定为int：

```c++
void (QSpinBox:: *spinBoxSignal)(int) = &QSpinBox::valueChanged;
```

然后我们将这个函数指针作为signal，与QSlider的函数连接：

```c++
QObject::connect(spinBox, spinBoxSignal, slider, &QSlider::setValue);
```

这就避免了编译错误。

仔细观察这两个connect()的作用，它们实际完成了一个双向的数据绑定。当然，对于Qt自己的信号函数，我们可以放心的使用。但是，如果是我们自己的信号，应当注意避免发生无限循环！

上面的代码，我们创建了一个QHBoxLayout对象。显然，这是一个布局管理器。然后将这两个组件都添加到这个布局管理器，并且把把该布局管理器设置为窗口的布局管理器。并且，布局管理器很聪明地做出了正确的行为：保持QSpinBox宽度不变，自动拉伸QSlider的宽度。

Qt提供了几种布局管理器供我们选择：

* QHBoxLayout：按照水平方向从做到右布局；
* QVBoxLayout：按照竖直方向从上到下布局；
* QGridLayout：在一个网格中进行布局，类似于HTML的table；
* QFormLayout：按照表格布局，每一行前面是一段文本，文本后面跟随一个组件（通常是输入框），类似于HTML的form;
* QStackedLayout：层叠的布局，允许我们将几个组件按照Z轴方向堆叠，可以形成向导哪种一页一页的效果。

# 8 菜单栏、工具栏和状态栏

在之前的《添加动作》一章中，我们已经了解了，Qt将用户与界面进行交互的元素抽象为一种“动作”，使用QAction类表示。QAction可以添加到菜单上、工具栏上。

我们假设窗口还是建立在QMainWindow类之上，这会让我们的开发简单许多。当然，在实际开发过程中，QMainWindow通常只作为“主窗口”，对话框窗口则更多地使用QDialog类。我们会在后面看到，QDialog类会缺少一些QMainWindow类提供的方便函数，比如menuBar()以及toolBar()。

下面还是回到《添加动作》一文中的代码片段：

```
openAction = new QAction(QIcon(":/images/doc-open"), tr("&Open..."), this);
openAction->setShortcuts(QKeySequence::Open);
openAction->setStatusTip(tr("Open an existing file"));
connect(openAction, &QAction::triggered, this, MainWindow::open);

QMenu *file = menuBar()->addMenu(tr("&File"));
file->addAction(openAction);

QToolBar *toolBar = addToolBar(tr("&File"));
toolBar->addAction(openAction);
```

我们看到，使用 menuBar() 函数，Qt 为我们创建了一个菜单栏。menuBar() 是 QMainWindow 提供的函数，因此你是不会在 QWidget 或者 QDialog 中找到它的。这个函数会返回窗口的菜单栏，如果没有菜单栏则会新创建一个。这也就解释了，为什么我们可以直接使用 menuBar() 函数的返回值，毕竟我们并没有创建一个菜单栏对象啊！原来，这就是 menuBar() 为我们创建好并且返回了的。

Qt 中，表示菜单的类是 QMenuBar（你应该已经想到这个名字了）。QMenuBar 代表的是窗口最上方的一条菜单栏。我们使用其 addMenu() 函数为其添加菜单。尽管我们只是提供了一个字符串作为参数，但是 Qt 为将其作为新创建的菜单的文本显示出来。至于 & 符号，我们已经解释过，这可以为菜单创建一个快捷键。当我们创建出来了菜单对象时，就可以把 QAction 添加到这个菜单上面，也就是 addAction() 函数的作用。

下面的 QToolBar 部分非常类似。顾名思义，QToolBar 就是工具栏。我们使用的是 addToolBar() 函数添加新的工具栏。为什么前面一个是 menuBar() 而现在的是 addToolBar() 呢？因为一个窗口只有一个菜单栏，但是却可能有多个工具栏。如果我们将代码修改一下：

```
QToolBar *toolBar = addToolBar(tr("&File"));
toolBar->addAction(openAction);

QToolBar *toolBar2 = addToolBar(tr("Tool Bar 2"));
toolBar2->addAction(openAction);
```

我们看到，现在有两个工具栏了：

![](G:\images\qtoolbar-2.png)

工具栏可以设置成固定的、浮动的等等，具体设置可以参考 Qt 文档。

前面我们说过，使用 QAction::setStatusTip() 可以设置该动作在状态栏上的提示文本。但我们现在把鼠标放在按钮上，是看不到这个提示文本的。原因很简单，我们没有添加一个状态栏。怎么添加呢？类似前面的 QMainWindow::menuBar()，QMainWindow 有一个 statusBar() 函数。让我们把这个函数添加上去：

```
QToolBar *toolBar2 = addToolBar(tr("Tool Bar 2"));
toolBar2->addAction(openAction);

statusBar();
```

然后编译运行一下：

![](G:\images\statusbar.png)

我们添加了一个孤零零的 statuBar() 显得不伦不类，但是，同前面的 menuBar() 的实现类似，这个函数会返回一个 QStatusBar 对象，如果没有则先创建再返回。

QStatusBar 继承了 QWidget，因此，我们可以将其它任意 QWidget 子类添加到状态栏，从而实现类似 Photoshop 窗口底部那种有比例显示、有网格开关的复杂状态栏。有关 QStatusBar 的更多信息，请参考 Qt 文档。

对于没有这些函数的 QDialog 或者 QWidget 怎么做呢？**要记得，QToolBar 以及 QStatusBar 都是 QWidget 的子类，因此我们就可以将其结合布局管理器添加到另外的 QWidget 上面。QLayout 布局提供了 setMenuBar() 函数，可以方便的添加菜单栏。**具体细节还是详见文档。

至此，我们已经将组成窗口元素介绍过一遍。结合这些元素以及布局管理，我们就应该可以实现一个简单的通用的窗口。当我们完成窗口布局之后，我们就可以考虑向其中添加功能。这就是我们后面章节的内容。

# 9 对话框简介

对话框是GUI程序中不可或缺的组成部分。很多不能或者不适合放入主窗口的功能组件都必须放在对话框中设置。对话框通常会是一个顶层窗口，出现在程序最上层，用于实现短期任务或者简洁的用户交互。尽管Ribbon界面的出现在一定程度上减少了对话框的使用几率，但是，我们依然可以在最新版本的office中发现不少对话框。因此，在可预见的未来，对话框会一直存在于我们的程序之中。

Qt中使用QDialog类实现对话框。就像主窗口一样，我们通常会设计一个类继承QDialog。QDialog(及其子类，以及所有Qt::Dialog类型的类)的对于其parent指针都有额外的解释：如果parent为NULL，则该对话框作为一个顶层窗口，否则则作为其父组件的自对话框（此时，其默认出现的位置是parent的中心）。顶层窗口与非顶层窗口的区别在于，顶层窗口在任务栏会有自己的位置，而非顶层窗口则会共享其父组件的位置。

上面我们使用了前面的示例代码。注意看的是 open() 函数里面的内容。我们使用 QDialog 创建了一个对话框，设置其标题为“Hello, dialog!”，然后调用 exec() 将其显示出来。注意看的是任务栏的图标，由于我们没有设置对话框的 parent 指针，我们会看到在任务栏出现了对话框的位置：

![](G:\images\dialog-without-parent.png)

我们修改一下 open() 函数的内容：

```
void MainWindow::open()
{
	QDialog dialog(this);
	dialog.setWindowTitle(tr("Hello, dialog!"));
	dialog.exec();
}
```

重新运行一下，对比一下就会看到parent的有无对QDialog实例的影响。

对话框分为模态对话框和非模态对话框。所谓模态对话框，就是会阻塞同一应用程序中其它窗口的输入。模态对话框很常见，比如"打开文件"功能。你可以尝试一下记事本的打开文件，当打开文件对话框出现时，我们是不能对除此对话框之外的窗口部分进行操作的。因此相反的是非模态对话框，例如查找对话框，我们可以在显示着对话框的同时，继续对记事本的内容进行编辑。

Qt支持模态对话框和非模态对话框。其中，Qt有两种级别的模态对话框：应用程序级别的模态和窗口级别的模态，默认是应用程序级别的模态。应用程序级别的模态是指，当该种模态的对话框出现时，用户必须首先对对话框进行交互，直到关闭对话框，然后才能访问程序中其它的窗口。窗口级别的模态是指，该模态仅仅阻塞与对话框关联的窗口，但是依然允许用户与程序中其它窗口交互。窗口级别的模态尤其适用于多窗口模式，更详细的讨论可以看https://www.devbean.net/2011/03/qdialog_window_modal/。

Qt使用QDialog::exec()实现应用程序级别的模态对话框，使用QDialog::open()实现窗口级别的模态对话框，使用QDialog::show()实现非模态对话框。回顾一下我们的代码，在上面的示例中，我们调用了exec()将对话框显示出来，因此这就是一个模态对话框。当对话框出现时，我们不能与主窗口进行任何交互，直到我们关闭了该对话框。

下面我们试着将exec()修改为show()，看看非模态对话框：

```
void MainWindow::open()
{
	QDialog dialog(this);
	dialog.setWindowTitle(tr("Hello, dialog!"));
	dialog.show();
}
```

是不是事与愿违？对话框竟然一闪而过！show()函数不会阻塞当前线程，对话框会显示出来，然后函数立即返回，代码继续执行。注意，dialog是建立在栈上的，show()函数返回，MainWindow::open()函数结束，dialog超出作用域被析构，因此对话框消失了。找到了原因就好改了，我们将dialog改成堆上建立，当然就没有这个问题了。

```
void MainWindow::open()
{
	QDialog *dialog = new QDialog;
	dialog->setWindowTitle(tr("Hello, dialog"));
	dialog->show();
}
```

对于一下这个非模态对话框和之前的模态对话框。我们在对话框出现的时候可以与主窗口交互，因此我们可以建立多个相同的对话框：

![](G:\images\non-modal-dialog.png)

如果你足够细心，应该发现上面的代码是有问题的：dialog存在内存泄漏！dialog使用new在堆上分配空间，却一直没有delete。解决方案也很简单：将MainWindow的指针赋给dialog即可。不过，这样做还有一个问题：如果我们的对话框不是在界面类中出现呢？由于QWidget的parent必须是QWidget指针，那就限制了我们不能将一个普通的C++类指针传给Qt对话框。另外，如果内存占用有严格限制的话，当我们将主窗口作为parent时，主窗口不关闭，对话框就不会被销毁，所以会一直占用内存。在这种情景下，我们可以调用deleteLater()函数，或者是设置dialog的WindowAttribute：

```
void MainWindow::open()
{
	QDialog *dialog = new QDialog;
	dialog->setAttribute(Qt::WA_DeleteOnClose); //或者dialog->deleteLater();
	dialog->setWindowTitle(tr("Hello, dialog"));
	dialog->show();
}
```

setAttribute()函数设置对话框关闭时，自动销毁对话框。deleteLater()函数会在当前事件循环结束时销毁该对话框。

## 9.1 对话框数据传递

对话框的出现用于完成一个简单的或者是短期的任务。对话框与主窗口之间的数据交互相当重要。对话框分为模态和非模态两种。我们也将以这两种为例，分别进行阐述。

模态对话框使用了exec()函数将其显示出来。exec()函数的真正含义是开启一个新的事件循环。Qt在开启事件循环之后，系统发出的各种事件才能够被程序监听到。这个事件循环相当于一种轮询的作用。既然是无限循环，当然在开启了事件循环的地方，代码就会被阻塞，后面的语句也就不会被执行到。因此，对于使用了exec()显示的模态对话框，我们可以在exec()函数之后直接从对话框的对象获取到数据值。

看一下下面的代码：

```
void MainWindow::open()
{
	QDialog dialog(this);
	dialog.setWindowTitle(tr("Hello, dialog"));
	dialog.exec();
	
	qDebug() << dialog.result();
}
```

上面的代码中，我们使用exec()显示一个模态对话框。最后一行代码，qDebug()类似于std::cout或者java的System.out.println()；语句，将后面的信息输出到标准输出，一般就是控制台。使用qDebug()需要引入头文件。在exec()函数之后，我们直接可以获取到dialog的数据值。注意，exec()开始了一个事件循环，代码被阻塞到这里。由于exec()函数没有返回，因此下面的result()函数也就不会被执行。指导对话框关闭，exec()函数返回，此时，我们就可以取得对话框的数据。

需要注意一点的是，如果我们设置dialog的属性为WA_DeleteOnClose，那么当对话框关闭时，对象被销毁，我们就不能使用这种办法获取数据了。在这种情况下，我们可以考虑使用parent指针的方式构建对话框，避免设置WA_DeleteOnClose属性；或者是利用另外的方式。

实际上，QDialog::exec()是有返回值的，其返回值是QDialog::Accepted或者QDialog::Rejected。一般我们会使用类似下面的代码：

```
QDialog dialog(this);
if(dialog.exec() == QDialog::Accepted)
{
	//do something
}else
{
	//do something
}
```

来判断对话框的返回值，也就是用户是点击了“确定”还是“取消”。

模态对话框相对简单，如果是非模态对话框，QDialog::show()函数会立即返回，如果我们也这么写，就不可能取得用户输入的数据。因为show()函数不会阻塞主线程，show()立即返回，用户还没来得及输入，就要执行后面的代码，当然是不会有正确结果的。那么我们就应该换一种思路获取数据，那就是信号槽机制。

由于非模态对话框在关闭时可以调用QDialog::accept()或者QDialog::reject()或者更通用的QDialog::done()函数，所以我们可以在这里发出信号。另外，如果找不到合适的信号发出点，我们可以重写QDialog::closeEvent()函数，在这里发出信号。在需要接收数据的窗口（这里是主窗口）连接到这个信号即可。类似的代码片段如下所示：

```
//in dialog
void UserAgeDialog::accept()
{
	emit userAgeChanged(newAge); //newAge is an int
	QDialog::accept();
}

// in main window
void MainWindow::showUserAgeDialog()
{
	UserAgeDialog *dialog = new UserAgeDialog(this);
	connect(dialog, &UserAgeDialog::userAgeChanged, this, &Mainwindow：：setUserAge);
	dualog->show();
}

//
void MainWindow::setUserAge(int age)
{
	userAge = age;
}
```

不要担心如果对话框关闭，是不是还能获取到数据。因为 Qt 信号槽的机制保证，在槽函数在调用的时候，我们始终可以使用 sender() 函数获取到 signal 的发出者。关于 sender() 函数，可以在文档中找到更多的介绍。顺便说一句，sender() 函数的存在使我们可以利用这个函数，来实现一个只能打开一个的非模态对话框（方法就是在对话框打开时在一个对话框映射表中记录下标记，在对话框关闭时利用 sender() 函数判断是不是该对话框，然后从映射表中将其删除）。

## 9.2 标准对话框 QMessageBox

所谓标准对话框，是Qt内置的一系列对话框，用于简化开发。事实上，有很多对话框都是通用的，比如打开文件、设置颜色、打印设置等。这些对话框在所有程序中几乎相同，因此没有必要在每一个程序中都自己实现这么一个对话框。

Qt的内置对话框大致分为以下几类：

* QColorDialog：选择颜色；
* QFileDialog：选择文件或者目录
* QFontDialog：选择字体
* QInputDialog：允许用户输入一个值，并将其值返回；
* QMessageBox：模态对话框，用于显示信息、询问问题等
* QPageSetupDialig：为打印机提供的纸张相关的选项；
* QPrintDialog：打印机配置
* QPrintPreviewDialog：打印预览
* QProgressDialog：显示操作过程

QMessageBox用于显示消息提示。我们一般会使用其提供的几个static函数：

* void about(QWidget* parent, const QString &title, const QString &text)：显示关于对话框。这是最简单的对话框，其标题是titile，内容是text，父窗口是parent。对话框只有一个OK按钮。
* void aboutQt(QWidget* parent, const QString &title = QString())：显示关于Qt对话框。该对话框显示有关Qt的信息。
* StandardButton critical(QWidget* parent, const QString &title, const QString &text, StandardButtons buttons buttons = OK, StandardButton defaultButton = NoButton)：显示严重错误对话框。这个对话框将显示一个红色的错误符号。我们可以通过buttons参数指明其显示的按钮。默认情况下只有一个Ok按钮，我们可以使用StandardButtons类型指定多种按钮。
* StandardButton information(QWidget *parent, const QStrint &title, const QString &text, StandardButtons buttons=OK, StandardButton defaultButton = NoButton)：QMessageBox::information()函数与QMessageBox::critical()类似，不同之处在于这个对话框提供一个普通信息图标。
* StandardButton question(QWidget * parent, const QString & title, const QString & text, StandardButtons buttons = StandardButtons( Yes | No ), StandardButton defaultButton = NoButton)：QMessageBox::question() 函数与 QMessageBox::critical() 类似，不同之处在于这个对话框提供一个问号图标，并且其显示的按钮是“是”和“否”两个
* StandardButton warning(QWidget * parent, const QString & title, const QString & text, StandardButtons buttons = Ok, StandardButton defaultButton = NoButton)：QMessageBox::warning() 函数与 QMessageBox::critical() 类似，不同之处在于这个对话框提供一个黄色叹号图标。

我们可以通过下面的代码来演示如何使用QMessageBox。

```
if(QMessageBox::Yes == QMessageBox::question(this, tr("Question"), tr("Are you OK?"), QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes))
{
	QMessageBox::information(this, tr("Hmmm"), tr("I'm glad to hear that!"));
}else
{
	QMessageBox::information(this, tr("Hmmm"), tr("I'm sorry!"));
}
```

我们使用 QMessageBox::question() 来询问一个问题。这个对话框的父窗口是 this，也就是我们的 MainWindow（或者其他 QWidget 指针）。QMessageBox 是 QDialog 的子类，这意味着它的初始显示位置将会是在 parent 窗口的中央（我们在前面的章节中提到过这一点）。第二个参数是对话框的标题。第三个参数是我们想要显示的内容。这里就是我们需要询问的文字。下面，我们使用或运算符（|）指定对话框应该出现的按钮。这里我们希望是一个 Yes 和一个 No。最后一个参数指定默认选择的按钮。这个函数有一个返回值，用于确定用户点击的是哪一个按钮。按照我们的写法，应该很容易的看出，这是一个模态对话框，因此我们可以直接获取其返回值。如果返回值是 Yes，也就是说用户点击了 Yes 按钮，我们显示一个普通消息对话框，显示“I’m glad to hear that!”，否则则显示“I’m sorry!”。运行一下我们的程序片段，就可以看到其中的不同：

![](G:\images\qmessagebox-demo.png)

QMessageBox类的static函数优点是方便使用，缺点也很明显：非常不灵活。我们只能使用简单的几种形式。为了能够定制QMessageBox细节，我们必须使用QMessageBox的属性设置API。如果我们希望制作一个询问是否保存的对话框，我们可以使用如下的代码：

```c++
QMessageBox msgBox;
msgBox.setText(tr("The document has been modified."));
msgBox.setInformativeText(tr("Do you want to save your changes?"));
msgBox.setDetailedText(tr("Differences here..."));
msgBox.setStandardButtons(QMessageBox::Save | QMessageBox::Discard | QMessageBox::Cancel);
msgBox.setDefaultButton(QMessageBox::Save);
int ret = msgBox.exec();
switch(ret)
{
    case QMessageBox::Save:
        qDebug() << "Save document!";
        break;
    case QMessageBox::Discard:
        qDebug() << "Discard changes!"
            case QMessageBox::Cancel:
        qDebug() << "Close document!";
        break;
}
```

msgBox 是一个建立在栈上的 QMessageBox 实例。我们设置其标题为“The document has been modified.”，informationText 则是会在对话框中显示的文字。下面我们使用了一个 detailedText，也就是详细信息，当我们点击了详细信息按钮时，对话框可以自动显示更多信息。我们自己定义的对话框的按钮有三个：保存、丢弃和取消。然后我们使用了 exec() 是其成为一个模态对话框，根据其返回值进行相应的操作。

同时在 KDE 和 Windows 7 上编译运行一下上面的代码，我们可以看到一些区别：

![](G:\images\qmessagebox-demo-win7.png) ![](G:\images\qmessagebox-demo-kde.png)

除去对话框样式，我们值得注意的是 QMessageBox 下方按钮的排列顺序。KDE 上是 Show Details…、Save、Discard 和 Cancel；而 Windows 7 上则是 Save、Discard、Show Details… 和 Cancel。我们并没有指定按钮的顺序，Qt 已经帮我们按照不同平台的使用习惯对其进行了调整。这一点在 Mac OS 上也会有相应的体现。对于一个普通的 QDialog 而言，Qt 使用的是 QDialogButtonBox 这个类来实现不同平台的对话框按钮顺序的显示的。

# 10 深入Qt5信号槽新语法

## 10.1 基本用法

Qt5引入了信号槽的新语法：使用函数指针能够获得编译期的类型检查。使用我们在自定义信号槽中设计的Newspaper类:

```
//!!! Qt5
#include <QObject>

////////// newspaper.h
class Newspaper : public QObject
{
    Q_OBJECT
public:
    Newspaper(const QString & name) :
        m_name(name)
    {
    }

    void send() const
    {
        emit newPaper(m_name);
    }

signals:
    void newPaper(const QString &name);

private:
    QString m_name;
};

////////// reader.h
#include <QObject>
#include <QDebug>

class Reader : public QObject
{
    Q_OBJECT
public:
    Reader() {}

    void receiveNewspaper(cosnt QString & name) const
    {
        qDebug() << "Receives Newspaper: " << name;
    }
};

////////// main.cpp
#include <QCoreApplication>

#include "newspaper.h"
#include "reader.h"

int main(int argc, char *argv[])
{
    QCoreApplication app(argc, argv);

    Newspaper newspaper("Newspaper A");
    Reader reader;
    QObject::connect(&newspaper, &Newspaper::newPaper,
                     &reader,    &Reader::receiveNewspaper);
    newspaper.send();

    return app.exec();
}
```

在 main() 函数中，我们使用 connect() 函数将 newspaper 对象的 newPaper() 信号与 reader 对象的 receiveNewspaper() 槽函数联系起来。当 newspaper 发出这个信号时，reader 相应的槽函数就会自动被调用。这里我们使用了取址操作符，取到 Newspaper::newPaper() 信号的地址，同样类似的取到了 Reader::receiveNewspaper() 函数地址。编译器能够利用这两个地址，在编译期对这个连接操作进行检查，如果有个任何错误（包括对象没有这个信号，或者信号参数不匹配等），编译时就会发现。

## 10.2 有重载的信号

如果有重载，比如我们向Newspaper类增加一个新的信号：

```c++
void newPaper(const QString &name, const QDate &date);
```

此时如果还是按照前面的写法，编译器会报出一个错误：由于这个函数（注意，信号实际也是一个普通的函数）有重载，因此不能用一个取址操作符获取其地址。可以使用Qt4的处理方法：

```c++
QObject::connect(&newspaper, SIGNAL(newPaper(QString, Qdate)), SLOT(receiveNewspaper(QString, QDate)));
```

注意，我们临时增加了一个 receiveNewspaper() 函数的重载，以便支持两个参数的信号。在 Qt 4 中不存在我们所说的错误，因为 Qt 4 的信号槽连接是带有参数的。因此，Qt 能够自己判断究竟是哪一个信号对应了哪一个槽。

对此，我们也给出了一个解决方案，使用一个函数指针来指明到底是哪一个信号：

```
void (Newspaper:: *newPaperNameDate)(const QString &, const QDate &) = &Newspaper::newPaper;
QObject::connect(&newspaper, newPaperNameDate,
                 &reader,    &Reader::receiveNewspaper);
```

这样，我们使用了函数指针 newspaperNameDate 声明一个带有 QString 和 QDate 两个参数，返回值是 void 的函数，将该函数作为信号，与 Reader::receiveNewspaper() 槽连接起来。这样，我们就回避了之前编译器的错误。归根结底，这个错误是因为函数重载，编译器不知道要取哪一个函数的地址，而我们显式指明一个函数就可以了。

如果你觉得这种写法很难看，想像前面一样写成一行，当然也是由解决方法的：

```
QObject::connect(&newspaper,
                 (void (Newspaper:: *)(const QString &, const QDate &))&Newspaper::newPaper,
                 &reader,
                 &Reader::receiveNewspaper);
```

这是一种换汤不换药的做法：我们只是声明了一个匿名的函数指针，而之前我们的函数指针是有名字的。不过，我们并不推荐这样写，而是希望以下的写法：

```
QObject::connect(&newspaper,
                 static_cast<void (Newspaper:: *)(const QString &, const QDate &)>(&Newspaper::newPaper),
                 &reader,
                 &Reader::receiveNewspaper);
```

对比上面两种写法。第一个使用的是 C 风格的强制类型转换。此时，如果你改变了信号的类型，那么你就会有一个潜在的运行时错误。例如，如果我们把 (const QString &, const QDate &) 两个参数修改成 (const QDate &, const QString &)，C 风格的强制类型转换就会失败，并且这个错误只能在运行时发现。而第二种则是 C++ 推荐的风格，当参数类型改变时，编译器会检测到这个错误。

注意，这里我们只是强调了函数参数的问题。如果前面的对象都错了呢？比如，我们写的 newspaper 对象并不是一个 Newspaper，而是 Newspaper2？此时，编译器会直接失败，因为 connect() 函数会去寻找 sender->*signal，如果这两个参数不满足，则会直接报错。

## 10.3 带有默认参数的槽函数

Qt允许信号和槽的参数数目不一致：槽函数的参数数目要比信号的参数少。这是因为，我们信号的参数实际是作为一种返回值。正如普通的函数调用一样，我们可以选择忽略函数返回值，但是不能使用一个并不存在的返回值。如果槽函数的参数数目比信号的多，在槽函数中就使用到这些参数的时候，实际这些参数并不存在（因为信号的参数比槽函数的少，因此并没有传过来），函数就会报错。这种情况往往有两种原因：一是槽的参数就是比信号的少，此时我们可以像前面那种写法直接连接。另一个原因是，信号的参数带有默认值。比如：

```
void QPushButton::clicked(bool checked = false);
```

就是这种情况。

然而，有一种情况，槽函数的参数可以比信号的多，那就是槽函数的参数带有默认值。比如我们的Newpaper和Reader有下面的代码：

```c++
//Newspaper
signals:
	void newPaper(const QString &name);
//Reader
	void recieveNewspaper(const QString &name, const QDate &date = QDate::currentDate());
```

虽然Reader::receiveNewspaper()的参数数目比Newspaper::newPaper()多，但是由于Reader::receiveNewspaper()后面一个参数带有默认值，所以该参数不是必须提供的。但是，如果你按照前面的写法，比如以下的代码：

```c++
QObject::connect(&newspaper, static_cast<void (Newspaper::*)(const QString&)>(&Newspaper::newPaper), &reader, static_cast<void (Reader::*)(const QString&, const QDate& =Qdate::currentDate())>(&Reader::receiveNewspaper));
```

你会得到一个断言错误：

```c++
The slot requires more arguments than the signal provides.
```

我们不能在函数指针中使用函数参数的默认值。这是C++语言的限制：**参数默认值只能使用在直接的函数调用中。当使用函数指针取其地址的时候，默认参数是不可见的！**

当然，此时你可以选择 Qt 4 的连接语法。如果你还是想使用 Qt 5 的新语法，目前的办法只有一个：Lambda 表达式。不要担心你的编译器不支持 Lambda 表达式，因为在你使用 Qt 5 的时候，能够支持 Qt 5 的编译器都是支持 Lambda 表达式的。于是，我们的代码就变成了：

```c++
QObject::connect(&newspaper,
                 static_cast<void (Newspaper:: *)(const QString &)>(&Newspaper::newPaper),
                 [=](const QString &name) { /* Your code here. */ });
```

# 11 文件对话框

在前面的章节中，我们讨论了 Qt 标准对话框 QMessageBox 的使用。所谓标准对话框，其实也就是一个普通的对话框。因此，我们同样可以将 QDialog 所提供的其它特性应用到这种标准对话框上面。今天，我们继续讨论另外一个标准对话框：QFileDialog，也就是文件对话框。在本节中，我们将尝试编写一个简单的文本文件编辑器，我们将使用 QFileDialog 来打开一个文本文件，并将修改过的文件保存到硬盘。这或许是我们在本系列中所提供的第一个带有实际功能的实例。

首先，我们需要创建一个带有文本编辑功能的窗口。借用我们前面的程序代码，应该可以很方便地完成：

```c++
#include"mainwindow.h"
#include<QAction>
#include<QMenuBar>
#include<QToolBar>
#include<QTextEdit>
#include<QFile>
#include<QFileDialog>
#include<QMessageBox>
#include<QTextStream>
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)
{
    setWindowTitle(tr("Main Window"));

    openAction = new QAction(QIcon(":/images/file-open"), tr("&Open..."), this);
    openAction->setShortcuts(QKeySequence::Open);
    openAction->setStatusTip(tr("Open an existing file"));

    saveAction = new QAction(QIcon(":/images/file-save"), tr("&Save..."), this);
    saveAction->setShortcuts(QKeySequence::Save);
    saveAction->setStatusTip(tr("Save a new file"));

    QMenu* file = menuBar()->addMenu(tr("&File"));
    file->addAction(openAction);
    file->addAction(saveAction);

    QToolBar *toolBar = addToolBar(tr("&File"));
    toolBar->addAction(openAction);
    toolBar->addAction(saveAction);

    textEdit = new QTextEdit(this);
    setCentralWidget(textEdit);

    connect(openAction, &QAction::triggered, this, &MainWindow::openFile);
    connect(saveAction, &QAction::triggered, this, &MainWindow::saveFile);
}
```

我们在菜单和工具栏添加了两个动作：打开和保存。接下来是一个 **QTextEdit** 类，这个类用于显示富文本文件。也就是说，它不仅仅用于显示文本，还可以显示图片、表格等等。不过，我们现在只用它显示纯文本文件。QMainWindow 有一个 setCentralWidget() 函数，可以将一个组件作为窗口的中心组件，放在窗口中央显示区。显然，在一个文本编辑器中，文本编辑区就是这个中心组件，因此我们将 QTextEdit 作为这种组件。

我们使用connect()函数，为这两个QAction对象添加响应的动作：

```c++
connect(openAction, &QAction::triggered, this, &MainWindow::openFile);
connect(saveAction, &QAction::triggered, this, &MainWindow::saveFile);
```

这些应该都不是问题。我们应该能够很清楚这些代码的含义。下面是最主要的 openFile() 和 saveFile() 这两个函数的代码：

```c++
void MainWindow::openFile()
{
    QString path = QFileDialog::getOpenFileName(this, tr("Open File"), "E:\桌面", tr("Text Files(*.txt)"));
    if(!path.isEmpty())
    {
        QFile file(path);
        if(!file.open(QIODevice::ReadOnly | QIODevice::Text))
        {
            QMessageBox::warning(this, tr("Read File"), tr("Cannot open file:\n%1").arg(path));
            return;
        }
        QTextStream in(&file);
        textEdit->setText(in.readAll());
        file.close();
    }
    else
    {
        QMessageBox::warning(this, tr("Path"), tr("You did not select any file"));
    }
}

void MainWindow::saveFile()
{
    QString path = QFileDialog::getSaveFileName(this, tr("Open File"), "E:\桌面", tr("Text Files(*.txt)"));
     if(!path.isEmpty())
     {
         QFile file(path);
         if(!file.open(QIODevice::WriteOnly | QIODevice::Text))
         {
             QMessageBox::warning(this, tr("Write File"), tr("Cannot open file:\n%1").arg(path));
             return;
         }
         QTextStream out(&file);
         out << textEdit->toPlainText();
         file.close();
     }
     else
     {
         QMessageBox::warning(this, tr("Pant"), tr("You did not select any file"));
     }
}

```

在 openFile() 函数中，我们使用 QFileDialog::getOpenFileName() 来获取需要打开的文件的路径。这个函数具有一个长长的签名：

```c++
QString getOpenFileName(QWidget * parent = 0,
                        const QString & caption = QString(),
                        const QString & dir = QString(),
                        const QString & filter = QString(),
                        QString * selectedFilter = 0,
                        Options options = 0)
```

不过注意，它的所有参数都是可选的，因此在一定程度上说，这个函数也是简单的。这六个参数分别是：

* parent：父窗口。我们前面介绍过，Qt 的标准对话框提供静态函数，用于返回一个模态对话框（在一定程度上这就是外观模式的一种体现）；
* caption：对话框标题；
* dir：对话框打开时的默认目录，“.” 代表程序运行目录，“/” 代表当前盘符的根目录（特指 Windows 平台；Linux 平台当然就是根目录），这个参数也可以是平台相关的，比如“C:\”等；
* filter：过滤器。我们使用文件对话框可以浏览很多类型的文件，但是，很多时候我们仅希望打开特定类型的文件。比如，文本编辑器希望打开文本文件，图片浏览器希望打开图片文件。过滤器就是用于过滤特定的后缀名。如果我们使用“Image Files(*.jpg *.png)”，则只能显示后缀名是 jpg 或者 png 的文件。如果需要多个过滤器，使用“;;”分割，比如“JPEG Files(*.jpg);;PNG Files(*.png)”；
* selectedFilter：默认选择的过滤器
* options：对话框的一些参数设定，比如只显示文件夹等等，它的取值是 enum QFileDialog::Option，每个选项可以使用 | 运算组合起来。

QFileDialog::getOpenFileName() 返回值是选择的文件路径。我们将其赋值给 path。通过判断 path 是否为空，可以确定用户是否选择了某一文件。只有当用户选择了一个文件时，我们才执行下面的操作。在 saveFile() 中使用的 QFileDialog::getSaveFileName() 也是类似的。使用这种静态函数，在 Windows、Mac OS 上面都是直接调用本地对话框，但是 Linux 上则是 QFileDialog 自己的模拟。这暗示了，如果你不使用这些静态函数，而是直接使用 QFileDialog 进行设置，就像我们前面介绍的 QMessageBox 的设置一样，那么得到的对话框很可能与系统对话框的外观不一致。这一点是需要注意的。

首先，我们创建一个 QFile 对象，将用户选择的文件路径传递给这个对象。然后我们需要打开这个文件，使用的是 QFile::open()，其参数是指定的打开方式，这里我们使用只读方式和文本方式打开这个文件（因为我们选择的是后缀名 txt 的文件，可以认为是文本文件。当然，在实际应用中，可能需要进行进一步的判断）。QFile::open() 打开成功则返回 true，由此继续进行下面的操作：使用 QTextStream::readAll() 读取文件所有内容，然后将其赋值给 QTextEdit 显示出来。最后不要忘记关闭文件。另外，saveFile() 函数也是类似的，只不过最后一步，我们使用 << 重定向，将 QTextEdit 的内容输出到一个文件中。关于文件操作，我们会在后面的章节中进一步介绍。

这里需要注意一点：我们的代码仅仅是用于演示，很多必须的操作并没有进行。比如，我们没有检查这个文件的实际类型是不是一个文本文件。并且，我们使用了 QTextStream::readAll() 直接读取文件所有内容，如果这个文件有 100M，程序会立刻死掉，这些都是实际程序必须考虑的问题。不过这些内容已经超出我们本章的介绍，也就不再详细说明。

至此，我们的代码已经介绍完毕，马上可以编译运行一下了：

![](G:\images\qfiledialog-kde.png)

# 12 事件

事件（event)是有系统或者Qt本身在不同时刻发出的。当用户按下鼠标、敲下键盘，或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件在对用户操作做出响应时发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。

事件也就是我们通常说的“事件驱动（event drive)，程序设计的基础概念。事件的出现，使得程序代码不会按照原始线性顺序执行。

事件也就是我们通常说的“事件驱动（event drive）”程序设计的基础概念。事件的出现，使得程序代码不会按照原始的线性顺序执行。想想看，从最初的 C 语言开始，我们的程序就是以一种线性的顺序执行代码：这一条语句执行之后，开始执行下一条语句；这一个函数执行过后，开始执行下一个函数。这种类似“批处理”的程序设计风格显然不适合于处理复杂的用户交互。我们来想象一下用户交互的情景：我们设计了一堆功能放在界面上，用户点击了“打开文件”，于是开始执行打开文件的操作；用户点击了“保存文件”，于是开始执行保存文件的操作。我们不知道用户究竟想进行什么操作，因此也就不能预测接下来将会调用哪一个函数。如果我们设计了一个“文件另存为”的操作，如果用户不点击，这个操作将永远不会被调用。这就是所谓的“事件驱动”，我们的程序的执行顺序不再是线性的，而是由一个个事件驱动着程序继续执行。没有事件，程序将阻塞在那里，不执行任何代码。

在Qt中，事件的概念似乎同信号槽类似。的确如此，一般来说，使用Qt组件时，我们并不会把主要精力放在事件上。因为在Qt中，我们关心的更多的是事件关联的一个信号。比如，对于QPushButton的鼠标点击，我们不需要关心这个鼠标点击事件，而是关心它的clicked信号的发出。这与其他的一些GUI框架不同：在Swing中，你所要关心的是JButton的ActionListener这个点击事件。由此看出，相比于其它GUI框架，Qt给了我们额外的选择：信号槽。

但是，Qt中的事件和信号槽却不是可以相互替代的。信号由具体的对象发出，然后会马上交给由connect()函数连接的槽进行处理；而对于事件，Qt使用一个事件队列对所有发出的事件进行维护，当新的事件产生时，会被追加到事件队列的尾部。前一个事件完成后，取出后面的事件进行处理。但是，必要的时候，Qt的事件也可以不进入事件队列，而是直接处理。信号一旦发出，对应的的槽函数一定会被执行。但是，事件则可以使用“事件过滤器”进行过滤，对于有些事件进行额外的处理，另外的事件则不关心。**总的来说，如果我们使用组件，我们关心的是信号槽；如果我们自定义组件，我们关心的是事件。**因为我们可以通过事件来改变组件的默认操作。比如，如果我们要自定义一个能够响应鼠标事件的EventLabel，我们就需要重写QLabel的鼠标事件，做出我们希望的操作，有可能还得在恰当的时候发出一个类似的按钮的clicked()信号（**如果我们希望让这个EventLabel能够被其它组件使用**）或者其它信号。

在前面我们也曾经简单提到，Qt程序需要在main()函数创建一个QCoreApplication对象，然后调用它的exec()函数。这个函数就是开始Qt的事件循环。在执行exec()函数之后，程序将进入事件循环来监听应用程序的事件。当事件发生时，Qt将创建一个事件对象。Qt中所有事件类都继承于QEvent。在事件对象创建完毕后，Qt将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数（event handler)。关于这一点，我们会在以后的章节中详细说明。

在所有组件的父类QWidget中，定义了很多事件处理的回调函数，如keyPressEvent()、keyReleaseEvent()、mouseDoubleClickEvent()、mouseMoveEvent()、mousePressEvent()、mouseReleaseEvent()等。这些函数都是protected virtual的，也就是说，我们可以在子类中重新实现这些函数。下面来看一个例子：

```C++
/// eventlabel.h
#ifndef EVENTLABEL_H
#define EVENTLABEL_H
#include<QLabel>
#include<QMouseEvent>

class EventLabel : public QLabel
{
    Q_OBJECT
public:
    EventLabel(QWidget* parent=nullptr);
protected:
    void mouseMoveEvent(QMouseEvent *ev);
    void mousePressEvent(QMouseEvent *ev);
    void mouseReleaseEvent(QMouseEvent *ev);
};

#endif // EVENTLABEL_H

/// eventlabel.cpp
#include "eventlabel.h"

EventLabel::EventLabel(QWidget* parent) : QLabel(parent)
{

}

void EventLabel::mouseMoveEvent(QMouseEvent *ev)
{
    this->setText(QString("<center><h1>Move:(%1, %2)</h1></center>").arg(QString::number(ev->x()), QString::number(ev->y())));
}

void EventLabel::mousePressEvent(QMouseEvent *ev)
{
    this->setText(QString("<center><h1>Press: (%1, %2)</h1></center>").arg(QString::number(ev->x()), QString::number(ev->y())));
}

void EventLabel::mouseReleaseEvent(QMouseEvent *ev)
{
    QString msg;
    msg.sprintf("<center><h1>Release: (%d, %d)</h1></center>", ev->x(), ev->y());
    this->setText(msg);
}

/// main.cpp
#include<QApplication>
#include "eventlabel.h"

int main(int argc, char* argv[])
{
    QApplication app(argc, argv);

    EventLabel *label = new EventLabel;
    label->setWindowTitle("MouseEvent Demo");
    label->resize(300, 200);
    label->show();

    return app.exec();
}

```

我们编译运行上面的代码，就可以理解到有关事件的使用方法。

EventLabel 继承了 QLabel，覆盖了 mousePressEvent()、mouseMoveEvent() 和 MouseReleaseEvent() 三个函数。我们并没有添加什么功能，只是在鼠标按下（press）、鼠标移动（move）和鼠标释放（release）的时候，**把当前鼠标的坐标值显示在这个 Label 上面。由于 QLabel 是支持 HTML 代码的，因此我们直接使用了 HTML 代码来格式化文字。**

QString的arg()函数可以自动替换掉QString中出现的占位符。其占位符以%开始，后面是占位符的位置，例如%1，%2这种。

```c++
QString("[%1, %2]").arg(x, y);
```

语句将会使用x替换%1，y替换%2，因此，这个语句生成的QString为[x, y]。

在 mouseReleaseEvent() 函数中，我们使用了另外一种 QString 的构造方法。我们使用类似 C 风格的格式化函数 sprintf() 来构造 QString。

运行上面的代码，当我们点击了一下鼠标之后，label 上将显示鼠标当前坐标值。

![](G:\images\eventlabel-demo.png)

为什么要点击鼠标之后才能在 mouseMoveEvent() 函数中显示鼠标坐标值？这是因为 QWidget 中有一个 mouseTracking 属性，该属性用于设置是否追踪鼠标。只有鼠标被追踪时，mouseMoveEvent() 才会发出。如果 mouseTracking 是 false（默认即是），组件在至少一次鼠标点击之后，才能够被追踪，也就是能够发出 mouseMoveEvent() 事件。如果 mouseTracking 为 true，则 mouseMoveEvent() 直接可以被发出。知道了这一点，我们就可以在 main() 函数中直接设置下：

```c++
EventLabel *label = new EventLabel;
label->setWindowTitle("MouseEvent Demo");
label->resize(300, 200);
label->setMouseTracking(true);
label->show();
```

这样子就没有这个问题了。

# 13 事件的接受与忽略

上一章我们介绍了有关事件的相关内容。我们曾经提到，事件可以依情况接受和忽略。现在，我们就来了解下有关事件的更多的知识。

首先来看一段代码：

```c++
/// custombuttom.h
#ifndef CUSTOMBUTTON_H
#define CUSTOMBUTTON_H

#include <QPushButton>

class CustomButton : public QPushButton
{
    Q_OBJECT
public:
    explicit CustomButton(QWidget *parent = nullptr);
    void onButtonClicked();
signals:

public slots:
};

#endif // CUSTOMBUTTON_H

// custombutton.cpp
#include "custombutton.h"
#include<QPushButton>
#include <QDebug>

CustomButton::CustomButton(QWidget *parent) : QPushButton(parent)
{
    connect(this, &CustomButton::clicked, this, &CustomButton::onButtonClicked);
}

void CustomButton::onButtonClicked()
{
      qDebug() << "You clicked this!";
}

//main.cpp
#include<QApplication>
#include "custombutton.h"

int main(int argc, char* argv[])
{
    QApplication app(argc, argv);

   CustomButton btn;
   btn.setText("This is a Button");
   btn.show();

    return app.exec();
}
```

这是一段简单的代码，经过我们前面一段时间的学习，我们已经能够知道这段代码的运行结果：点击按钮，会在控制台打印出“You clicked this!”字符串。这是我们前面介绍过的内容。下面，我们向 CustomButton 类添加一个事件函数：

```c++
// CustomButton
...
protected:
    void mousePressEvent(QMouseEvent *event);
...

// ---------- custombutton.cpp ---------- //
...
void CustomButton::mousePressEvent(QMouseEvent *event)
{
    if (event->button() == Qt::LeftButton) {
        qDebug() << "left";
    } else {
        QPushButton::mousePressEvent(event);
    }
}
...
```

我们重写了 CustomButton 的 mousePressEvent() 函数，也就是鼠标按下。在这个函数中，我们判断如果鼠标按下的是左键，则打印出来“left”字符串，否则，调用父类的同名函数。编译运行这段代码，当我们点击按钮时，“You clicked this!”字符串不再出现，只有一个“left”。也就是说，我们把父类的实现覆盖掉了。由此可以看出，父类 QPushButton 的 mousePressEvent() 函数中肯定发出了 clicked() 信号，否则的话，我们的槽函数怎么会不执行了呢？这暗示我们一个非常重要的细节： **当重写事件回调函数时，时刻注意是否需要通过调用父类的同名函数来确保原有实现仍能进行！** 比如我们的 CustomButton 了，如果像我们这么覆盖函数，clicked() 信号永远不会发生，你连接到这个信号的槽函数也就永远不会被执行。这个错误非常隐蔽，很可能会浪费你很多时间才能找到。因为这个错误不会有任何提示。这一定程度上说，我们的组件“忽略”了父类的事件，但这更多的是一种违心之举，一种错误。

通过调用父类的同名函数，我们可以把 Qt 的事件传递看成链状：如果子类没有处理这个事件，就会继续向其父类传递。Qt 的事件对象有两个函数：accept() 和 ignore()。正如它们的名字一样，前者用来告诉 Qt，这个类的事件处理函数想要这个事件；后者则告诉 Qt，这个类的事件处理函数不想要这个事件。无论是 accept() 还是 ignore()，该类 **不想要的事件** 都会被继续发送给其父组件。在事件处理函数中，可以使用 isAccepted() 来查询这个事件是不是已经被接收了。

事实上，我们很少会使用 accept() 和 ignore() 函数，而是像上面的示例一样，如果希望忽略事件（所谓忽略，是指自己不想要这个事件），只要调用父类的响应函数即可。记得我们曾经说过，Qt 中的事件都是 protected 的，因此，重写的函数必定存在着其父类中的响应函数，所以，这个方法是可行的。为什么要这么做，而不是自己去手动调用这两个函数呢？因为我们无法确认父类中的这个处理函数有没有额外的操作。如果我们在子类中直接忽略事件，Qt 将不会再去寻找其他的接收者，那么父类的操作也就不能进行，这可能会有潜在的危险。

要理解这一点，我们可以查看一下 QWidget 的 mousePressEvent() 函数的实现：

```c++
//!!! Qt5
void QWidget::mousePressEvent(QMouseEvent *event)
{
    event->ignore();
    if ((windowType() == Qt::Popup)) {
        event->accept();
        QWidget* w;
        while ((w = QApplication::activePopupWidget()) && w != this){
            w->close();
            if (QApplication::activePopupWidget() == w)
                w->hide(); // hide at least
        }
        if (!rect().contains(event->pos())){
            close();
        }
    }
}
```



这段代码在 Qt4 和 Qt5 中基本一致（区别在于 activePopupWidget() 一行，Qt4 的版本是 qApp->activePopupWidget()）。注意函数的第一个语句：event->ignore();，如果子类都没有重写这个函数，Qt 会默认忽略这个事件，不会继续传播。如果我们在子类的 mousePressEvent() 函数中直接调用了 accept() 或者 ignore()，而没有调用父类的同名函数，QWidget::mousePressEvent() 函数中关于 Popup 判断的那段代码就不会被执行，因此可能会出现默认其妙的怪异现象。

不过，事情也不是绝对的。在一个情形下，我们必须使用 accept() 和 ignore() 函数，那就是窗口关闭的事件。回到我们前面写的简单的文本编辑器。我们在构造函数中添加如下代码：

```c++
//!!! Qt5
...
textEdit = new QTextEdit(this);
setCentralWidget(textEdit);
connect(textEdit, &QTextEdit::textChanged, [=]() {
    this->setWindowModified(true);
});

setWindowTitle("TextPad [*]");
...

void MainWindow::closeEvent(QCloseEvent *event)
{
    if (isWindowModified()) {
        bool exit = QMessageBox::question(this,
                                      tr("Quit"),
                                      tr("Are you sure to quit this application?"),
                                      QMessageBox::Yes | QMessageBox::No,
                                      QMessageBox::No) == QMessageBox::Yes;
        if (exit) {
            event->accept();
        } else {
            event->ignore();
        }
    } else {
        event->accept();
    }
}
```

setWindowTitle() 函数可以使用 [\*] 这种语法来表明，在窗口内容发生改变时（通过 setWindowModified(true) 函数通知），Qt 会自动在标题上面的 [*] 位置替换成 * 号。我们使用 Lambda 表达式连接 QTextEdit::textChanged() 信号，将 windowModified 设置为 true。然后我们需要重写 closeEvent() 函数。在这个函数中，我们首先判断是不是有过修改，如果有，则弹出询问框，问一下是否要退出。如果用户点击了“Yes”，则接受关闭事件，这个事件所在的操作就是关闭窗口。因此，一旦接受事件，窗口就会被关闭；否则窗口继续保留。当然，如果窗口内容没有被修改，则直接接受事件，关闭窗口。

**1.事件的传播是在组件层次上面的，而不是依靠类继承机制。**
注：这句话很关键，当触发一个窗口组件时，如果ignore了，则事件会继续传播到上层组件。如下程序，点击了CustomButton按钮，则会触发CustomWidget和MainWindow这2个上级组件，同样，当点击CustomWidget组件时，将会触发MainWindow这个上级组件。
**2.重写事件回调函数时，时刻注意是否需要通过调用父类的同名函数来确保原有实现仍能进行。**
注：重写事件函数时，很容易出现覆盖构造函数的实现。
**3.Qt中事件对象默认是 accept 的，而作为所有组件的父类QWidget的默认实现则是调用ignore()。**
注：如果要忽略事件，需要调用QWidget的默认来实现，否则就等于接受了事件。

# 14 event()

前面的章节中我们曾经提到 event() 函数。事件对象创建完毕后，Qt 将这个事件对象传递给 QObject 的 event() 函数。event() 函数并不直接处理事件，而是将这些事件对象按照它们不同的类型，分发给不同的事件处理器（event handler）。

如上所述，event()函数主要用于事件的分发。所以，如果你希望在事件分发之前做一些操作，就可以重写event()函数了。例如，我们希望在一个QWidget组件中监听tab键的按下，那么就可以继承QWidget，并重写它的event()函数，来达到这个目的：

```c++
bool CustomWidget::event(QEvent *e)
{
	if(e->type() == QEvent::KeyPress)
	{
		QKeyEvent *keyEvent = static_cast<QKeyEvent*>(e);
		if(e->type() == QEvent::KeyPress)
		{
			qDebug() << "You press tab";
			return true;
		}
	}
	return QWidget::event(e);
}
```

CustomWidget 是一个普通的 QWidget 子类。我们重写了它的 event() 函数，这个函数有一个 QEvent 对象作为参数，也就是需要转发的事件对象。函数返回值是 bool 类型。如果传入的事件已被识别并且处理，则需要返回 true，否则返回 false。如果返回值是 true，并且，该事件对象设置了 accept()，那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。

我们可以通过使用 QEvent::type() 函数可以检查事件的实际类型，其返回值是 QEvent::Type 类型的枚举。我们处理过自己感兴趣的事件之后，可以直接返回 true，表示我们已经对此事件进行了处理；对于其它我们不关心的事件，则需要调用父类的 event() 函数继续转发，否则这个组件就只能处理我们定义的事件了。为了测试这一种情况，我们可以尝试下面的代码：

```
bool CustomTextEdit::event(QEvent* e)
{
	if(e->type() == QEvent::KeyPress)
	{
		QKeyEvent *keyEvent = static_cast<QKeyEvent*>(e);
		if(keyEvent->key() == Qt::Key_Tab)
		{
			qDebug() << "You press tab";
			return true;
		}
	}
	return false;
}
```

CustomTextEdit 是 QTextEdit 的一个子类。我们重写了其 event() 函数，却没有调用父类的同名函数。这样，我们的组件就只能处理 Tab 键，再也无法输入任何文本，也不能响应其它事件，比如鼠标点击之后也不会有光标出现。这是因为我们只处理的 KeyPress 类型的事件，并且如果不是 KeyPress 事件，则直接返回 false，鼠标事件根本不会被转发，也就没有了鼠标事件。

通过查看 QObject::event() 的实现，我们可以理解，event() 函数同前面的章节中我们所说的事件处理器有什么联系：

```c++
bool QObject::event(QEvent* e)
{
	switch(e->type())
	{
		case QEvent::Timer:
			timerEvent((QTimerEvent*)e);
			break;
		case QEvent::ChildAdded:
		case QEvent::ChildPolished:
		case QEvent::ChildRemove:
			childEvent((QChildEvent*)e);
			break;
		//...
		default:
			if(e->type() >= QEvent::User)
			{
				customEvent(e);
				break;
			}
			return false;
	}
	return true;
}
```

这是 Qt 5 中 QObject::event() 函数的源代码（Qt 4 的版本也是类似的）。我们可以看到，同前面我们所说的一样，Qt 也是使用 QEvent::type() 判断事件类型，然后调用了特定的事件处理器。比如，如果 event->type() 返回值是 QEvent::Timer，则调用 timerEvent() 函数。可以想象，QWidget::event() 中一定会有如下的代码：

```C++
switch (event->type()) {
    case QEvent::MouseMove:
        mouseMoveEvent((QMouseEvent*)event);
        break;
    // ...
}
```

事实也的确如此。timerEvent() 和 mouseMoveEvent() 这样的函数，就是我们前面章节所说的事件处理器 event handler。也就是说，event() 函数中实际是通过事件处理器来响应一个具体的事件。这相当于 event() 函数将具体事件的处理“委托”给具体的事件处理器。而这些事件处理器是 protected virtual 的，因此，我们重写了某一个事件处理器，即可让 Qt 调用我们自己实现的版本。

由此可以见，event() 是一个集中处理不同类型的事件的地方。如果你不想重写一大堆事件处理器，就可以重写这个 event() 函数，通过 QEvent::type() 判断不同的事件。鉴于重写 event() 函数需要十分小心注意父类的同名函数的调用，一不留神就可能出现问题，所以一般还是建议只重写事件处理器（当然，也必须记得是不是应该调用父类的同名处理器）。这其实暗示了 event() 函数的另外一个作用：屏蔽掉某些不需要的事件处理器。正如我们前面的 CustomTextEdit 例子看到的那样，我们创建了一个只能响应 tab 键的组件。这种作用是重写事件处理器所不能实现的。

# 15 事件过滤器

有时候，对象需要查看、甚至拦截发送到另外对象的事件。例如，对话框可能想要拦截按键事件，不让别的组件接收到；或者修改回车键的默认处理。

通过前面的章节，我们已经知道，Qt 创建了 QEvent 事件对象之后，会调用 QObject 的 event() 函数处理事件的分发。显然，我们可以在 event() 函数中实现拦截的操作。由于 event() 函数是 protected 的，因此，需要继承已有类。如果组件很多，就需要重写很多个 event() 函数。这当然相当麻烦，更不用说重写 event() 函数还得小心一堆问题。好在 Qt 提供了另外一种机制来达到这一目的：事件过滤器。

QObject 有一个 eventFilter() 函数，用于建立事件过滤器。这个函数的签名如下：

```c++
virtual bool QObject::eventFilter(QObject* watched, QEvent* event);
```

这个函数正如其名字显示的那样，是一个“事件过滤器”。所谓事件过滤器，可以理解成一种过滤代码。想想做化学实验时用到的过滤器，可以将杂质留到滤纸上，让过滤后的液体溜走。事件过滤器也是如此：它会检查接收到的事件。如果这个事件是我们感兴趣的类型，就进行我们自己的处理；如果不是，就继续转发。**这个函数返回一个 bool 类型，如果你想将参数 event 过滤出来，比如，不想让它继续转发，就返回 true，否则返回 false。**事件过滤器的调用时间是目标对象（也就是参数里面的 watched 对象）接收到事件对象之前。也就是说，如果你在事件过滤器中停止了某个事件，那么，watched 对象以及以后所有的事件过滤器根本不会知道这么一个事件。

我们来看一段简单的代码：

```c++
class MainWindow : public QMainWindow
{
public:
    MainWindow();
protected:
    QTexEdit *textEdit;
};

MainWindow::MainWindow()
{
    textEdit = new QTextEdit;
    setCentralWidget(textEdit);
    
    textEdit->installEventFilter(this);
}

bool MainWindow::eventFilter(QObject* obj, QEvent* event)
{
    if(obj == textEdit)
    {
        if(event->type() == QEvent::KeyPress)
        {
            QKeyEvent *keyEvent = static_cast<QKeyEvent*>(event);
            qDebug() << "Ate key press" << keyEvent->key();
            return true;
        }
        else
        {
            return false;
        }
    }
    else
    {
        return QMainWindow::eventFilter(obj, event);
    }
}
```

MainWindow 是我们定义的一个类。我们重写了它的 eventFilter() 函数。为了过滤特定组件上的事件，首先需要判断这个对象是不是我们感兴趣的组件，然后判断这个事件的类型。在上面的代码中，我们不想让 textEdit 组件处理键盘按下的事件。所以，首先我们找到这个组件，如果这个事件是键盘事件，则直接返回 true，也就是过滤掉了这个事件，其他事件还是要继续处理，所以返回 false。对于其它的组件，我们并不保证是不是还有过滤器，于是最保险的办法是调用父类的函数。

eventFilter() 函数相当于创建了过滤器，然后我们需要安装这个过滤器。安装过滤器需要调用 QObject::installEventFilter() 函数。这个函数的签名如下：

```
void QObject::installEventFilter ( QObject * filterObj )
```

这个函数接受一个 QObject * 类型的参数。记得刚刚我们说的，eventFilter() 函数是 QObject 的一个成员函数，因此，任意 QObject 都可以作为事件过滤器（问题在于，如果你没有重写 eventFilter() 函数，这个事件过滤器是没有任何作用的，因为默认什么都不会过滤）。已经存在的过滤器则可以通过 QObject::removeEventFilter() 函数移除。

我们可以向一个对象上面安装多个事件处理器，只要调用多次 installEventFilter() 函数。如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是后进先执行的顺序。

还记得我们前面的那个例子吗？我们使用 event() 函数处理了 Tab 键：

```
bool CustomWidget::event(QEvent *e)
{
    if (e->type() == QEvent::KeyPress) {
        QKeyEvent *keyEvent = static_cast<QKeyEvent *>(e);
        if (keyEvent->key() == Qt::Key_Tab) {
            qDebug() << "You press tab.";
            return true;
        }
    }
    return QWidget::event(e);
}
```

现在，我们可以给出一个使用事件过滤器的版本：

```
bool FilterObject::eventFilter(QObject *object, QEvent *event)
{
    if (object == target && event->type() == QEvent::KeyPress) {
        QKeyEvent *keyEvent = static_cast<QKeyEvent *>(event);
        if (keyEvent->key() == Qt::Key_Tab) {
            qDebug() << "You press tab.";
            return true;
        } else {
            return false;
        }
    }
    return false;
}
```

事件过滤器的强大之处在于，我们可以为整个应用程序添加一个事件过滤器。记得，installEventFilter() 函数是 QObject 的函数，QApplication 或者 QCoreApplication 对象都是 QObject 的子类，因此，我们可以向 QApplication 或者 QCoreApplication 添加事件过滤器。这种全局的事件过滤器将会在所有其它特性对象的事件过滤器之前调用。尽管很强大，但这种行为会严重降低整个应用程序的事件分发效率。因此，除非是不得不使用的情况，否则的话我们不应该这么做。

**注意，如果你在事件过滤器中 delete 了某个接收组件，务必将函数返回值设为 true。否则，Qt 还是会将事件分发给这个接收组件，从而导致程序崩溃。**

事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。

# 16 事件总结

Qt 的事件是整个 Qt 框架的核心机制之一，也比较复杂。说它复杂，更多是因为它涉及到的函数众多，而处理方法也很多，有时候让人难以选择。现在我们简单总结一下 Qt 中的事件机制。

Qt 中有很多种事件：鼠标事件、键盘事件、大小改变的事件、位置移动的事件等等。如何处理这些事件，实际有两种选择：

1 所有事件对应一个处理函数，在这个事件处理函数中用一个很大的分支语句进行选择，其代表就是win32API的WndProc()函数：

```c
LRESULT CALLBACK WndProc(HWND hWnd,
                         UINT message,
                         WPARAM wParam,
                         LPARAM lParam)
```

在这个函数中，我们需要使用switch语句，选择message参数的类型进行处理，典型代码是：

```C
switch(message)
{
    case WM_PAINT:
        // ...
        break;
    case WM_DESTROY:
        // ...
        break;
    ...
}
```

2 每一种事件对应一个事件处理函数。Qt就是使用的这么一种机制：

* mouseEvent()
* keyPressEvent()
* ……

Qt具有这么多事件处理函数，肯定有一个地方对其进行分发，否则，Qt怎么知道哪一种事件调用哪一个事件处理函数呢？这个分发的函数，就是event()。显然，当QMouseEvent产生之后，event()函数将其分发给mouseEvent()事件处理器进行处理。

event()函数会有两个问题：

1 event()函数是一个protected的函数，这意味着我们想重写event()，必须继承一个已有的类。试想，我的程序根本不想要鼠标事件，程序中所有组件都不允许处理鼠标事件，是不是我得继承所有组件，——重写其event()函数？protected函数带来的另外一个问题是，如果我基于第三方库进行开发，而对方没有提供源代码，只有一个链接库，其它都是封装好的。我怎么去继承这种库中的组件呢？

2 event()函数的确有一定的控制，不过有时候我的需要更严格一些：我希望那些组件根本看不到这种事件。event()函数虽然可以拦截，但其实也是接收到了QMouseEvent对象。我让它收都收不到。这样做的好处是，模拟一种系统根本没有那个事件的效果，所以其它组件根本不会收到这个事件，也就无需修改自己的事件处理函数。

这两个问题是 event() 函数无法处理的。于是，Qt 提供了另外一种解决方案：事件过滤器。事件过滤器给我们一种能力，让我们能够完全移除某种事件。事件过滤器可以安装到任意 QObject 类型上面，并且可以安装多个。如果要实现全局的事件过滤器，则可以安装到 QApplication 或者 QCoreApplication 上面。这里需要注意的是，如果使用 installEventFilter() 函数给一个对象安装事件过滤器，那么该事件过滤器只对该对象有效，只有这个对象的事件需要先传递给事件过滤器的 eventFilter() 函数进行过滤，其它对象不受影响。如果给 QApplication 对象安装事件过滤器，那么该过滤器对程序中的每一个对象都有效，任何对象的事件都是先传给 eventFilter() 函数。

事件过滤器可以解决刚刚我们提出的 event() 函数的两点不足：首先，事件过滤器不是 protected 的，因此我们可以向任何 QObject 子类安装事件过滤器；其次，事件过滤器在目标对象接收到事件之前进行处理，如果我们将时间过滤掉，目标对象根本不会见到这个事件。

事实上，还有一种方法，我们没有介绍。Qt 事件的调用最终都会追溯到 QCoreApplication::notify() 函数，因此，最大的控制权实际上是重写 QCoreApplication::notify()。这个函数的声明是：

```c
virtual bool QCoreApplication::notify(QObject* receiver, QEvent* event);
```

此函数会将event发送给receiver，也就是调用receiver->event(event)，其返回值就是来自receiver的事件处理器。注意，这个函数为任意线程的任意对象的任意事件调用，因此，不存在事件过滤器的线程问题。不过不推荐这么做，因为notify()函数只有一个，而事件过滤器要灵活得多。

现在我们可以总结一下 Qt 的事件处理，实际上是有五个层次：

1. 重写 paintEvent()、mousePressEvent() 等事件处理函数。这是最普通、最简单的形式，同时功能也最简单。
2. 重写 event() 函数。event() 函数是所有对象的事件入口，QObject 和 QWidget 中的实现，默认是把事件传递给特定的事件处理函数。
3. 在特定对象上面安装事件过滤器。该过滤器仅过滤该对象接收到的事件。
4. 在 QCoreApplication::instance() 上面安装事件过滤器。该过滤器将过滤所有对象的所有事件，因此和 notify() 函数一样强大，但是它更灵活，因为可以安装多个过滤器。全局的事件过滤器可以看到 disabled 组件上面发出的鼠标事件。全局过滤器有一个问题：只能用在主线程。
5. 重写 QCoreApplication::notify() 函数。这是最强大的，和全局事件过滤器一样提供完全控制，并且不受线程的限制。但是全局范围内只能有一个被使用（因为 QCoreApplication 是单例的）。

为了进一步了解这几个层次的事件处理方式的调用顺序，我们可以编写一个测试代码：

```c++
class Label : public QWidget
{
public:
    Label()
    {
        installEventFilter(this);
    }

    bool eventFilter(QObject *watched, QEvent *event)
    {
        if (watched == this) {
            if (event->type() == QEvent::MouseButtonPress) {
                qDebug() << "eventFilter";
            }
        }
        return false;
    }

protected:
    void mousePressEvent(QMouseEvent *)
    {
        qDebug() << "mousePressEvent";
    }

    bool event(QEvent *e)
    {
        if (e->type() == QEvent::MouseButtonPress) {
            qDebug() << "event";
        }
        return QWidget::event(e);
    }
};

class EventFilter : public QObject
{
public:
    EventFilter(QObject *watched, QObject *parent = 0) :
        QObject(parent),
        m_watched(watched)
    {
    }

    bool eventFilter(QObject *watched, QEvent *event)
    {
        if (watched == m_watched) {
            if (event->type() == QEvent::MouseButtonPress) {
                qDebug() << "QApplication::eventFilter";
            }
        }
        return false;
    }

private:
    QObject *m_watched;
};

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    Label label;
    app.installEventFilter(new EventFilter(&label, &label));
    label.show();
    return app.exec();
}
```

我们可以看到，鼠标点击之后的输出结果是：

```
QApplication::eventFilter
eventFilter
event
mousePressEvent
```

因此可以知道，全局事件过滤器被第一个调用，之后是该对象上面的事件过滤器，其次是 event() 函数，最后是特定的事件处理函数。

# 17 自定义事件

尽管Qt已经提供了很多事件，但对于更加千变万化的需求来说，有限的事件都是不够的。例如，我要支持一种新的设备，这个设备提供一种崭新的交互方式，那么，这种事件如何处理呢？所以，允许创建自己的事件类型也势在必行。即便是不说那种非常极端的例子，在多线程的程序中，自定义事件也是尤其有用。当然，事件也并不是局限在多线程中，它可以用在单线程的程序中，作为一种对象间通讯的机制。那么，为什么我们需要使用事件，而不是信号槽呢？主要原因是，事件的发发既可以是同步的，也可以是异步的，而函数的调用或者说槽的回调总是同步的。事件的另外一个好处是，它可以使用过滤器。

Qt自定义事件很简单，同其它类库的使用很相似，都是要继承一个类进行扩展。在Qt中，你需要继承的类是QEvent。继承QEvent类，最重要的是提供一个QEvent::Type类型的参数，作为自定义事件的类型值。回忆一下，这个type是我们在处理事件时用于识别事件类型的代号。比如在event()函数中，我们使用QEvent::type()获得这个事件类型，然后我们定义的实际类型对比。

QEvent::Type是QEvent定义的一个枚举。因此，我们可以传递一个int值。但是需要注意的是，我们的自定义事件类型不能和已经存在的type值重复，否则会有不可预料的错误发生。因为系统会将你新增加的事件当做系统事件进行派发和调用。在Qt中，系统保留0-999的值，也就是说，你的事件type要大于999.这种数值当然非常难记，所以Qt定义了两个边界值：QEvent::User和QEvent::MaxUser。我们自定义事件的type应该在这两个值的范围之间。其中，QEvent::User的值是1000，QEvent::MaxUser的值是65535。从这里知道，我们最多可以定义64536个事件。通过这两个枚举值，我们可以保证我们自己定义的事件类型不会覆盖系统定义的事件类型。但是，这样并不能保证自定义事件相互之间不会被覆盖。为了解决这个问题，Qt提供了一个函数：registerEventType()，用于自定义事件的注册。该函数签名如下：

```c++
static int QEvent::registerEventType ( int hint = -1 );
```

这个函数是 static 的，因此可以使用 QEvent 类直接调用。函数接受一个 int 值，其默认值是 -1；函数返回值是向系统注册的新的 Type 类型的值。如果 hint 是合法的，也就是说这个 hint 不会发生任何覆盖（系统的以及其它自定义事件的），则会直接返回这个值；否则，系统会自动分配一个合法值并返回。因此，使用这个函数即可完成 type 值的指定。这个函数是线程安全的，不必另外添加同步。

我们可以在 QEvent 子类中添加自己的事件所需要的数据，然后进行事件的发送。Qt 中提供了两种事件发送方式：

```c++
static bool QCoreApplication::sendEvent(QObject *receiver,
                                        QEvent *event);
```

1. 直接将 event 事件发送给 receiver 接受者，使用的是 QCoreApplication::notify() 函数。函数返回值就是事件处理函数的返回值。在事件被发送的时候，event 对象并不会被销毁。通常我们会在栈上创建 event 对象，例如：

   ```
   QMouseEvent event(QEvent::MouseButtonPress, pos, 0, 0, 0);
   QApplication::sendEvent(mainWindow, &event);
   
   static void QCoreApplication::postEvent(QObject *receiver,
                                           QEvent *event);
   ```

   

2. 将 event 事件及其接受者 receiver 一同追加到事件队列中，函数立即返回。

因为 post 事件队列会持有事件对象，并且在其 post 的时候将其 delete 掉，因此，我们必须在堆上创建 event 对象。当对象被发送之后，再试图访问 event 对象就会出现问题（因为 post 之后，event 对象就会被 delete）。

当控制权返回到主线程循环是，保存在事件队列中的所有事件都通过 notify() 函数发送出去。

事件会根据 post 的顺序进行处理。如果你想要改变事件的处理顺序，可以考虑为其指定一个优先级。默认的优先级是 Qt::NormalEventPriority。

这个函数是线程安全的。

Qt 还提供了一个函数：

```
static void QCoreApplication::sendPostedEvents(QObject *receiver,
                                               int event_type);
```

这个函数的作用是，将事件队列中的接受者为 receiver，事件类似为 event_type 的所有事件立即发送给 receiver 进行处理。需要注意的是，来自窗口系统的事件并不由这个函数进行处理，而是 processEvent()。详细信息请参考 Qt API 手册。

现在，我们已经能够自定义事件对象，已经能够将事件发送出去，还剩下最后一步：处理自定义事件。处理自定义事件，同前面我们讲解的那些处理方法没有什么区别。我们可以重写 QObject::customEvent() 函数，该函数接收一个 QEvent 对象作为参数：

```
void QObject::customEvent(QEvent *event);
```

我们可以通过转换 event 对象类型来判断不同的事件：

```c++
void CustomWidget::customEvent(QEvent *event) {
    CustomEvent *customEvent = static_cast<CustomEvent *>(event);
    // ...
}
```

当然，我们也可以在 event() 函数中直接处理：

```C++
bool CustomWidget::event(QEvent *event) {
    if (event->type() == MyCustomEventType) {
        CustomEvent *myEvent = static_cast<CustomEvent *>(event);
        // processing...
        return true;
    }
    return QWidget::event(event);
}
```

# 18 Qt绘制系统

Qt的绘图系统允许使用相同的API在屏幕上和其它打印设备上进行绘制。整个绘图系统基于QPainter，QPainterDevice和QPaintEngine三个类。

QPainter用来执行绘制的操作；QPaintDevice是一个二维空间的抽象，这个二维空间允许QPainter在其上面进行绘制，也就是QPainter工作的空间；QPaintEngine提供了画笔（QPainter）在不同的设备上进行绘制的统一的接口。QPainteEngine类应用于QPainter和QPaintDevice之间，通常对开发人员是透明的。除非你需要自定义一个设备，否则你是不需要关心QPaintEngine这个类。我们可以把QPainter理解成画笔；把QPaintDevice理解成使用画笔的地方，比如纸张、屏幕等；而对于纸张、屏幕而言，肯定要使用不同的画笔绘制，为了统一使用同一种画笔，我们设计了QPaintEngine类，这个类让不同的纸张、屏幕都能使用一种画笔。

下图给出了这三个类之间的层次结构：

![](G:\images\paint-system.png)

上面的示意图告诉我们，Qt的绘图系统实际上是，使用QPainter在QPainterDevice上进行绘制，它们之间使用QPaintEngine进行通讯（也就是翻译QPainter的指令）。

下面我们通过一个实例来介绍QPainter的使用：

```C++
class PaintedWidget : public QWidget
{
	Q_OBJECT
public:
	PaintedWidget(QWidget *parent = 0);
protected:
	void paintEvent(QPaintEvent*);
}
```

注意我们重写了 QWidget 的 paintEvent() 函数。这或许是我们在理解了 Qt 事件系统之后首次实际应用。接下来就是 PaintedWidget 的源代码：

```c++
PaintedWidget::PaintedWidget(QWidget *parent) : QWidget(parent)
{
	resize(800, 600);
	setWindowTitle(tr("Paint Demo"));
}

void PaintedWidget::paintEvent(QPaintEvent*)
{
	QPainter painter(this);
	painter.drawLine(80, 100, 650, 500);
	painter.setPen(Qt::red);
	painter.drawRect(10, 10, 100, 400);
	painter.setPen(QPen(Qt::green, 5));
	painter.setBrush(Qt::blue);
	painter.drawEllipse(50, 150, 400, 200);
}
```

在构造函数中，我们仅仅设置了窗口的大小和标题。而 paintEvent() 函数则是绘制的代码。首先，我们在栈上创建了一个 QPainter 对象，也就是说，每次运行 paintEvent() 函数的时候，都会重建这个 QPainter 对象。注意，这一点可能会引发某些细节问题：由于我们每次重建 QPainter，因此第一次运行时所设置的画笔颜色、状态等，第二次再进入这个函数时就会全部丢失。有时候我们希望保存画笔状态，就必须自己保存数据，否则的话则需要将 QPainter 作为类的成员变量。

QPainter 接收一个 QPaintDevice 指针作为参数。QPaintDevice 有很多子类，比如 QImage，以及 QWidget。注意回忆一下，QPaintDevice 可以理解成要在哪里去绘制，而现在我们希望画在这个组件，因此传入的是 this 指针。

QPainter 有很多以 draw 开头的函数，用于各种图形的绘制，比如这里的 drawLine()，drawRect() 以及 drawEllipse() 等。当绘制轮廓线时，使用 QPainter 的 pen() 属性。比如，我们调用了 painter.setPen(Qt::red) 将 pen 设置为红色，则下面绘制的矩形具有红色的轮廓线。接下来，我们将 pen 修改为绿色，5 像素宽（painter.setPen(QPen(Qt::green, 5))），又设置了画刷为蓝色。这时候再调用 draw 函数，则是具有绿色 5 像素宽轮廓线、蓝色填充的椭圆。

运行一下我们的程序，可以看到最终效果：

![](G:\images\paint-demo-600x468.png)

另外要说明一点，请注意我们的绘制顺序，首先是直线，然后是矩形，最后是椭圆。按照这样的绘制顺序，可以看到直线是第一个绘制，位于最下一层；矩形是第二个绘制，在中间一层；椭圆是最后绘制，在最上层。

如果了解 OpenGL，肯定听说过这么一句话：OpenGL 是一个状态机。所谓状态机，就是说，OpenGL 保存的只是各种状态。比如，将画笔颜色设置成红色，那么，除非你重新设置另外的颜色，它的颜色会一直是红色。QPainter 也是这样，它的状态不会自己恢复，除非你使用了各种设置函数。因此，如果在上面的代码中，我们在椭圆绘制之后再画一个矩形，它的样式还会是绿色 5 像素的轮廓线以及蓝色的填充，除非你显式地调用了设置函数进行状态的更新。这是大多数绘图系统的实现方式，包括 OpenGL、QPainter 以及 Java2D。正因为 QPainter 是一个状态机，才会引出我们前面曾经介绍过的一个细节问题：由于 paintEvent() 是需要重复进入的，因此，需要注意第二次进入时，QPainter 的状态是不是和第一次一致，否则的话可能会造成闪烁的现象。这个闪烁并不是由于双缓冲的问题，而是由于绘制状态的快速切换。

# 19 画刷和画笔

前面一章我们提到，Qt 绘图系统定义了两个绘制时使用的关键属性：画刷和画笔。前者使用 QBrush 描述，大多用于填充；后者使用 QPen 描述，大多用于绘制轮廓线。

QBrush定义了QPainter的填充模式，具有样式、颜色、渐变以及纹理等属性。

画刷的style()定义了填充的样式，使用Qt::BrushStule枚举，默认值是Qt::NoBrush，也就是不进行任何填充。我们可以从下面的图示中看到各种填充样式的区别：

![](G:\images\brush-fill-pattern-327x480.png)

画刷的color()定义类填充模式的颜色。这个颜色可以是Qt预定义的颜色常量，也就是Qt::GlobalColoor，也可以是任意QColor对象。

画刷的gradient()定义了渐变填充。这个属性只有在样式是Qt::LinearGradientPattern、Qt::RadialGradientPattern 或者 Qt::ConicalGradientPattern 之一时才有效。渐变可以由 QGradient 对象表示。Qt 提供了三种渐变：QLinearGradient、QConicalGradient 和 QRadialGradient，它们都是 QGradient 的子类。我们可以使用如下代码片段来定义一个渐变的画刷：

```c++
QRadiaGradient gradient(50, 50, 50, 50);
gradient.setColorAt(0, QColor::fromRgbF(0, 1, 0, 1));
gradient.setColorAt(1, QColor::fromRgbF(0, 0, 0, 0));

QBrush brush(gradient);
```

当画刷样式是 Qt::TexturePattern 时，texture() 定义了用于填充的纹理。注意，即使你没有设置样式为 Qt::TexturePattern，当你调用 setTexture() 函数时，QBrush 会自动将 style() 设置为 Qt::TexturePattern。

QPen 定义了用于 QPainter 应该怎样画线或者轮廓线。画笔具有样式、宽度、画刷、笔帽样式和连接样式等属性。画笔的样式 style() 定义了线的样式。画刷 brush() 用于填充画笔所绘制的线条。笔帽样式 capStyle() 定义了使用 QPainter 绘制的线的末端；连接样式 joinStyle() 则定义了两条线如何连接起来。画笔宽度 width() 或 widthF() 定义了画笔的宽。注意，不存在宽度为 0 的线。假设你设置 width 为 0，QPainter 依然会绘制出一条线，而这个线的宽度为 1 像素。也就是说，画笔宽度通常至少是 1 像素。

这么多参数既可以在构造时指定，也可以使用set函数指定，完全取决于你的习惯，例如：

```C++
QPainter painter(this);
QPen pen(Qt::green, 3, Qt::DashDotLine, Qt::RoundCap, Qt::RoundJoin);
painter.setPen(pen);
```

等价于

```C++
QPainter painter(this);
QPen pen; //creates a default pen

pen.setStyle(Qt::DashDotLine);
pen.setWidth(3);
pen.setBrush(Qt::green);
pen.setCapStyle(Qt::RoundCap);
pen.setJoinStyle(Qt::RoundJoin);

painter.setPen(pen);
```

使用构造函数的优点是代码较短，但是参数含义不明确；使用 set 函数则正好反过来。

默认的画笔属性是纯黑色，0 像素，方形笔帽（Qt::SquareCap），斜面型连接（Qt::BevelJoin）。

下面是画笔样式的示例：

![](G:\images\pen-style-600x267.png)

你也可以使用 setDashPattern() 函数自定义样式，例如如下代码片段：

```c++
QPen pen;
QVector dashes;
qreal space = 4;

dashes << 1 << 3 << space << 9 << space
	   << 27 << space << 9 << space;
pen.setDashPattern(dashes);
```

笔帽定义了画笔末端的样式，例如：

![](G:\images\cap-style.png)

他们之间的区别是，Qt::SquareCap是一种包含了最后一个点的方形端点，使用半个线宽覆盖；Qt::FlatCap不包含最后一个点；Qt::RoundCap是包含最后一个点的圆形端点。具体可以参考下面的示例：

![](G:\images\cap-style-2.png)

连接样式定义了两条线连接时的样式，例如：

![](G:\images\join-style-600x341.png)

同样，可以参考下面图示来理解这几种连接样式的细节（出自《C++ GUI Programming with Qt 4, 2nd Edition》）：

![](G:\images\join-style-2.png)

注意，我们前面说了，QPainter 也是一个状态机，这里我们所说的这些属性都是处于这个状态机之中的，因此，我们应该记得是否要将其保存下来或者是重新构建。

我们在光栅图形显示器上绘制非水平、非垂直的直线或多边形边界时，或多或少会呈现锯齿状外观。这是因为直线和多边形的边界是连续的，而光栅则是由离散的点组成。在光栅显示设备上表现直线、多边形等，必须在离散位置采样。由于采样不充分重建后造成的信息失真，就叫走样；用于减少或消除这种效果的技术，就称为反走样。

反走样是图形学中的重要概念，用以防止通常所说的“锯齿”现象的出现。很多系统的绘图 API 里面都内置了有关反走样的算法，不过由于性能问题，默认一般是关闭的，Qt 也不例外。下面我们来看看代码：

```c++
void paintEvent(QPaintEvent*)
{
	QPainter painter(this);
	painter.setPen(QPen(Qt::black, 5, Qt::DashDotLine, Qt::RoundCap));
	painter.setBrush(Qt::yellow);
	painter.drawEllipse(50, 150, 200, 150);
	
	painter.setRenderHint(QPainter::Antialiasing, true);
	painter.setPen(QPen(Qt::black, 5, Qt::DashDotLine, Qt::RoundCap));
	painter.setBrush(Qt::yellow);
	painter.drawEllipse(300, 150, 200, 150);
}
```

看看运行后的结果：

![](G:\images\qt-antialiasing.png)

注意看左侧椭圆与右侧椭圆在边界处的区别。左侧没有使用反锯齿，明细显示出锯齿的样子；右侧则增加了反锯齿代码。

在这段代码中，我们创建了一个黑色 5 像素宽的画笔，使用了点线的样式，圆形笔帽：

```C++
painter.setPen(QPen(Qt::black, 5, Qt::DAshDoLine, Qt::RoundCap));
```

然后我们使用一个黄色的画刷填充，绘制一个椭圆。

第二个椭圆的绘制与第一个十分相似，唯一的区别是多了一句

```C++
painter.setRendHint(QPainter::Antialiasing, true);
```

显然，我们通过这条语句，将 Antialiasing 属性（也就是反走样）设置为 true。经过这句设置，我们就打开了 QPainter 的反走样功能。还记得我们曾经说过，QPainter 是一个状态机，因此，只要这里我们打开了它，之后所有的代码都会是反走样绘制的了。由于反走样需要比较复杂的算法，在一些对图像质量要求不是很高的应用中，是不需要进行反走样的。为了提高效率，一般的图形绘制系统，如 Java2D、OpenGL 之类都是默认不进行反走样的。

![](G:\images\ps-points.png)

这是使用 Photoshop 的铅笔和画笔工具绘制的 1 像素的点，放大 3200% 的视图。在一定程度上，我们可以认为，Photoshop 的铅笔工具是不进行反走样，而画笔是要进行反走样的。在放大的情况下就会知道，有反走样的情况下是不能进行精确到 1 像素的操作的。因为反走样很难让你控制到 1 个像素。这不是 Photoshop 画笔工具的缺陷，而是反走样算法的问题。反走样之所以看起来比较模糊，就是因为它需要以一种近似色来替换原始的像素色，这样一来就会显得模糊而圆滑。

# 20 渐变

渐变是绘图中很常见的一种功能，简单来说就是可以把几种颜色混合在一起，让它们自然过渡，而不是一下子变成另外一种颜色。渐变的算法比较复杂，写得不好的话效率会很低，好在很多绘图系统都内置了渐变的功能，Qt也不例外。渐变一般是用在填充里面的，所以，设置渐变是在QBrush里面。

Qt提供了三种渐变：线性渐变（QLinearGradient）、辐射渐变（QRadialGradient）和角度渐变（QConicalGradient）。我们可以在Qt API手册中看到这几种渐变的区别：

线性渐变：

![](G:\images\QLinearGradient-600x279.png)

辐射渐变：

![](G:\images\QRadialGradient-600x259.png)

角度渐变：

![](G:\images\QConicalGradient.png)

具体细节可以参考文档。下面我们通过一个示例看看如何使用渐变进行填充：

```c++
void paintEvent(QPaintEvent *)
{
	QPainter painter(this);
	
	painter.setRenderHint(QPianter::Antialiasing, true);
	QLinearGradient linearGradient(60, 50, 200, 200);
	linearGradient.setColorAt(0.2, Qt::white);
	linearGradient.setColorAt(0.6, Qt::green);
	linearGradient.setColorAt(1.0, Qt::black);
	painter.setBrush(QBrush(linearGradient));
	painter.drawEllipse(50, 50, 200, 150);
}
```

像以前一样，我们也只给出了 paintEvent() 的代码。这段代码看起来也相当清晰：首先我们打开了反走样，然后创建一个 QLinearGradient 对象实例。QLinearGradient 也就是线性渐变，其构造函数有四个参数，分别是 x1，y1，x2，y2，即渐变的起始点和终止点。在这里，我们从 (60, 50) 点开始渐变，到 (200, 200) 点止。关于坐标的具体细节，我们会在后面的章节中详细介绍。渐变的颜色是在 setColorAt() 函数中指定的。下面是这个函数的签名：

```c++
void QGradient::setColorAt ( qreal position, const QColor & color )
```

这个函数的作用是，把 position 位置的颜色设置成 color。其中，position 是一个 [0, 1] 闭区间的数字。也就是说，position 是相对于我们建立渐变对象时做的那个起始点和终止点区间的一个比例。以这个线性渐变为例，在从 (60, 50) 到 (200, 200) 的线段上，在 0.2，也就五分之一处设置成白色，在 0.6 也就是五分之三处设置成绿色，在 1.0 也就是终点处设置成黑色。创建 QBrush 对象时，把这个渐变对象传递进去，然后就可以运行了：

![](G:\images\gradient-demo.png)

下面我们开始一个更复杂，也更实用一些的例子：绘制一个色轮（color wheel）。所谓色轮，其实就是一个带有颜色的圆盘（或许你没听说过这个名字，但是你肯定见过这个东西），下面是色轮的运行结果：

![](G:\images\color-wheel.png)

我们来看看它的代码：

```C++
void ColorWheel::paintEvent(QPaintEvent *)
{
	QPainter painter(this);
	painter.setRenderHint(QPainter::Antialiasing);
	
	const int r = 150;
	QConicalGradient conicalGradient(0, 0, 0);
	
	conicalGradient.setColorAt(0.0, Qt::red);
	conicalGradient.setColorAt(60.0/360.0, Qt::yellow);
	conicalGradient.setColorAt(120.0/360.0, Qt::green);
	conicalGradient.setColorAt(180.0/360.0, Qt::cyan);
	conicalGradient.setColorAt(240.0/360.0, Qt::blue);
	conicalGradient.setColorAt(300.0/360.0, Qt::magenta);
	conicalGradient.setColorAt(1.0, Qt::red);
    
	painter.translate(r, r);
	
	QBrush brush(conicalGradient);
	painter.setPen(Qt::NoPen);
	painter.setLBrush(brush);
	painter.drawEllipse(QPoint(0, 0), r, r);
}
```

首先还是新建 QPainter 对象，开启反走样。然后我们将圆盘半径定义为 150。下面创建一个角度渐变实例，其构造函数同样接受三个参数：

```C++
QConicalGradient::QConicalGradient ( qreal cx, qreal cy, qreal angle )
```

前两个参数 cx 和 cy 组成角度渐变的中心点，第三个参数是渐变的起始角度。在我们的例子中，我们将渐变中心点设置为 (0, 0)，起始角度为 0。类似线性渐变，角度渐变的 setColorAt() 函数同样接受两个参数，第一个是角度比例，第二个是颜色。例如，

```C++
conicalGradient.setColorAt(0.0, Qt::red);
```

将 0 度角设置为红色；

```c++
conicalGradient.setColorAt(60.0/360.0, Qt::yellow);
```

将 60 度角设置为黄色。由于一个圆周是 360 度，所以 60.0/360.0 即是这个角度的比例。其余代码以此类推。最后一句，我们将 1.0 处设置为红色，也就是重新回到起始处。至于颜色的分布，这是由颜色空间定义的，有兴趣的朋友可以查阅有关颜色模型的理论。

```C++
painter.translate(r, r);
```

这是我们唯一不熟悉的函数。QPainter::translate(x, y) 函数意思是，将坐标系的原点设置到 (x, y) 点。原本坐标系原点位于左上角，我们使用 translate(r, r)，将坐标原点设置为 (r, r)。这么一来，左上角的点的坐标就应该是 (-r, -r)。

PS：为了理解 translate() 函数的作用，可以思考下，如果去掉 translate() 函数的调用，我们的程序应该如何修改。答案是：

```c++
void ColorWheel::paintEvent(QPaintEvent *)
{
    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing);

    const int r = 150;
    QConicalGradient conicalGradient(r, r, 0);

    conicalGradient.setColorAt(0.0, Qt::red);
    conicalGradient.setColorAt(60.0/360.0, Qt::yellow);
    conicalGradient.setColorAt(120.0/360.0, Qt::green);
    conicalGradient.setColorAt(180.0/360.0, Qt::cyan);
    conicalGradient.setColorAt(240.0/360.0, Qt::blue);
    conicalGradient.setColorAt(300.0/360.0, Qt::magenta);
    conicalGradient.setColorAt(1.0, Qt::red);

    QBrush brush(conicalGradient);
    painter.setPen(Qt::NoPen);
    painter.setBrush(brush);
    painter.drawEllipse(QPoint(r, r), r, r);
```

不仅我们需要修改最后的绘制语句，还需要注意修改 QConicalGradient 定义时传入的中心点的坐标。

# 21 坐标系统

在经历过实际操作，以及前面一节中我们见到的那个 translate() 函数之后，我们可以详细了解下 Qt 的坐标系统了。泛泛而谈坐标系统，有时候会觉得枯燥无味，难以理解，好在现在我们已经有了基础。

坐标系统是由QPainter控制的。我们前面说过，QPaintDevice、QPaintEngine和QPainter是Qt绘制系统的三个核心类。QPainter用于进行绘制的实际操作；QPaintDevice是那些能够让QPainter进行绘制的“东西”（准确的术语叫做，二维空间）的抽象层（其子类有QWidget、QPixmap、QImage和QPrinter等）；QPainterEngine提供QPainter使用的用于不同设备上绘制的统一的接口。

由于QPainterDevice是进行绘制的对象，因此，所谓坐标系统，也就是QPaintDevice上面的坐标。默认坐标系统位于设备的左上角，也就是坐标原点（0,0）。x轴方向向右；y轴方向向下。在基于像素的设备上（比如显示器），坐标默认单位是像素，在打印机上则是点（1/72英寸）。

将QPainter的逻辑坐标与QPaintDevice的物理坐标进行映射的工作，是由QPainter的变换矩阵（transformation matrix）、视口（viewport）和窗口（window）完成的。如果你不理解这些术语，可以简单了解下有关图形学的内容。实际上，对图形的操作，底层的数学都是进行的矩阵变换、相乘等运算。

在Qt的坐标系统中，每个像素占据1 X 1的空间。你可以把它想象成一张方格纸，每个小格都是一个像素。方格的焦点定义了坐标，也就是说，像素（x，y）的中心位置其实是在（x + 0.5，y + 0.5)的位置上。这个坐标系统实际上是一个“半像素坐标系”。我们可以通过下面的示意图来理解这种坐标系：

![](G:\images\coordinate-system-demo-600x308.png)

我们使用一个像素的画笔进行绘制，可以看到，每一个绘制像素都是以坐标点为中心的矩形。 **注意，这是坐标的逻辑表示，实际绘制则与此不同。** 因为在实际设备上，像素是最小单位，我们不能像上面一样，在两个像素之间进行绘制。所以在实际绘制时，Qt 的定义是，绘制点所在像素是逻辑定义点的右下方的像素。

我们前面已经介绍过，Qt 的绘制分为走样和反走样两种。对此，我们必须分别对待。

一个像素的绘制最简单，我们从这里开始：

![](G:\images\1px-painting-600x409.png)

![](G:\images\mutilpx-painting-594x480.png)

Qt 的这种处理，带来的一个问题是，我们可能获取不到真实的坐标值。由于历史原因，QRect::right() 和 QRect::bottom() 的返回值并不是矩形右下角点的真实坐标值：QRect::right() 返回的是 left() + width() – 1；QRect::bottom() 则返回 top() + height() – 1，上图的绿色点指出了这两个函数的返回点的坐标。

为避免这个问题，我们建议是使用 QRectF。QRectF 使用浮点值，而不是整数值，来描述坐标。这个类的两个函数 QRectF::right() 和 QRectF::bottom() 是正确的。如果你不得不使用 QRect，那么可以利用 x() + width() 和 y() + height() 来替代 right() 和 bottom() 函数。

对于反走样，实际绘制会包裹住逻辑坐标值：

![](G:\images\anti-aliasing-painting-600x421.png)

这里我们不去解释为什么在反走样是，像素颜色不是一致的，这是由于反走样算法导致，已经超出本节的内容。

Qt 同样提供了坐标变换。前面说，图形学大部分算法依赖于矩形计算，坐标变换便是其中的代表：每一种变换都对应着一个矩阵乘法（如果你想知道学的线性代数有什么用处，这就是应用之一了 ;-P）。我们会以一个实际的例子来了解坐标变换。在此之前，我们需要了解两个函数：QPainter::save() 和 QPainter::restore()。

前面说过，QPainter 是一个状态机。那么，有时我想保存下当前的状态：当我临时绘制某些图像时，就可能想这么做。当然，我们有最原始的办法：将可能改变的状态，比如画笔颜色、粗细等，在临时绘制结束之后再全部恢复。对此，QPainter 提供了内置的函数：save() 和 restore()。save() 就是保存下当前状态；restore() 则恢复上一次保存的结果。这两个函数 **必须** 成对出现：QPainter 使用栈来保存数据，每一次 save()，将当前状态压入栈顶，restore() 则弹出栈顶进行恢复。

在了解了这两个函数之后，我们就可以进行示例代码了：

```c++
void PaintDemo::paintEvent(QPaintEvent *)
{
	QPainter painter(this);
    painter.fillRect(10, 10, 50, 100, Qt::red);
    painter.save();
    painter.translate(100, 0); //向右平移100px
    painter.fillRect(10, 10, 50, 100, Qt::yellow);
    painter.restore();
    painter.save();
    painter.translate(300, 0);//向右平移300px
    painter.rotate(30); //顺时针旋转30度
    painter.fillRect(10, 10, 50, 100);
    painter.restore();
    painter.save();
    painter.translate(400, 0); //向右平移400px
    painter.scale(2, 3);//横坐标单位放大2倍，纵坐标单位放大3倍
    painter.fillRect(10, 10, 50, 100, Qt::blue);
    painter.restore();
    painter.save();
    painter.translate(600, 0);// 向右平移600px
    painter.shear(0, 1); //横向不变，纵向扭曲1倍
    painter.fillRect(10, 10, 50, 100, Qt::cyan);
    painter.restore();
}
```

Qt 提供了四种坐标变换：平移 translate，旋转 rotate，缩放 scale 和扭曲 shear。在这段代码中，我们首先在 (10, 10) 点绘制一个红色的 50×100 矩形。保存当前状态，将坐标系平移到 (100, 0)，绘制一个黄色的矩形。注意，translate() 操作平移的是坐标系，不是矩形。因此，我们还是在 (10, 10) 点绘制一个 50×100 矩形，现在，它跑到了右侧的位置。然后恢复先前状态，也就是把坐标系重新设为默认坐标系（相当于进行 translate(-100, 0)），再进行下面的操作。之后也是类似的。由于我们只是保存了默认坐标系的状态，因此我们之后的 translate() 横坐标值必须增加，否则就会覆盖掉前面的图形。所有这些操作都是针对坐标系的，因此在绘制时，我们提供的矩形的坐标参数都是不变的。

运行结果如下：

![](G:\images\coordinate-transformations-demo-600x333.png)

Qt的坐标分为逻辑坐标和物理坐标。在我们绘制时，提供给QPainter的都是逻辑坐标。之前我们看到的坐标变换，也是针对逻辑坐标的。所谓物理坐标，就是绘制底层QPaintDevice的坐标。单单只是逻辑坐标，我们是不能在设备上进行绘制的。要想在设备上绘制，必须提供设备认识的物理坐标。Qt使用viewport-window机制将我们提供的逻辑坐标转换成绘制设备使用的物理坐标，方法是，在逻辑坐标和物理坐标之间提供一层“窗口”坐标。视口是由任意矩形指定的物理坐标；窗口则是该矩形的逻辑坐标表示。默认该矩形的逻辑坐标表示。默认情况下，物理坐标和逻辑坐标是一致的，都等于设备矩形。

视口坐标（也就是物理坐标）和窗口坐标是一个简单的线性变换。比如一个400 X 400的窗口，我们添加如下代码：

```C++
void PaintDemo::paintEvent(QPaintEvent *)
{
	QPainter painter(this);
	painter.setWindow(0, 0, 200, 200);
	painter.fillRect(0, 0, 200, 200, Qt::red);
}
```

我们将窗口矩形设置为左上角坐标为（0， 0），长和宽都200px。此时，坐标原点不变，还是左上角，但是对于原来的（400， 400）点，新的窗口坐标是（200， 200）。我们可以理解成，

我们将窗口矩形设置为左上角坐标为 (0, 0)，长和宽都是 200px。此时，坐标原点不变，还是左上角，但是，对于原来的 (400, 400) 点，新的窗口坐标是 (200, 200)。我们可以理解成，逻辑坐标被“重新分配”。这有点类似于 translate()，但是，translate() 函数只是简单地将坐标原点重新设置，而 setWindow() 则是将整个坐标系进行了修改。这段代码的运行结果是将整个窗口进行了填充。

试比较下面两行代码的区别（还是 400×400 的窗口）：

```C++
painter.translate(200, 200);
painter.setWindow(-160, -320, 320, 640);
```

第一行代码，我们将坐标原点设置到 (200, 200) 处，横坐标范围是 [-200, 200]，纵坐标范围是 [-200, 200]。第二行代码，坐标原点也是在窗口正中心，但是，我们将物理宽 400px 映射成窗口宽 320px，物理高 400px 映射成窗口高 640px，此时，横坐标范围是 [-160, 160]，纵坐标范围是 [-320, 320]。这种变换是简单的线性变换。假设原来有个点坐标是 (64， 60)，那么新的窗口坐标下对应的坐标应该是 ((-160 + 64 * 320 / 400), (-320 + 60 * 640 / 400)) = (-108.8, -224)。

下面我们再来理解下视口的含义。还是以一段代码为例：

```C++
void PaintDemo::paintEvent(QPaintEvent *)
{
    QPainter painter(this);
    painter.setViewport(0, 0, 200, 200);
    painter.fillRect(0, 0, 200, 200, Qt::red);
}
```

这段代码和前面一样，只是把 setWindow() 换成了 setViewport()。前面我们说过，window 代表窗口坐标，viewport 代码物理坐标。也就是说，我们将物理坐标区域定义为左上角位于 (0, 0)，长高都是 200px 的矩形。然后还是绘制和上面一样的矩形。如果你认为运行结果是 1/4 窗口被填充，那就错了。实际是只有 1/16 的窗口被填充。这是由于，我们修改了物理坐标，但是没有修改相应的窗口坐标。默认的逻辑坐标范围是左上角坐标为 (0, 0)，长宽都是 400px 的矩形。当我们将物理坐标修改为左上角位于 (0, 0)，长高都是 200px 的矩形时，窗口坐标范围不变，也就是说，我们将物理宽 200px 映射成窗口宽 400px，物理高 200px 映射成窗口高 400px，所以，原始点 (200, 200) 的坐标变成了 ((0 + 200 * 200 / 400), (0 + 200 * 200 / 400)) = (100, 100)。

现在我们可以用一张图示总结一下逻辑坐标、窗口坐标和物理坐标之间的关系：

![](G:\images\coordinate-system-instruction-600x228.png)

我们传给 QPainter 的是逻辑坐标（也称为世界坐标），逻辑坐标可以通过变换矩阵转换成窗口坐标，窗口坐标通过 window-viewport 转换成物理坐标（也就是设备坐标）。

# 22 绘制设备

绘图设备是继承QPainterDevice的类。QPaintDevice就是能够进行绘制的类，也就是说，QPainter可以在任何QPaintDevice的子类上进行绘制。现在，Qt提供了若干这样的类：

Qt4：

![](G:\images\paint-device-qt4-600x240.png)

Qt5：

![](G:\images\paint-device-qt5-600x239.png)

上面的是Qt4的相关类图，下面是Qt5。这两部分大致相同，只是在Qt5中，QGLPixelBuffer已经被废弃。本章我们关注的是QPixmap、QBitmap、QImage和QPicture这几个类。另外的部分，QWidget就是所有组件的父类，我们已经在前面的章节使用过，这里不再赘述。QGLWidget和QGLFramebufferObject，顾名思义，就是关于OpenGL的相关类。在Qt中，我们可以方便地结合OpenGL进行绘制。由于这部分需要牵涉到OpenGL的相关内容，现在也不再深入。在我们选择的几个类中，大多与图像密切相关。

QPixmap专门为图像在屏幕上的显示做了优化；QBitmap是QPixmap的一个子类，它的色深限定为1，你可以使用永QPixmap的isQBitmap()函数来确定这个QPixmap是不是QBitmap。QImage专门为图像的像素级访问做了优化。QPicture则可以记录和重现QPainter的条条命令。下面我们将分两部分介绍四种绘图设备。

QPixmap继承了QPaintDevice，因此，你可以直接使用QPainter直接在上面绘制图形。QPixmap也可以接受一个字符串作为一个文件的路径来显示这个文件，比如你想在程序中打开png、jpeg之类的文件，就可以使用QPixmap。使用QPainter::drawPixmap()函数可以把这个文件绘制到一个QLabel、QPushButton或者其它的设备上面。正如前面所说的那样，QPixmap是针对屏幕进行特殊优化的，因此，它与实际的底层显示设备息息相关。注意，这里说的显示设备并不是硬件，而是操作系统提供的绘图引擎。所以，在不同的操作系统平台下，QPixmap的显示可能会有所差别。

QPixmap提供了静态的grabWidget()和grabWindow()函数，用于将自身图像绘制到目标上。同时，在使用QPixmap时，你可以直接使用传值的形式，不需要传指针，因为QPixmap提供了“隐式数据共享”。关于这一点，我们会在以后的章节详细描述。简单来说，就是一般对于大型数据（图像无疑就是这种“大型数据”），为性能起见，通常会采用传指针的方式，但是由于QPixmap内置了隐式数据共享，所以只值传递QPixmap。

前面说过，QBitmap 继承自 QPixmap，因此具有 QPixmap 的所有特性。不同之处在于，QBitmap 的色深始终为 1。色深这个概念来自计算机图形学，是指用于表现颜色的二进制的位数。我们知道，计算机里面的数据都是使用二进制表示的。为了表示一种颜色，我们也会使用二进制。比如我们要表示 8 种颜色，需要用 3 个二进制位，这时我们就说色深是 3。因此，所谓色深为 1，也就是使用 1 个二进制位表示颜色。1 个位只有两种状态：0 和 1，因此它所表示的颜色就有两种，黑和白。所以说，QBitmap 实际上是只有黑白两色的图像数据。由于 QBitmap 色深小，因此只占用很少的存储空间，所以适合做光标文件和笔刷。

下面我们来看同一个图像文件在 QPixmap 和 QBitmap 下的不同表现：

```C++
void paintEvent(QPaintEvent *)
{
	QPainter painter(this);
	QPixmap pixmap("qt-logo.png");
	QBitmap bitmap("qt-logo.png");
	painter.drawPixmap(10, 10, 250, 125, pixmap);
	painter.drawPixmap(270, 10, 250, 125, pixmap);
	QPixmap whitePixmap("qt-logo-white.png");
	QBitmap whiteBitmap("qt-logo-white.png");
	painter.drawPixmap(10, 140, 200, 125, whitePixmap);
	painter.drawPixmap(270, 140, 250, 125, whiteBitmap);
}
```

先来看一下运行结果：

![](G:\images\qpixmap-qbitmap-demo.png)

这里我们给出了两张 png 图片。qt-logo.png 具有透明背景，qt-logo-white.png 具有白色背景。我们分别使用 QPixmap 和 QBitmap 来加载它们。注意看它们的区别：白色的背景在 QBitmap 中消失了，而透明色在QBitmap 中转换成了黑色（“黑色”，记住，QBitmap 只有两种颜色：黑色和白色）；其他颜色则是使用点的疏密程度来体现的。

QPixmap 使用底层平台的绘制系统进行绘制，无法提供像素级别的操作，而 QImage 则是使用独立于硬件的绘制系统，实际上是自己绘制自己，因此提供了像素级别的操作，并且能够在不同系统之上提供一个一致的显示形式。

![](G:\images\qimage-32bit-600x294.png)

QImage 与 QPixmap 相比，最大的优势在于能够进行像素级别的操作。我们通过上面的示意图可以看到，我们声明一个 3 x 3 像素的 QImage 对象，然后利用 setPixel() 函数进行颜色的设置。你可以把 QImage 想象成一个 RGB 颜色的二维数组，记录了每一像素的颜色。值得注意的是，在 QImage 上进行绘制时，不能使用 QImage::Format_Indexed8 这种格式。

最后一种 QPicture 是平台无关的，因此它可以使用在多种设备之上，比如 svg、pdf、ps、打印机或者屏幕。回忆下我们曾经说的 QPaintDevice，实际上是说可以由 QPainter 进行绘制的对象。QPicture 使用系统分辨率，并且可以调整 QPainter 来消除不同设备之间的显示差异。如果我们要记录下 QPainter 的命令，首先要使用 QPainter::begin() 函数，将 QPicture 实例作为参数传递进去，以便告诉系统开始记录，记录完毕后使用 QPainter::end() 命令终止。代码示例如下：

```C++
QPicture picture;
QPainter painter;
painter.begin(&picture); //在picture上进行绘制
painter.drawEllipse(10, 20, 80, 70);//绘制一个椭圆
painter.end(); //绘制完成
picture.save("drawing.pic"); //保存picture
```

如果我们要重现命令，首先要使用 QPicture::load() 函数进行装载：

```C++
QPicture picture;
picture.load("drawing.pic");
QPainter painter;
painter.begin(&myImage); //在（0,0）上开始绘制
painter.drawPicture(0, 0, picture);//在（0,0）点开始绘制picture
painter.end();
```

# 23 Graphics View Framework

Graphics View 提供了一种接口，用于管理大量自定义的 2D 图形元素，并与之进行交互；还提供了用于将这些元素进行可视化显示的观察组件，并支持缩放和旋转。我们通常所说的 Linux 的 KDE 桌面环境，就是建立在 Graphics View 基础之上的（尽管新版本的 KDE 有向 QML 迁移的趋势）。

Graphics View 框架包含了一套完整的事件体系，可以用于与场景中的元素进行双精度的交互。这些元素同样支持键盘事件、鼠标事件等。Graphics View 使用了 BSP 树（Binary Space Partitioning tree，这是一种被广泛应用于图形学方面的数据结构）来提供非常快速的元素发现，也正因为如此，才能够实现一种上百万数量级元素的实时显示机制。

Graphics View 最初在 Qt 4.2 引入，来取代 Qt 3 中的 QCanvas。当然，在最新的 Qt5 中，Qt3 的代码已经不能继续使用了（尽管在一定程度上， Qt4 还是可以使用这些遗留代码）。

Graphics View 是一个基于元素（item）的 MV 架构的框架。它可以分成三个部分：元素 item、场景 scene 和视图 view。

基于元素的意思是，它的每一个组件都是一个独立的元素。这是与我们之前讲到过的 QPainter 状态机机制不同。回忆一下，使用 QPainter 绘图，大多是采用一种面向过程的描述方式：首先使用 drawLine() 画一条直线，然后使用 drawPolygon() 画一个多边形。对于 Graphics View，相同的过程可以是，首先创建一个场景（scene），然后创建一个直线对象和一个多边形对象，再使用场景的 add() 函数，将直线和多边形添加到场景中，最后通过视图进行观察，就可以看到了。乍看起来，后者似乎更加复杂，但是，如果你的图像中包含了成千上万的直线、多边形之类，管理这些对象要比管理 QPainter 的绘制语句容易得多。并且，这些图形对象也更加符合面向对象的设计要求：一个很复杂的图形可以很方便的复用。

MV 架构的意思是，Graphics View 提供一个 model 和一个 view（正如 MVC 架构，只不过 MV 架构少了 C 这么一个组件）。所谓模型（model）就是我们添加的种种对象；所谓视图（view）就是我们观察这些对象的视口。同一个模型可以由很多视图从不同的角度进行观察，这是很常见的需求。使用 QPainter 很难实现这一点，这需要很复杂的计算，而 Graphics View 可以很容易的实现。

Graphics View 提供了 QGraphicsScene 作为场景，即是允许我们添加图形的空间，相当于整个世界；QGraphicsView 作为视口，也就是我们的观察窗口，相当于照相机的取景框，这个取景框可以覆盖整个场景，也可以是场景的一部分；QGraphicsItem 作为图形元件，以便添加到场景中去，Qt 内置了很多图形，比如直线、多边形等，它们都是继承自 QGraphicsItem。

下面我们通过一段代码看看 Graphics View 的使用。

```
int main(int argc, char *argv[])
{
	QApplication app(argc, argv);
	
	QGraphicScene scene;
	secne.addLine(0, 0, 150, 150);
	
	QGraphicsView view(&scene);
	view.setWindowTitle("Graphics View");
	view.resize(500, 500);
	view.show();
	
	return app.exec();
}
```

这段代码很简单：首先创建一个场景，也就是 QGraphicsScene 对象。然后我们使用 addLine() 函数向场景中添加了一个直线，起始点和终点坐标分别是 (0, 0) 和 (150, 150)。可以想象，这是一个边长 150px 的正方形的对角线。通过这两步，我们已经有了场景和元素。之后，我们创建一个 GraphicsView 对象，绑定到一个场景上（也就是我们前面创建的 scene 对象）。注意，QGraphicsScene 不是 QWidget 的子类，因此该构造函数并不是调用的 QGraphicsView(QWidget *parent)。接下来，我们可以运行一下代码：

![](G:\images\graphics-view-demo-460x480.png)

我们看到，这个直线自动在视图居中显示。这并不需要我们进行任何额外的代码。如果不想这么做，我们可以给 scene 设置一下 sceneRect() 属性：

```C++
QGraphicsScene scene;
scene.setSceneRect(0, 0, 300, 300);
scene.addLine(0, 0, 150, 150);

QGraphicsView view(&scene);
view.setWindowTitle("Graphics View");
view.show();
```

不仅如此，我们还去掉了 view.resize() 一行。QGraphicsScene 的 sceneRect 属性供 QGraphicsView 确定视图默认的滚动条区域，并且协助 QGraphicsScene 管理元素索引。之所以去掉 view.resize() 一行，是因为我们让系统去决定视图的最小尺寸（否则的话，我们需要手动将窗口标题栏等的大小同时考虑设置）。

# 24 贪吃蛇游戏

经过前面一段时间的学习，我们已经了解到有关 Qt 相当多的知识。现在，我们将把前面所讲过的知识综合起来，开发一个贪吃蛇游戏。游戏很简单，相信大家都有见过，多多少少也都玩过。我们在实现这个贪吃蛇游戏时，会利用到事件系统、Graphics View Framework、QPainter 等相关内容，也会了解到一个游戏所具有的一些特性，比如游戏循环等，在 Qt 中如何体现出来。当然，最重要的是，通过一个相对较大的程序，学习到如何将之前的点点滴滴结合在一起。

本部分的代码出自：http://qtcollege.co.il/developing-a-qt-snake-game/ ，但是有一些基于软件工程方面考虑的修改，例如常量放置的位置等。

前面说过，Qt 提供了自己的绘制系统，还提供了 Graphics View Framework。很明显，绘制图形和移动图形，是一个游戏的核心。对于游戏而言，将其中的每一个部分看做对象是非常合理的，也是相当有成效的。因此，我们选择 Graphics View Framework 作为核心框架。回忆一下，这个框架具有一系列面向对象的特性，能够让我们将一个个图形作为对象进行处理。同时，Graphics View Framework 的性能很好，即便是数千上万的图形也没有压力。这一点非常适合于游戏。

正如我们前面所说，Graphics View Framework 有三个主要部分：

* QGraphicsScene：能够管理元素的非GUI容器；
* QGraphicsItem：能够被添加到场景的元素；
* QGraphicsView：能够观察场景的可视化组件视图。

对于游戏而言，我们需要一个QGraphicsScene，作为游戏发生的舞台；一个QGraphicsView，作为观察游戏舞台的组件；以及若干元素，用于表示游戏对象，比如蛇，食物以及障碍物等。

大致分析过游戏组成以及各部分的实现方式后，我们可以开始编码了。这当然是一个GUI过程，主窗口应该是一个QGraphicsView。为了以后的实现方便（比如，我们希望向工具栏添加按钮等），我们不会直接以QGraphicsView作为顶层窗口，而是将其添加到一个主窗口上。这里我们不会使用QtDesigner进行界面设计，而是直接编码完成。

```C++
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>

class QGraphicsScene;
class QGraphicsView;

class GameController;

class MainWindow : public QMainWindow
{
    Q_OBJECT
public:
    MainWindow(QWidget *parent = 0);
    ~MainWindow();

private slots:
    void adjustViewSize();

private:
    void initScene();
    void initSceneBackground();

    QGraphicsScene *scene;
    QGraphicsView *view;

    GameController *game;
};

#endif // MAINWINDOW_H
```

在头文件中声明了 MainWindow。构造函数除了初始化成员变量，还设置了窗口的大小，并且需要对场景进行初始化：

```c++
MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    scene(new QGraphicsScene(this)),
    view(new QGraphicsView(scene, this)),
    game(new GameController(*scene, this))
{
    setCentralWidget(view);
    resize(600, 600);

    initScene();
    initSceneBackground();

    QTimer::singleShot(0, this, SLOT(adjustViewSize()));
}
```

值得说明的是最后一行代码。singleShot() 函数原型如下：

```c++
static void QTimer::singleShot(int msec, QObject* receiver, const char *member);
```

该函数接受三个参数，简单来说，它的作用是，在 msec 毫秒之后，调用 receiver 的 member **槽函数** 。在我们的代码中，第一个参数传递的是 0，也就是 0ms 之后，调用 this->adjustViewSize()。这与直接调用 this->adjustViewSize(); 有什么区别呢？如果你看文档，这一段的解释很隐晦。文档中写到：“It is very convenient to use this function because you do not need to bother with a timerEvent or create a local QTimer object”，也就是说，它的作用是方便使用，无需重写 timerEvent() 函数或者是创建一个局部的 QTimer 对象。当我们使用 QTimer::signleShot(0, …) 的时候，实际上也是对 QTimer 的简化，而不是简单地函数调用。QTimer 的处理是将其放到事件列表中，等到下一次事件循环开始时去调用这个函数。那么，QTimer::signleShot(0, …) 意思是，在下一次事件循环开始时，立刻调用指定的槽函数。在我们的例子中，我们需要在视图绘制完毕后才去改变大小（视图绘制当然是在 paintEvent() 事件中），因此我们需要在下一次事件循环中调用 adjustViewSize() 函数。这就是为什么我们需要用 QTimer 而不是直接调用 adjustViewSize()。如果熟悉 flash，这相当于 flash 里面的 callLater() 函数。接下来看看 initScene() 和 initSceneBackground() 的代码：

```
void MainWindow::initScene()
{
	scene->setSceneRect(-100, -100, 200, 200);
}

void MainWindow::initSceneBackground()
{
	QPixmap bg(TILE_SIZE, TILE_SIZE);
	QPainter p(&bg);
	p.setBrush(QBrush(Qt::gray));
	p.drawRect(0, 0, TILE_SIZE, TILE_SIZE);
	
	view->setBackgroundBrush(QBrush(bg));
}
```

initScene() 函数设置场景的范围，是左上角在 (-100, -100)，长和宽都是 200px 的矩形。默认情况下，场景是无限大的，我们代码的作用是设置了一个有限的范围。Graphics View Framework 为每一个元素维护三个不同的坐标系：场景坐标，元素自己的坐标以及其相对于父组件的坐标。除了元素在场景中的位置，其它几乎所有位置都是相对于元素坐标系的。所以，我们选择的矩形 (-100, -100, 200, 200)，实际是设置了场景的坐标系。此时，如果一个元素坐标是 (-100, -100)，那么它将出现在场景左上角，(100, 100) 的坐标则是在右下角。

initSceneBackground() 函数看似很长，实际却很简单。首先我们创建一个边长 TILE_SIZE 的 QPixmap，将其使用灰色填充矩形。我们没有设置边框颜色，默认就是黑色。然后将这个 QPixmap 作为背景画刷，铺满整个视图。

现在我们的程序看起来是这样的：

![](G:\images\snake-scene-463x480.png)

# 25 文件

文件操作是应用程序必不可少的部分。Qt作为一个通用开发库，提供了跨平台的文件操作能力。从本章开始，我们来了解下Qt的文件以及输入输出的功能，也就是I/O系统。

Qt通过QIODevice提供了对I/O设备的抽象，这些设备具有读写字节块的能力。下面是I/O设备的类图：

![](G:\images\qt5-io-device-600x410.png)

途中所涉及的类及其用途简要说明如下：

- QIODevice：所有 I/O 设备类的父类，提供了字节块读写的通用操作以及基本接口；
- QFlie：访问本地文件或者嵌入资源；
- QTemporaryFile：创建和访问本地文件系统的临时文件；
- QBuffer：读写 QByteArray；
- QProcess：运行外部程序，处理进程间通讯；
- QAbstractSocket：所有套接字类的父类；
- QTcpSocket：TCP 协议网络数据传输；
- QUdpSocket：传输 UDP 报文；
- QSslSocket：使用 SSL/TLS 传输数据；

- QFileDevice：Qt5 新增加的类，提供了有关文件操作的通用实现。

这其中，QProcess、QTcpSocket、QUdpSoctet 和 QSslSocket 是顺序访问设备。所谓“顺序访问”，是指它们的数据只能访问一遍：从头走到尾，从第一个字节开始访问，直到最后一个字节，中途不能返回去读取上一个字节；QFile、QTemporaryFile 和 QBuffer 是随机访问设备，可以访问任意位置任意次数，还可以使用 QIODevice::seek() 函数来重新定位文件访问位置指针。

本章将主要介绍 QFile 及其相关类，后面的章节则开始介绍有关输入输出的流。

在所有的 I/O 设备中，文件 I/O 是最重要的部分之一。因为我们大多数的程序依旧需要首先访问本地文件（当然，在云计算大行其道的将来，这一观点可能改变）。QFile 提供了从文件中读取和写入数据的能力。Qt5 新加入的 QFileDevice 类，则将这部分公共操作放到了这个单独的类中。显然，这部分代码在 Qt4 中位于 QFile 类。这样看来，Qt5 的代码结构更为清晰，层次更好。

我们通常会将文件路径作为参数传给 QFile 的构造函数。不过也可以在创建好对象之后，使用 setFileName() 来修改。QFile 需要使用 / 作为文件分隔符，不过，它会自动将其转换成操作系统所需要的形式。例如 C:/windows 这样的路径在 Windows 平台下同样是可以的。

QFile 主要提供了有关文件的各种操作，比如打开文件、关闭文件、刷新文件等。我们可以使用 QDataStream 或 QTextStream 类来读写文件，也可以使用 QIODevice 类提供的 read()、readLine()、readAll() 以及 write() 这样的函数。值得注意的是，有关文件本身的信息，比如文件名、文件所在目录的名字等，则是通过 QFileInfo 获取，而不是自己分析文件路径字符串。

下面我们使用一段代码来看看 QFile 的有关操作：

```C++
int main(int argc, char *argv[])
{
	QApplicatin app(argc, argv);
	
	QFile file("in.txt");
	if(!file.open(QIODevice::ReadOnly|QIODevice::Text))
	{
		qDebug() << "Open file failed";
		return -1;
	}
	else
	{
		while(!file.atEnd())
		{
			qDebug() << file.readLine();
		}
	}
	
	QFileInfo info(file);
	qDebug() << info.isDir();
	qDebug() << info.isExecutable();
	qDebug() << info.baseName();
	qDebug() << info.completeBaseName();
	qDebug() << info.suffix();
	qDebug() << info.completeSuffix();
	
	return app.exec();
}
```

在这段代码中，我们首先使用 QFile 创建了一个文件对象。这个文件名字是 in.txt。如果你不知道应该把它放在哪里，<del>可以使用 app.applicationFilePath(); 或者 app.applicationDirPath(); 来获得应用程序的执行路径。只要将这个文件放在同执行路径一致的目录下即可。</del>可以使用 QDir::currentPath() 来获得应用程序执行时的当前路径。只要将这个文件放在与当前路径一致的目录下即可。然后，我们使用 open() 函数打开这个文件，打开形式是只读方式，文本格式。这个类似于 fopen() 的 r 这样的参数。open() 函数返回一个 bool 类型，如果打开失败，我们在控制台输出一段提示然后程序退出。否则，我们利用 while 循环，将每一行读到的内容输出。

程序的第二部分，我们使用 QFileInfo 获取有关该文件的信息。QFileInfo 有很多类型的函数，我们只举出一些例子。比如这里，isDir() 检查该文件是否是目录；isExecutable() 检查该文件是否是可执行文件等。baseName() 可以直接获得文件名；suffix() 则直接获取文件后缀名。我们可以由下面的示例看到，baseName() 和 completeBaseName()，以及 suffix() 和 completeSuffix() 的区别：

```C++
QFileInfo fi("/tmp/archive.tar.gz");
QString base  = fi.baseName();  // base = "archive"
QString cbase = fi.completeBaseName();  // base = "archive.tar"
QString ext   = fi.suffix();  // ext = "gz"
QString ext   = fi.completeSuffix();  // ext = "tar.gz"
```

# 26 二进制文件读写

在上一章中，我们介绍了有关 QFile 和 QFileInfo 两个类的使用。我们提到，QIODevice 提供了 read()、readLine() 等基本的操作。同时，Qt 还提供了更高一级的操作：用于二进制的流 QDataStream 和用于文本流的 QTextStream。本节，我们将讲解有关 QDataStream 的使用以及一些技巧。下一章则是 QTextStream 的相关内容。

QDataStream提供了基于QIODevice的二进制数据的序列化。数据流是一种二进制流，这种流完全不依赖于底层操作系统、CPU或者字节顺序（大端或小端）。例如，在安装了Windows平台的PC上面写入的一个数据流，可以不经过任何处理，直接拿到运行了Solaris的SPARC机器上读取。由于数据流就是二进制流，因此我们也可以直接读写没有变化的二进制数据，例如图像、视频、音频等。

QDataStream既能够存取C++基本类型，如int、char、short等，也可以存取复杂的数据类型，例如自定义的类。实际上，QDataStream对于类的存储，是将复杂的类分割为很多基本单元实现的。

结合QIODevice，QDataStream可以很方便地对文件、网络套接字等进行读写操作。我们从代码开始看起：

```C++
QFile file("file.dat");
file.open(QIODevice::WriteOnly);
QDataStream out(&file);
out << QString("the answer is");
out << (qint32)42;
```

在这段代码中，我们首先打开一个名为file.dat的文件（注意，我们为简单起见，并没有检查文件打开是否成功，这在正式程序中是不允许的）。然后，我们将刚刚创建的file对象的指针传递给一个QDataStream实例out。类似于std::cout标准输出流，QDataStream也重载了<<输出重定向<<运算符。后面的代码就简单了：将“the answer is”和数字42输出到数据流。由于我们的out对象建立在file之上，因此相当于将数据写入file。

需要指出一点：最好使用Qt整型来进行读写，比如程序中的qint32。这保证了在任意平台和任意编译器都能够有相同的行为。

我们通过一个例子来看看Qt是如何存储数据的。例如char*字符串，在存储时，会首先存储该字符串包括0结束符的长度（32位整型），然后是字符串的内容以及结束符0。在读取时，先以32位整型读出这个长度，然后按照这个长度取出整个字符串的内容。

但是，如果你直接运行这段代码，你会得到一个空白的 file.dat，并没有写入任何数据。这是因为我们的 file 没有正常关闭。为性能起见，数据只有在文件关闭时才会真正写入。因此，我们必须在最后添加一行代码：

```
file.close(); // 如果不想关闭文件，可以使用 file.flush();
```

重新运行一下程序，你就得到宇宙终极问题的答案了。

我们已经获得宇宙终极问题的答案了，下面，我们要将这个答案读取出来：

```
QFile file("file.dat");
file.open(QIODevice::ReadOnly);
QDataStream in(&file);
QString str;
qint32 a;
in >> str >> a;
```

这段代码没什么好说的。唯一需要注意的是，你必须按照写入的顺序，将数据读取出来。也就是说，程序数据写入的顺序必须预先定义好。在这个例子中，我们首先写入字符串，然后写入数字，那么就首先读出来的就是字符串，然后才是数字。顺序颠倒的话，程序行为是不确定的，严重时会直接造成程序崩溃。

由于二进制流是纯粹的字节数据，带来的问题是，如果程序不同版本之间按照不同的方式读取（前面说过，Qt 保证读写内容的一致，但是并不能保证不同 Qt 版本之间的一致），数据就会出现错误。因此，我们必须提供一种机制来确保不同版本之间的一致性。通常，我们会使用如下的代码写入：

```C++
QFile file("file.dat")
file.open(QIODevice::WriteOnly);
QDataStream out(&file);

//写入魔术数字和版本
out << (quint32)0xA0B0C0D0;
out << (qint32)123;

out.setVersion(QDataStream::Qt_4_0);

//写入数据
out << lots_of_interesting_data;
```

这里，我们增加了两行代码：

```
out << (quint32)0xA0B0C0D0;
```

用于写入魔术数字。所谓魔术数字，是二进制输出中经常使用的一种技术。二进制格式是人不可读的，并且通常具有相同的后缀名（比如 dat 之类），因此我们没有办法区分两个二进制文件哪个是合法的。所以，我们定义的二进制格式通常具有一个魔术数字，用于标识文件的合法性。在本例中，我们在文件最开始写入 0xA0B0C0D0，在读取的时候首先检查这个数字是不是 0xA0B0C0D0。如果不是的话，说明这个文件不是可识别格式，因此根本不需要去继续读取。一般二进制文件都会有这么一个魔术数字，例如 Java 的 class 文件的魔术数字就是 0xCAFEBABE，使用二进制查看器就可以查看。魔术数字是一个 32 位的无符号整型，因此我们使用 quint32 来得到一个平台无关的 32 位无符号整型。

接下来一行，

```
out << (qint32)123;
```

是标识文件的版本。我们用魔术数字标识文件的类型，从而判断文件是不是合法的。但是，文件的不同版本之间也可能存在差异：我们可能在第一版保存整型，第二版可能保存字符串。为了标识不同的版本，我们只能将版本写入文件。比如，现在我们的版本是 123。

下面一行还是有关版本的：

```
out.setVersion(QDataStream::Qt_4_0);
```

上面一句是文件的版本号，但是，Qt 不同版本之间的读取方式可能也不一样。这样，我们就得指定 Qt 按照哪个版本去读。这里，我们指定以 Qt 4.0 格式去读取内容。

当我们这样写入文件之后，我们在读取的时候就需要增加一系列的判断：

```C++
QFile file("file.dat");
file.open(QIODevice::ReadOnly);
QDataStream in(&file);

// 检查魔术数字
quint32 magic;
in >> magic;
if (magic != 0xA0B0C0D0) {
    return BAD_FILE_FORMAT;
}

// 检查版本
qint32 version;
in >> version;
if (version < 100) {
    return BAD_FILE_TOO_OLD;
}
if (version > 123) {
    return BAD_FILE_TOO_NEW;
}

if (version <= 110) {
    in.setVersion(QDataStream::Qt_3_2);
} else {
    in.setVersion(QDataStream::Qt_4_0);
}
// 读取数据
in >> lots_of_interesting_data;
if (version >= 120) {
    in >> data_new_in_version_1_2;
}
in >> other_interesting_data;
```

这段代码就是按照前面的解释进行的。首先读取魔术数字，检查文件是否合法。如果合法，读取文件版本：小于 100 或者大于 123 都是不支持的。如果在支持的版本范围内（100 <= version <= 123），则当是小于等于 110 的时候，按照 Qt_3_2 的格式读取，否则按照 Qt_4_0 的格式读取。当设置完这些参数之后，开始读取数据。

至此，我们介绍了有关 QDataStream 的相关内容。那么，既然 QIODevice 提供了 read()、readLine() 之类的函数，为什么还要有 QDataStream 呢？QDataStream 同 QIODevice 有什么区别？区别在于，有些 QIODevice 支持随机读写，而 QDataStream 提供的是流的形式，不允许随机读写。我们通过下面一段代码看看什么是流的形式：

```C++
QFile file("file.dat");
file.open(QIODevice::ReadWrite);

QDataStream stream(&file);
QString str = "the answer is 42";
QString strout;

stream << str;
file.flush();
stream >> strout;
```

这段代码中，我们首先向文件中写入数据，紧接着把数据读出来。有什么问题吗？运行之后你会发现，strout 实际是空的。为什么没有读取出来？我们不是已经添加了 file.flush(); 语句吗？原因并不在于文件有没有写入，而是在于我们使用的是“流”。所谓流，就像水流一样，它的游标会随着输出向后移动。当使用 << 操作符输出之后，流的游标已经到了最后，此时你再去读，当然什么也读不到了。所以你需要在输出之后重新把游标设置为 0 的位置才能够继续读取。具体代码片段如下：

```C++
stream << str;
stream.device()->seek(0);
stream >> strout;
```

# 27 文本文件读写

上一章我们介绍了有关二进制文件的读写。二进制文件比较小巧，却不是人可读的格式。而文本文件是一种人可读的文件。为了操作这种文件，我们需要使用 QTextStream 类。QTextStream 和 QDataStream 的使用类似，只不过它是操作纯文本文件的。另外，像 XML、HTML 这种，虽然也是文本文件，可以由 QTextStream 生成，但 Qt 提供了更方便的 XML 操作类，这里就不包括这部分内容了。

QTextStream 会自动将 Unicode 编码同操作系统的编码进行转换，这一操作对开发人员是透明的。它也会将换行符进行转换，同样不需要自己处理。QTextStream 使用 16 位的 QChar 作为基础的数据存储单位，同样，它也支持 C++ 标准类型，如 int 等。实际上，这是将这种标准类型与字符串进行了相互转换。

QTextStream 同 QDataStream 的使用基本一致，例如下面的代码将把“The answer is 42”写入到 file.txt 文件中：

```C++
QFile data("file.txt");
if (data.open(QFile::WriteOnly | QIODevice::Truncate)) {
    QTextStream out(&data);
    out << "The answer is " << 42;
}
```

这里，我们在 open() 函数中增加了 QIODevice::Truncate 打开方式。我们可以从下表中看到这些打开方式的区别：

| 枚举值                | 描述                                                         |
| :-------------------- | :----------------------------------------------------------- |
| QIODevice::NotOpen    | 未打开                                                       |
| QIODevice::ReadOnly   | 以只读方式打开                                               |
| QIODevice::WriteOnly  | 以只写方式打开                                               |
| QIODevice::ReadWrite  | 以读写方式打开                                               |
| QIODevice::Append     | 以追加的方式打开，新增加的内容将被追加到文件末尾             |
| QIODevice::Truncate   | 以重写的方式打开，在写入新的数据时会将游标设置在文件开头     |
| QIODevice::Text       | 在读取时，将行结束符转换成 n；在写入时，将行结束符转换成本地格式，例如 Win32 平台上是 rn |
| QIODevice::Unbuffered | 忽略缓存                                                     |

我们在这里使用了 QFile::WriteOnly | QIODevice::Truncate，也就是以只写并且覆盖已有内容的形式操作文件。注意，QIODevice::Truncate 并不是将文件内容清空，而是在文件开头处开始写入。要理解这一点，假设原文件内容是1111111111，我们想要写入222，如果设置为 QIODevice::Append，则处理结果将会是 1111111111222，这是很容易理解的；如果设置为 QIODevice::Truncate，那么文件内容将会是 2221111111。

虽然 QTextStream 的写入内容与 QDataStream 一样，但是读取时却会有些困难：

```
QFile data("file.txt");
if (data.open(QFile::ReadOnly)) {
    QTextStream in(&data);
    QString str;
    int ans = 0;
    in >> str >> ans;
}
```

在使用 QDataStream 的时候，这样的代码很方便，但是使用了 QTextStream 时却有所不同：读出的时候，str 里面将是 The answer is 42，ans 是 0。这是因为以文本形式写入数据，是没有数据之间的分隔的。还记得我们前面曾经说过，使用 QDataStream 写入的时候，实际上会在要写入的内容前面，额外添加一个这段内容的长度值。而文本文件则没有类似的操作。因此，使用文本文件时，很少会将其分割开来读取，而是使用诸如 QTextStream::readLine() 读取一行，使用 QTextStream::readAll() 读取所有文本这种函数，之后再对获得的 QString 对象进行处理。

默认情况下，QTextStream 的编码格式是 Unicode，如果我们需要使用另外的编码，可以使用

```C++
stream.setCodec("UTF-8");
```

这样的函数进行设置。

另外，为方便起见，QTextStream 同 std::cout 一样提供了很多描述符，被称为 stream manipulators。因为文本文件是供人去读的，自然需要良好的格式（相比而言，二进制文件就没有这些问题，只要数据准确就可以了）。这些描述符是一些函数的简写，我们可以从文档中找到：

| 描述符          | 等价于                                           |
| :-------------- | :----------------------------------------------- |
| bin             | setIntegerBase(2)                                |
| oct             | setIntegerBase(8)                                |
| dec             | setIntegerBase(10)                               |
| hex             | setIntegerBase(16)                               |
| showbase        | setNumberFlags(numberFlags() \| ShowBase)        |
| forcesign       | setNumberFlags(numberFlags() \| ForceSign)       |
| forcepoint      | setNumberFlags(numberFlags() \| ForcePoint)      |
| noshowbase      | setNumberFlags(numberFlags() & ~ShowBase)        |
| noforcesign     | setNumberFlags(numberFlags() & ~ForceSign)       |
| noforcepoint    | setNumberFlags(numberFlags() & ~ForcePoint)      |
| uppercasebase   | setNumberFlags(numberFlags() \| UppercaseBase)   |
| uppercasedigits | setNumberFlags(numberFlags() \| UppercaseDigits) |
| lowercasebase   | setNumberFlags(numberFlags() & ~UppercaseBase)   |
| lowercasedigits | setNumberFlags(numberFlags() & ~UppercaseDigits) |
| fixed           | setRealNumberNotation(FixedNotation)             |
| scientific      | setRealNumberNotation(ScientificNotation)        |
| left            | setFieldAlignment(AlignLeft)                     |
| right           | setFieldAlignment(AlignRight)                    |
| center          | setFieldAlignment(AlignCenter)                   |
| endl            | operator<<(‘n’) and flush()                      |
| flush           | flush()                                          |
| reset           | reset()                                          |
| ws              | skipWhiteSpace()                                 |
| bom             | setGenerateByteOrderMark(true)                   |

这些描述符只是一些函数的简写。例如，我们想要输出 12345678 的二进制形式，那么可以直接使用

```C++
out << bin << 12345678;
```

就可以了。这等价于

```C++
out.setIntegerBase(2);
out << 12345678;
```

更复杂的，如果我们想要舒服 1234567890 的带有前缀、全部字母大写的十六进制格式（0xBC614E），那么只要使用

```C++
out << showbase << uppercasedigits << hex << 12345678;
```

即可。

不仅是 QIODevice，QTextStream 也可以直接把内容输出到 QString。例如

```c++
QString str;
QTextStream(&str) << oct << 31 << " " << dec << 25 << endl;
```

这提供了一种简单的处理字符串内容的方法。

# 28 存储容器

存储容器（containers）有时候也被称为（collections），是能够在内存中存储其它待定类型的对象，通常是一些常用的数据结构，一般是通用模板类的形式。C++提供了一套完整的解决方案，作为标准模板库（Standard Template Library）,也就是常说的STL。

Qt提供了另外一套基于模板的容器类。相比STL，这些容器类通常更轻量、更安全、更容易使用。如果你对STL不太熟悉，或者更喜欢Qt风格的API，那么你就应该选择使用这些类。当然，你也可以在Qt中使用STL容器，没有任何问题。

本章的目的，是让你能够选择使用哪个容器，而不是告诉你这个类都哪些函数。这个问题可以在文档中找到更清晰的回答。
