x86：Intel公司86系列处理器的统称

IA-32，x86-32：英特尔32位架构

# 1 寄存器的扩展和扩充

![image-20220719143618685](G:\images\Linux\image-20220719143618685.png)

![image-20220719143921852](G:\images\Linux\image-20220719143921852.png)

# 2 32位处理器的内存访问

## 2.1 实模式下的内存访问

在实模式下，无论计算机有多少内存，和多少根地址线，最多只能使用10FFEF的单元的内存空间。因为在实模式下，使用的段寄存器和IP寄存器都是16位的。寻址范围有限。

![image-20220719144738808](G:\images\Linux\image-20220719144738808.png)

## 2.2 保护模式下的内存访问

![image-20220719145314110](G:\images\Linux\image-20220719145314110.png)

## 2.3 寻址方式

### 2.3.1   16位处理器的内存寻址方式

![image-20220719150516918](G:\images\Linux\image-20220719150516918.png)

### 2.3.2 32位处理器特有的内存寻址方式

主要用于保护模式下，在实模式下也可以使用。

![image-20220719150904294](G:\images\Linux\image-20220719150904294.png)

```assembly
add eax, [0x2008]
sub eax, [eax+0x08]
mov ecx, [eax+ebx*8+0x02]
mov ax, [sp]		;非法的指令，使用了16位的栈指针寄存器
mov eax, [esp]
```

【例】

```assembly
mov ax, 0xb000
mov ds, ax

mov eax, 0x8000

mov byte [eax+0x00], ':'
mov byte [eax+0x01], 0x07
mov byte [eax+0x02], 'o'
mov byte [eax+0x03], 0x07

jmp $
	times 510-($-$$) db 0
	db 0x55,0xaa
```

# 3流水线技术

![image-20220719152642829](G:\images\Linux\image-20220719152642829.png)

![image-20220719153000373](G:\images\Linux\image-20220719153000373.png)

# 4 进入保护模式

代码段的特权级别分为4个级别。

![image-20220720091806247](G:\images\Linux\image-20220720091806247.png)

## 4.1 全局描述符表GDT和全局描述符表寄存器GDTR（48位）

为了让程序在内存中能自由浮动而又不影响它的正常执行，处理器将内存划分成逻辑上的段，并在指令中使用段内偏移地址。在保护模式下，对内存的访问仍然使用段地址和偏移地址，但是，在每个段能够访问之前，必须先登记。

这种情况好比是开公司做生意，在实模式下，开公司不需要登记，卖什么都没有人管，随时都可以开张，但在保护模式下就不行了。

开公司之前必须先登记，登记的信息包括住址和经营项目等。每当你做的买卖和你的注册项目不符时，就会被阻止。同样，必须登记每个段的起始地址、段界限等各种访问属性。这样，当你访问的偏移地址超出段的界限时，处理器就会阻止这种访问，并产生一个叫内部异常的中断。

全局描述符表由操作系统在进入保护模式之前在内存中定义。每个段的描述符占8个字节。

![image-20220720093103583](G:\images\Linux\image-20220720093103583.png)

全局描述符表寄存器高32位是全局描述符表的线性基地址，低16位是全局描述符表边界，即相对于起始地址的偏移量。由于偏移量是16位的，这意味着，全局描述符表最大占64KB，每个段描述符占8个字节，则最多可有8192个段。由于在实模式下，只能访问到前1M左右的内存，故GDT被存放在内存的低地址段。

![image-20220720093859107](G:\images\Linux\image-20220720093859107.png)

### 4.1.1 描述符的作用及分类

![image-20220720100809931](G:\images\Linux\image-20220720100809931.png)

描述符分为存储器的段描述符和系统描述符，其中系统描述符又分为系统的段描述符和门描述符。

![image-20220720101211826](G:\images\Linux\image-20220720101211826.png)

## 4.2 在主引导扇区写入创建全局描述符表和进入保护模式的程序

![image-20220720095745866](G:\images\Linux\image-20220720095745866.png)

![image-20220720100425792](G:\images\Linux\image-20220720100425792.png)

# 5 存储器的段描述符

## 5.1 type字段

![image-20220720101549406](G:\images\Linux\image-20220720101549406.png)

* **type字段的X位（executable）用来描述该段是否可以可被执行，X=0表示不可被执行，表明该段为数据段。其后两位为E和W。**

  * **E位（Expand）表明扩展方向，E=0表示段是向上扩展的，即当我们向段内写数据或者读数据时，是从低地址方向连续的向高地址方向进行的。E=1时，通常表明该段为栈段。**

  * **W位（writtable），表示是否可写，W=0，表示段是不允许写入的，只允许读取。W=1表示可以被正常写入。**

  ![image-20220720102627171](G:\images\Linux\image-20220720102627171.png)

* **当X位等于1时，表明其可以被执行，是代码段。其后两位为C和R。**
  * **C位（Confirming）表示段是否为特权依重的。C=0表示非依重的代码段，表示只有特权级相同的程序才可以直接转移到这个段内执行。C=1表示依从的代码段表示特权级低的程序可以直接转移到这个段内执行。这一位通常为0.**
  * **R位指示代码段是否允许读出，R=0表示代码段不可被读出，R=1表示可以被读出。**
* **代码段和数据段的最后一位是A位（Access），用于指示它所指向的段最近是否被访问过。在描述符创建时该位清零，每当该段被访问时就被置1，该位的清零是由软件（操作系统）负责的，通过定期监视该位的状态，就可以统计出该段的使用频率。当内存空间紧张时，可以把不经常使用的段退避到硬盘上，从而实现虚拟内存管理。**

![image-20220720105707103](G:\images\Linux\image-20220720105707103.png)

## 5.2 段界限及访问控制位

![image-20220720110111686](G:\images\Linux\image-20220720110111686.png)

![image-20220720110400925](G:\images\Linux\image-20220720110400925.png)

![image-20220720110539887](G:\images\Linux\image-20220720110539887.png)

![image-20220720110715733](G:\images\Linux\image-20220720110715733.png)

# 6 安装存储器的段描述符

![image-20220721103206985](G:\images\Linux\image-20220721103206985.png)

![image-20220721103436388](G:\images\Linux\image-20220721103436388.png)

![image-20220721103628570](G:\images\Linux\image-20220721103628570.png)

## 6.1 加载全局描述符表寄存器（lgdt指令）

![image-20220721103940107](G:\images\Linux\image-20220721103940107.png)

![image-20220721104738586](G:\images\Linux\image-20220721104738586.png)

```assembly
lgdt m48		;取指定内存地址的6个字节来初始化gdtr

lgdt [cs: gdt_size+0x7c00]
```

## 6.2 打开第21根地址线A20

早期的8086只有20根地址线，只能访问1M的地址空间。CPU寻址则按段+偏移的方式进行。16位段+16位偏移的可能的范围是0~0x10FFEF（即0xFFFF0+0xFFFF），即1M+65520字节的范围。由于只有20根地址线，所以在对1M~1M+65520范围进行访问时，会发生“地址回绕”的现象，就是说实际会访问到0~65520的地方。据说某个著名的/臭名昭著的软件利用了这个特点。在80286，386等CPU上，它会失败，因为这些CPU有多于20根的地址线，并不产生“地址回绕”现象。为了保持完全的兼容性，IBM决定在PC AT系统上加个逻辑，来模仿以上的回绕特征。他们的方法就是把A20和键盘控制器的一个输出进行AND，这样来控制A20的打开和关闭。一开始时A20是被屏蔽的（总为0），直到系统软件去打开它。

A20地址线问题（地址环绕）

1981年8月，IBM公司最初推出的个人计算机IBM PC使用的CPU是Intel 8088。在该微机中地址线
只有20根(A0 – A19)。在当时内存RAM只有几百KB或不到1MB时，20根地址线已足够用来寻址这些
内存。其所能寻址的最高地址是0xffff:0xffff，也即0x10ffef。对于超出0x100000(1MB)的寻址地址将默认
地环绕到0x0ffef。当IBM公司于1985年引入AT机时，使用的是Intel 80286 CPU，具有24根地址线，最
高可寻址16MB，并且有一个与8088完全兼容的实模式运行方式。然而，在寻址值超过1MB时它却不能
象8088那样实现地址寻址的环绕。但是当时已经有一些程序是利用这种地址环绕机制进行工作的。为了
实现完全的兼容性，IBM公司发明了使用一个开关来开启或禁止0x100000地址比特位。由于在当时的8042
键盘控制器上恰好有空闲的端口引脚（输出端口P2，引脚P21），于是便使用了该引脚来作为与门控制这
个地址比特位。该信号即被称为A20。如果它为零，**则比特20及以上地址都被清除**。从而实现了兼容性。
 由于在机器启动时，默认条件下，A20地址线是禁止的，所以操作系统必须使用适当的方法来开启它。
但是由于各种兼容机所使用的芯片集不同，要做到这一点却是非常的麻烦。因此通常要在几种控制方法中
选择。


 对A20信号线进行控制的常用方法是通过设置键盘控制器的端口值。 有些操作系统将A20的开启和禁止作

为实模式与保护运行模式之间进行转换的标准过程中的一部分。
由于键盘的控制器速度很慢，因此就不能使用键盘控制器对A20线来进行操作。为此引进了一个A20快
速门选项(Fast Gate A20)，它使用I/O端口0x92来处理A20信号线，避免了使用慢速的键盘控制器操作方
式。对于不含键盘控制器的系统就只能使用0x92端口来控制，但是该端口也有可能被其它兼容微机上的
设备（如显示芯片）所使用，从而造成系统错误的操作。
 还有一种方式是通过读0xee端口来开启A20信号线，写该端口则会禁止A20信号线。

![image-20220721111530342](G:\images\Linux\image-20220721111530342.png)

## 6.3 通过设置控制寄存器CR0的第0位PE(Protect Enable)进入保护模式

![image-20220721111931926](G:\images\Linux\image-20220721111931926.png)

## 6.4 描述符高速缓存器和保护模式下的内存访问

![image-20220721113129417](G:\images\Linux\image-20220721113129417.png)

![image-20220721150515860](G:\images\Linux\image-20220721150515860.png)

![image-20220721150705314](G:\images\Linux\image-20220721150705314.png)

![image-20220721150858669](G:\images\Linux\image-20220721150858669.png)

一旦将段选择子加载到段寄存器中，处理器内部自动到对应的段描述符处取得该段的线性基地址和其它属性放于对应的描述符高速缓存器中。

![image-20220721151409738](G:\images\Linux\image-20220721151409738.png)

![image-20220721151552669](G:\images\Linux\image-20220721151552669.png)

在实模式下，逻辑段基址会乘以16形成物理段地址存在对应的描述符高速缓存器中。

![image-20220721152413900](G:\images\Linux\image-20220721152413900.png)

```assembly
         ;代码清单11-1
         ;文件名：c11_mbr0.asm
         ;文件说明：硬盘主引导扇区代码
         ;创建日期：2020-6-7 15:00

         ;计算GDT所在的逻辑段地址
         mov ax,[cs:gdt_base+0x7c00]        ;低16位 
         mov dx,[cs:gdt_base+0x7c00+0x02]   ;高16位 
         mov bx,16							;计算段基地址        
         div bx            
         mov ds,ax                          ;令DS指向该段以进行操作
         mov bx,dx                          ;段内起始偏移地址 
      
         ;创建0#描述符，它是空描述符，这是处理器的要求
         mov dword [bx+0x00],0x00
         mov dword [bx+0x04],0x00  

         ;创建#1描述符，保护模式下的数据段描述符（文本模式下的显示缓冲区）
         mov dword [bx+0x08],0x8000ffff
         mov dword [bx+0x0c],0x0040920b

         ;初始化描述符表寄存器GDTR
         mov word [cs: gdt_size+0x7c00],15  ;描述符表的界限（总字节数减一）
                                             
         lgdt [cs: gdt_size+0x7c00]
      
         in al,0x92                         ;南桥芯片内的端口 
         or al,0000_0010B
         out 0x92,al                        ;打开A20

         cli                                ;保护模式下中断机制尚未建立，应 
                                            ;禁止中断 
         mov eax,cr0
         or eax,1
         mov cr0,eax                        ;设置PE位

         ;以下进入保护模式... ...

         mov cx,00000000000_01_000B         ;加载数据段选择子(0x01)
         mov ds,cx

         ;以下在屏幕上显示"Protect mode OK."
         mov byte [0x00],'P'
         mov byte [0x02],'r'
         mov byte [0x04],'o'
         mov byte [0x06],'t'
         mov byte [0x08],'e'
         mov byte [0x0a],'c'
         mov byte [0x0c],'t'
         mov byte [0x0e],' '
         mov byte [0x10],'m'
         mov byte [0x12],'o'
         mov byte [0x14],'d'
         mov byte [0x16],'e'
         mov byte [0x18],' '
         mov byte [0x1a],'O'
         mov byte [0x1c],'K'

         hlt                                ;已经禁止中断，将不会被唤醒 

;-------------------------------------------------------------------------------
     
         gdt_size         dw 0
         gdt_base         dd 0x00007e00     ;GDT的物理地址 
                             
         times 510-($-$$) db 0
                          db 0x55,0xaa
```

# 7  处理器的指令操作尺寸

**所谓指令的操作尺寸，是指指令中操作数的长度以及有效地址（偏移地址、偏移量）的长度。**

## 7.1 16位处理器的指令的操作尺寸

在16位处理器中，操作数的尺寸可以是8位的，也可以是16位的；**有效地址的尺寸始终是16位的。**

## 7.2 32位处理器的指令的操作尺寸

32处理器支持8/16/32位操作数，以及16/32位有效地址。

```assembly
mov al, cl
mov cx, ax
mov eax, edx
add al, [eax]
add edx, [bx]
mov si, [di]
mov ecx, [eax]

push dx			;sp - 2
push eax		;sp/esp - 4
```

```assembly
mov ax, 0x2000
mov ds, ax

mov eax, 0xffff		;段界限一般被预置为0xffff 64KB
mov dl, [eax]		;正常执行

mov edx, [eax]		;超出了段界限，产生异常

cli
hlt

times 510-($-$$) db 0
db 0x55, 0xaa
```

![image-20220723111856419](G:\images\Linux\image-20220723111856419.png)

# 8 x86指令格式-操作码和立即数

操作码：1到3个字节

```assembly
hlt		;F4
cli		;FA
std		;FD
ret		;C3
int3	;CC
```

立即数：1/2/4个字节

```assembly
mov al, 3		;B003
mov cx, 3		;B90300
mov edx, 3		;BA3000000
```

#  9 进入保护模式后切换到32位模式并使用32位默认操作尺寸

![image-20220725105700161](G:\images\Linux\image-20220725105700161.png)

```assembly
         ;代码清单11-1
         ;文件名：c11_mbr2.asm
         ;文件说明：硬盘主引导扇区代码
         ;创建日期：2020-6-22 18:00

         ;计算GDT所在的逻辑段地址
         mov ax,[cs:gdt_base+0x7c00]        ;低16位 
         mov dx,[cs:gdt_base+0x7c00+0x02]   ;高16位 
         mov bx,16        
         div bx            
         mov ds,ax                          ;令DS指向该段以进行操作
         mov bx,dx                          ;段内起始偏移地址 
      
         ;创建0#描述符，它是空描述符，这是处理器的要求
         mov dword [bx+0x00],0x00
         mov dword [bx+0x04],0x00  

         ;创建#1描述符，保护模式下的数据段描述符（文本模式下的显示缓冲区）
         mov dword [bx+0x08],0x8000ffff
         mov dword [bx+0x0c],0x0040920b
 
         ;创建#2描述符，保护模式下的代码段描述符
         mov dword [bx+0x10],0x7c0001ff
         mov dword [bx+0x14],0x00409800

         ;初始化描述符表寄存器GDTR
         mov word [cs: gdt_size+0x7c00],23  ;描述符表的界限（总字节数减一）
                                             
         lgdt [cs: gdt_size+0x7c00]
      
         in al,0x92                         ;南桥芯片内的端口 
         or al,0000_0010B
         out 0x92,al                        ;打开A20

         cli                                ;保护模式下中断机制尚未建立，应 
                                            ;禁止中断 
         mov eax,cr0
         or eax,1
         mov cr0,eax                        ;设置PE位

         ;以下进入保护模式... ...
         jmp 0000000000010_0_00B:flush

         bits 32

flush:
         mov cx,0000000000001_0_00B         ;加载数据段选择子(0x01)
         mov ds,cx

         ;以下在屏幕上显示"Protect mode OK."
         mov byte [0x00],'P'
         mov byte [0x02],'r'
         mov byte [0x04],'o'
         mov byte [0x06],'t'
         mov byte [0x08],'e'
         mov byte [0x0a],'c'
         mov byte [0x0c],'t'
         mov byte [0x0e],' '
         mov byte [0x10],'m'
         mov byte [0x12],'o'
         mov byte [0x14],'d'
         mov byte [0x16],'e'
         mov byte [0x18],' '
         mov byte [0x1a],'O'
         mov byte [0x1c],'K'

         hlt                                ;已经禁止中断，将不会被唤醒 

;-------------------------------------------------------------------------------
     
         gdt_size         dw 0
         gdt_base         dd 0x00007e00     ;GDT的物理地址 
                             
         times 510-($-$$) db 0
                          db 0x55,0xaa
```

# 10 条件传送指令（cmovcc）

它的目的操作数只允许是16位或者32位通用寄存器，源操作数只能是相同宽度的通用寄存器和内存单元。**p233**

```assembly
cmovz ax, cx	;为零则传送
cmovvnz eax, [0x2000]	;不为零则传送
cmove ebx, ecx	;相等则传送
cmovng cx, [0x1000]	;不大于则传送
```

# 11 带零扩展传送指令（movzx，Move with Zero-Extend）和带符号扩展传送指令（movsx，Move with Sign-Extension）

**p235**

# 12 查表指令xlat

**p244**

# 13 位串检测指令bts、btr、btc、bt

**p322**

