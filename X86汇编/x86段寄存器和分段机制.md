# x86段寄存器和分段机制

![](G:\images\Linux\duan.png)

## 1 前言

我们在编程的时候，多多少少都听过下面几个名词：逻辑地址、线性地址、物理地址和虚拟地址。先想几个问题：CPU直接使用的是什么地址？进程使用的是什么地址？在gdb调试时，打印的局部变量的地址，是哪种地址？

其实，逻辑地址可以认为是cpu执行程序过程中的一种中间地址，机器语言指令中出现的内存地址，都是逻辑地址；线性地址是进程使用的地址，是统一编址后的地址；物理地址就是和地址总线链接的RAM易失性存储单元。

为了更深入得了解逻辑地址和x86CPU寻址原理，下面从历史发展角度，依次来了解下x86上的段寄存器和分段机制。

## 2 x86段寄存器

### 2.1 16位CPU

intel 处理器从4位机到最新的64位，历时发展数十年，从8086开始，Intel CPU正式进入x86时代，而段寄存器也是这个时候诞生。

8086处理器位数变成16位，但是地址总线又变成了20根。为了能够访问到整个地址空间，在CPU里添加了4个段寄存器，分别为CS（代码段寄存器）DS（数据段寄存器） SS（堆栈段寄存器）ES(扩展段寄存器)。所以段寄存器就是为了解决CPU位数和地址总线不同的问题而诞生的。

那么如何用16位CPU访问20根地址线呢？x86将物理内存划分很多段（所有的操作都是在真实的物理内存上，当时没有操作系统这么一说，这样就是所谓的实模式），段基地址采用两字节对齐(16的倍数)，即16位的段寄存器只需要记录地址的高16位，ip寄存器记录段内偏移量。因此，进程要访问的线性地址 = （段寄存器 << 4） + （ip寄存器(偏移量））：

![](G:\images\Linux\v2-f6cec4b6d81e69bf41e7a146e00ac235_720w.jpg)

### 2.2 32位CPU

到了我们处理器80386时候（保护模式），这时候cpu是32位，地址总线变成了32根，除了先前的4个段寄存器，还引入了两个新的段寄存器FS、GS（附加数据段寄存器）。但是它的寄存器大小为了兼容之前体系下的版本，寄存器依旧是16比特位宽，这么说寻址能力又不能满足了。这个时候增加了两个寄存器，GDTR（全局的段的描述附表），LDTR（局部的描述附表），新增的寄存器可以不和上个版本兼容不是16位，是32位。

![](G:\images\Linux\v2-3fafbf895caa4c1e307a2013957bd736_720w.jpg)

在x86保护模式下，段的信息（段基线性地址、长度、权限等）即**段描述符**占8个字节，段信息无法直接存放在段寄存器中（段寄存器只有2字节）。Intel的设计是段描述符集中存放在GDT(Global Descriptor Table)或LDT(Local Descriptor Table)中，分别保存在新增的寄存器GDTR和LDTR中。而**段寄存器**CS DS SS ES**存放的是段描述符在GDT或LDT内的索引值**(index)。

CPU通过段寄存器找到GDT中的段描述符，计算出段基地址，加上ip寄存器里的逻辑地址，就得到线性地址：

```tex
线性地址 = [ 段描述符 ]+段内偏移量
```

下面还是通过一个简单的小程序去分析IA32 CPU寻址原理：

C源码：

```C
#include <stdio.h>

int main()
{
        printf("hello world! \n");
        return 0;
}
```

gcc test.c -m32 -g -o test

反汇编截取.text段部分汇编：

```assembly
Disassembly of section .text:

 08048370 <_start>:
 8048370:	f3 0f 1e fb          	endbr32 
        … …
 8048397:	50                   	push   %eax
 8048398:	51                   	push   %ecx
 8048399:	56                   	push   %esi
 804839a:	c7 c0 ad 84     	mov   $0x80484ad,%eax
 80483a0:	50                   	push   %eax
 80483a1:	e8 ba ff ff ff       	call   8048360 <__libc_start_main@plt>
    … …
 080484ad <main>:
 80484ad:	8d 4c 24 04          	lea    0x4(%esp),%ecx
 80484b1:	83 e4 f0             	and    $0xfffffff0,%esp
 80484b4:	ff 71 fc             	pushl  -0x4(%ecx)
```

代码段中汇编语句“mov $0x80484ad,%eax”访问了一个内存地址，通过下面的汇编地址发现他就是main函数入口地址。这里的内存地址0x80484ad 就是一个逻辑地址，必须加上隐含的CS 代码段的基地址，才能构成线性地址。也就是说 0x80484ad 是当前任务的CS代码段内的偏移。

因为0x80484ad是main函数入口地址，我们在main函数入口打断点，打印出段寄存器的值：

![](G:\images\Linux\v2-d292f963e8a42a24c7bfa8a87ecbfe76_720w.jpg)

分析：

> 从gdb中可以看到，cs寄存器值是0x23，二进制是0 0000 0010 0011 ，index字段是4，对应GDT表中的第四项 __USER_CODE；TI字段值为0,表示使用GDT，1表示LDT（linux只用了GDT）；RPL用于表示当前CPU的特权级(CPL)，CPL为0是最高权限(内核态使用)，CPL为3是用户态使用。

段描述符字段意义：

| 字段        | 意义                                                   |
| ----------- | ------------------------------------------------------ |
| BASE(32位)  | 段首地址的线性地址                                     |
| G           | 为0代表此段长度以字节为单位，为1代表此段长度以4K为单位 |
| LIMIT(20位) | 段限制长度                                             |
| S           | 为0表示是系统段，否则为代码段或数据段                  |
| Type        | 描述段的类型和存取权限                                 |
| DPL         | 描述符特权级，访问这个段CPU要求的最小优先级            |
| P           | 表示此段是否被交换到磁盘，总是置为1                    |
| D或B        | 如果段的LIMIT是32位长，则置1，如果是16位长，置0        |

注意，图中最后算出线性地址和；逻辑地址相同，是因为linux系统把所有段基地址（图中段描述符base）全部是零，即所有段都从0x00000000开始，屏蔽了分段机制，因此**在linux中逻辑地址等于线性地址**！

### 2.3 64位CPU

在64位模式下：处理器把CS/DS/ES/SS的段基都当作0，忽略与之关联的段描述符中的段基地址。因为在64位模式中，CPU可以访问所有可寻址的内存空间。今天大多数的64位CPU只需要访问40位到48位的物理内存，因此不再需要段寄存器去扩展。

## CPU寻址和地址转换

通过上面的分析，我们清晰得认识到了线性地址、逻辑地址的概念。那么在CPU寻址的最后一关，如何转换成物理地址的呢？下面还是分开解析。

【1】首先在16位或者更早的Intel CPU上，CPU工作在实模式，即直接使用物理地址，没有OS虚拟地址的概念。因此，在这些平台上，进行访问的线性地址 = 物理地址：

![](G:\images\Linux\v2-579718b4f504316a56d3e8695f1a161d_720w.jpg)

【2】在IA32上，x86工作在保护模式下时，分段单元将逻辑地址转换成线性地址，分页单元（MMU开启情况下）将线性地址转换成物理地址。当CPU启用了MMU，CPU核发出的地址将被MMU截获，从CPU到MMU的地址称为虚拟地址（Virtual Address，以下简称VA），而MMU将这个地址翻译成另一个地址发到CPU芯片的外部地址引脚上，也就是将虚拟地址映射成物理地址：

![](G:\images\Linux\v2-f5bd16f2f8dff63aabb873374f5517bd_720w.jpg)

【3】在x86_64上，处理器把CS/DS/ES/SS的段基都当作0，实际上摒弃了段式管理，不再使用。指令中使用的地址就是线性地址，当CPU开启MMU时，通过页式管理单元翻译成物理地址：

![](G:\images\Linux\v2-e12e6284571311db6e87857455f7fcf3_720w.jpg)

有一点需要注意，linux系统通过将段起始地址置零，无论是32位系统还是64位系统，都在实际上屏蔽了x86的段式内存管理，所以 **在Linux中逻辑地址与线性地址总是一致**。

总结：分段可以给每一个进程分配不同的线性地址空间；分页可以把同一线性地址空间映射到不同的物理空间，所以每个进程使用相同的段寄存器值。linux的分页机制不在本文讨论范围内，不再详细介绍。