# 1 什么是汇编语言

* 汇编语言其实应该叫机器指令符号化语言
* 学习计算机原理、操作系统、优化高级语言的必修课
* 学习嵌入式开发、加密和解密、破解、逆向的伴侣

## 1.1 8086处理器

内存共有1MB，2^20字节，而处理器的寄存器是16位的，无法寻址，故采用分段的机制来进行寻址。

物理地址 = 段基址 * 10（左移四位）+ 偏移地址

由于存放偏移地址的寄存器是16位的，所以每个段的最大空间为2^16B = 64KB

8086是低端字节序的，即低字节在低地址，高字节在高地址

**汇编地址是指该指令相对程序开头的偏移量**

**主引导扇区：**位于硬盘的0柱面0磁面（磁头）0扇面，512字节，标志是第511和512字节处存放0x55和0xaa，在计算机启动之后，先是执行rom中的bios启动初始化程序，然后跳转至主引导扇区执行，一般来说，主引导扇区的主要任务是作为跳板，加载和引导操作系统。

# 2 nasm

编译汇编文件命令：

nasm exam.asm -f bin -o exam.bin	编译

nasm exam.asm -l exam.lst	生成列表文件

type exam.lst	打开并显示列表文件

C:\NASM

 ```tex
   1，启动NotePad++，在菜单上选择“运行(R)”->“运行(R)”。
  2，在弹出的窗口内，输入：cmd /k pushd "$(CURRENT_DIRECTORY)" & C:\NASM\nasm.exe -f bin  "$(FULL_CURRENT_PATH)" -o "$(NAME_PART).bin" -l "$(NAME_PART).lst"& PAUSE & EXIT。其中，“D:\ACERFILES\OLDE\PROGFILES\NASM\”应该改成你自己机器上实际的NASM安装路径。
 3，点击“保存”，然后为这个运行命令起一个名字并分配一个快捷键，这样你下次就可以直接快速执行编译过程。
 ```



# 3 bochs虚拟机

* r：查看通用寄存器内容
* sreg：查看段寄存器内容
* s（step）：单步执行下一条指令
* n：大部分作用同上，一些情况下有特殊作用
* b(break) 内存地址：表示执行到该地址的指令时停下来，如b 7c00(boch定义的主引导扇区程序加载的位置)
* c（continue）：执行指令直至下一个断点
* q（quit）：退出虚拟机
* xp /512xb 0x7c00：以十六进制单字节地显示内存地址0x7c00处的数据
* xp /512xh ds:0：以十六进制双字节地显示内存地址ds：0处的512个数据
* u：反汇编下一条指令
* u /16： 反汇编16条指令
* help：查看调试命令
* help p：查看p命令的作用
* info eflags：查看flags寄存器内容，各个位置大写表示为1，小写表示为0
* 数字+0x30：数字转对应的数字字符
* print-stack：查看栈数据信息
* creg：查看控制寄存器
* info gdt：查看全局段描述符的内容

# 4 exma.asm

```assembly
mov ax, 0x30   ;将立即数传送到AX寄存器
mov dx, 0xc0
add ax, dx

times 502 db 0 ;填充0 502次

db 0x55		;主引导扇区有效程序标志
db 0xAA		;主引导扇区有效程序标志
```

![](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.icode9.com%2Fi%2Fl%2F%3Fn%3D20%26i%3Dblog%2F1822196%2F202103%2F1822196-20210305004915336-688944253.gif&refer=http%3A%2F%2Fwww.icode9.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1658678774&t=eb9582056a2247a81d60e6117345add3)

显存文本模式映射内存起始地址为0xb8000

mov [0x00], al  ；按字节操作

mov ax，[0x02]	;按字操作

# 5 mov指令

```assembly
;mov	目的操作数，源操作数
	;寄存器/内存地址	寄存器/内存地址/立即数

mov byte [0x02], 0xe9	;当目的操作数和源操作数都不能确定位数时，需要指明移动位数
mov word [0x06], 0x3c

mov [0x01], [0x02]	;×，不允许目的操作数和源操作数同时为地址
;可被分解为：
mov ax, [0x02]
mov [0x01], ax

mov ip, 0xf000	;×，ip寄存器不能被直接访问，不能出现在任何指令中

mov ds, ax
mov es, [0x3002]	;当目的为寄存器时，源操作数不能是立即数，可以为内存地址或通用寄存器

mov	ah,	bh	;√
mov	ax,	dx	;√

mov ax,	bl	;×,位数不匹配

mov	al,	[0xf000]
mov bx, [0x08]

mov	al, 0x07
mov	bx,	0x08

```

# 6 exam2.asm

添加标号，代表最近指令的地址

```assembly
start:
		mov ax, 0xb800		;段地址B800
		mov ds, ax

		mov byte [0x00], 0x41		;字符A的ASCII的编码
		mov byte [0x01], 0x04		;黑底红字，无闪烁

		mov byte [0x02], 's'		;等同于 mov byte [0x02], 0x73
		mov byte [0x03], 0x04

		mov byte [0x04], 's'
		mov byte [0x05], 0x04

		mov byte [0x06], 'e'
		mov byte [0x07], 0x04

		mov byte [0x08], 'm'
		mov byte [0x09], 0x04

		mov byte [0x0a], 'b'
		mov byte [0x0b], 0x04

		mov byte [0x0c], 'l'
		mov byte [0x0d], 0x04

		mov byte [0x0e], 'y'
		mov byte [0x0f], 0x04
	
		mov byte [0x10], '.'
		mov byte [0x11], 0x04
		
		jmp 0x0000:0x7c00		;段间直接绝对跳转指令

current:
		times 510-(current-start) db 0
		
		db 0x55, 0xaa
```

```assembly
start:
		mov ax, 0xb800		;段地址B800
		mov ds, ax

		mov byte [0x00], 0x41		;字符A的ASCII的编码
		mov byte [0x01], 0x04		;黑底红字，无闪烁

		mov byte [0x02], 's'		;等同于 mov byte [0x02], 0x73
		mov byte [0x03], 0x04

		mov byte [0x04], 's'
		mov byte [0x05], 0x04

		mov byte [0x06], 'e'
		mov byte [0x07], 0x04

		mov byte [0x08], 'm'
		mov byte [0x09], 0x04

		mov byte [0x0a], 'b'
		mov byte [0x0b], 0x04

		mov byte [0x0c], 'l'
		mov byte [0x0d], 0x04

		mov byte [0x0e], 'y'
		mov byte [0x0f], 0x04
	
		mov byte [0x10], '.'
		mov byte [0x11], 0x04
again:		
		jmp 0x0000:0x7c00+again

current:
		times 510-(current-start) db 0
		
		db 0x55, 0xaa

```

```assembly
start:
		mov ax, 0xb800		;段地址B800
		mov ds, ax

		mov byte [0x00], 0x41		;字符A的ASCII的编码
		mov byte [0x01], 0x04		;黑底红字，无闪烁

		mov byte [0x02], 's'		;等同于 mov byte [0x02], 0x73
		mov byte [0x03], 0x04

		mov byte [0x04], 's'
		mov byte [0x05], 0x04

		mov byte [0x06], 'e'
		mov byte [0x07], 0x04

		mov byte [0x08], 'm'
		mov byte [0x09], 0x04

		mov byte [0x0a], 'b'
		mov byte [0x0b], 0x04

		mov byte [0x0c], 'l'
		mov byte [0x0d], 0x04

		mov byte [0x0e], 'y'
		mov byte [0x0f], 0x04
	
		mov byte [0x10], '.'
		mov byte [0x11], 0x04
		
		mov bx, 0x7c00+again		;把段内偏移地址放入bx寄存器
again:		
		jmp bx				;使用寄存器的绝对间接接近（段内）跳转，不改变段寄存器cs中的内容

current:
		times 510-(current-start) db 0
		
		db 0x55, 0xaa

```

## 6.1 使用相对偏移量的短跳转和近跳转

jmp [short] 偏移量或标号			;EB 8位偏移量（-127-128）short可选，编译器可根据偏移量大小自动确定，如果是标号，编译器会自动计算偏移量

jum [near] 偏移量		;E9 16位偏移量，near可选，编译器可自动判断

```assembly
start:
		mov ax, 0xb800		;段地址B800
		mov ds, ax

		mov byte [0x00], 0x41		;字符A的ASCII的编码
		mov byte [0x01], 0x04		;黑底红字，无闪烁

		mov byte [0x02], 's'		;等同于 mov byte [0x02], 0x73
		mov byte [0x03], 0x04

		mov byte [0x04], 's'
		mov byte [0x05], 0x04

		mov byte [0x06], 'e'
		mov byte [0x07], 0x04

		mov byte [0x08], 'm'
		mov byte [0x09], 0x04

		mov byte [0x0a], 'b'
		mov byte [0x0b], 0x04

		mov byte [0x0c], 'l'
		mov byte [0x0d], 0x04

		mov byte [0x0e], 'y'
		mov byte [0x0f], 0x04
	
		mov byte [0x10], '.'
		mov byte [0x11], 0x04
		
again:		
		jmp near start
current:
		times 510-(current-start) db 0
		
		db 0x55, 0xaa
```

# 7  无符号整数的除法指令：div 除数所在寄存器或者内存地址

## 7.1 16位div

> 如果在指令中指定的是8位寄存器或者8位操作数的内存地址，则意味着被除数在寄存器AX里。
>
> 相除后，商在寄存器AL里，余数在寄存器AH里
>
> div bh
>
> div byte [0x2002]		**结果为AL...........AH**

## 7.2  32位div



> 如果在指令中指定的是16位寄存器或者16位操作数的内存地址，则意味着被除数是32位的，低16位在寄存器AX里；高16位在寄存器DX里。
>
> 相除后，商在寄存器AX里，余数在寄存器DX里
>
> **被除数：DX AX**
>
> **结果：AX...........DX**
>
> div bx
>
> div word [0x2002]

## 7.3  64位div

> 如果在指令中指定的是32位寄存器或者32位操作数的内存地址，则意味着被除数是64位的，低32位在寄存器EAX里；高32位在寄存器EDX里。
>
> 相除后，商在寄存器EAX里，余数在寄存器EDX里
>
> **被除数：EAX EDX**
>
> **结果：EAX..........EDX**
>
> div ebx
>
> div dword [0x2002]

## 7.4  128位div

> 8086和32位处理器不支持，只有64位处理器支持
>
> 如果在指令中指定的是64位寄存器或者64位操作数的内存地址，则意味着被除数是128位的，低64位在寄存器RAX里；高32位在寄存器RDX里。
>
> 相除后，商在寄存器RAX里，余数在寄存器RDX里
>
> **被除数：RAX RDX**
>
> **结果：RAX........RDX**
>
> div rbx
>
> div qword [0x2002]

## 7.5 示例

```assembly
start:
;计算378除以37的结果
mov ax, 378
mov bl, 37		;AL=商（10），AH=余数（8）
div bl

current:
times 510 - (current-start) db 0
db 0x55, 0xaa
```

```assembly
start:
;计算65535除以10的结果
mov dx, 0
mov ax, 65535
mov bx, 10		;AL=商（6553），AH=余数（5）
div bx

current:
times 510 - (current-start) db 0
db 0x55, 0xaa
```

# 8 xor指令(异或指令)

xor	寄存器/内存地址,	寄存器/内存地址/立即数		;数据长度须得相同

```assembly
xor bh al
xor cx, dx
xor ax, 3
xor word [0x2002], 67
xor si, [0x2002]

xor dx, dx		;=====> mov dx, 0
```

# 9 add指令

add	寄存器/内存地址,	寄存器/内存地址/立即数		;数据长度须得相同

```assembly
add bh, al
add cx, dx
add ax, 3
add word [0x2002], 67
add si, [0x2002]
```

# 10 段超越前缀的使用

## 10.1 普通内存不同段数据交换

```assembly
start:
;计算65535除以10的结果
xor dx, dx
mov ax, 65535
mov bx, 10		;AL=商（6553），AH=余数（5）
div bx

add dl, 0x30		;将数字转换为对应的数字字符

mov cx, 0
mov ds, cx

mov [0x7c00+buffer], dl

xor dx, dx
div bx
add dl, 0x30
mov [0x7c00+buffer+1], dl

xor dx, dx
div bx
add dl, 0x30
mov [0x7c00+buffer+2], dl

xor dx, dx
div bx
add dl, 0x30
mov [0x7c00+buffer+3], dl

xor dx, dx
div bx
add dl, 0x30
mov [0x7c00+buffer+4], dl

mov al, [0x7c00+buffer+4]

mov cx, 0xb800
mov ds, cx

mov [0x00], al
mov byte [0x01], 0x2f

mov cx, 0
mov ds, cx

mov al, [0x7c00+buffer+3]

mov cx, 0xb800
mov ds, cx

mov [0x02], al
mov byte [0x03], 0x2f



buffer	db 0, 0, 0, 0, 0
current:
times 510 - (current-start) db 0
db 0x55, 0xaa
```

## 10.2使用段超越前缀交换段间数据

```assembly
start:
;计算65535除以10的结果
xor dx, dx
mov ax, 65535
mov bx, 10		;AL=商（6553），AH=余数（5）
div bx

add dl, 0x30		;将数字转换为对应的数字字符

mov cx, 0
mov ds, cx

mov [0x7c00+buffer], dl

xor dx, dx
div bx
add dl, 0x30
mov [0x7c00+buffer+1], dl

xor dx, dx
div bx
add dl, 0x30
mov [0x7c00+buffer+2], dl

xor dx, dx
div bx
add dl, 0x30
mov [0x7c00+buffer+3], dl

xor dx, dx
div bx
add dl, 0x30
mov [0x7c00+buffer+4], dl

mov cx, 0xb800
mov es, cx

mov al, [0x7c00+buffer+4]		;默认使用ds寄存器中的段地址
mov [es:0x00], al				;使用段超越前缀
mov byte [es:0x01], 0x2f

mov al, [0x7c00+buffer+3]		;默认使用ds寄存器中的段地址
mov [es:0x02], al				;使用段超越前缀
mov byte [es:0x03], 0x2f

mov al, [0x7c00+buffer+2]		;默认使用ds寄存器中的段地址
mov [es:0x04], al				;使用段超越前缀
mov byte [es:0x05], 0x2f

mov al, [0x7c00+buffer+1]		;默认使用ds寄存器中的段地址
mov [es:0x06], al				;使用段超越前缀
mov byte [es:0x07], 0x2f

mov al, [0x7c00+buffer+0]		;默认使用ds寄存器中的段地址
mov [es:0x08], al				;使用段超越前缀
mov byte [es:0x09], 0x2f

again:
jmp again

buffer	db 0, 0, 0, 0, 0
current:
times 510 - (current-start) db 0
db 0x55, 0xaa
```

# 11 jmp指令

## 11. 1 概述

1、jmp为无条件转移，可以只修改IP，也可以同时修改CS和IP；

2、jmp指令可以给出两种信息；

> 1、转移的目的地址
>
> 2、转移的距离（段间转移、段内短转移和段内近转移）

## 11.2 8086CPU中的jmp指令

1、CPU从何处执行指令是由CS和IP寄存器的内容决定的，我们可以通过改变CS和IP的内容来控制CPU执行目标指令。

2、8086提供了一个mov指令（传送指令），可以用来修改大部分寄存器的值，比如：

```assembly
mov ax, 10
mov bx, 20
mov cx, 30
mov dx, 40
```

3、但是，mov指令不能用于设置CS和IP的值，8086没有提供这样的功能。

4、8086提供了另外的指令来修改CS、IP的值，这些指令统称为转移指令，最简单的是jmp指令。

> 一、若想同时修改CS、IP的内容，可用形如jmp 段地址：偏移地址的指令完成，如：
>
> jmp 2AE3:3，执行后：CS=2AE3H, IP=0003H,CPU将从2AE33H处读取指令。
>
> jmp 3:0B16，执行后：CS=0003H, IP=0B16H，CPU将从00B46H处读取指令。
>
> jmp 段地址: 偏移地址指令的功能为：用指令中给出的段地址修改CS，偏移地址修改IP。
>
>
> 二、若想仅修改IP的内容，可用如形如**jmp某一合法寄存器**的指令完成，如：
>
> 1、jmp ax，指令执行前ax=1000H，CS=2000H，IP=0003H；
>
> 指令执行后：ax=1000H，CS=2000H，IP=1000H
>
> 2、jmp bx，指令执行前：bx=0B16H，CS=2000H，IP=0003H
>
> 指令执行后：bx=0B16H，CS=2000H，IP=0B16H
>
> jmp 某一合法寄存器指令的功能为：用寄存器中的值修改IP。

5、可以jmp 立即数来改变IP的值，比如jmp 0100H

## 11.3 直接用法（只能在Debug下使用的汇编指令）

jmp 段地址：偏移地址

功能：修改CS、IP的内容

例子：jmp 55BA:8

执行后：（CS)=55EAH，(IP)=0008H

## 11.4 根据标号进行转移的用法

### 11.4.1 转移的目的地址不在指令中，依据位移进行转移（段内转移）

（1）jmp short 标号（IP的修改范围为-128至127）

功能：（IP）= （IP）+ 8位移

（2）jmp near ptr 标号（IP的修改范围为-32768至32767）

功能：（IP）+ 16位位移

注：依据位移进行的转移是段内转移，位移 = 标号处的地址 - jmp指令后的第一个字节的地址。

### 11.4.2 转移的目的地址在指令中（段间转移）

jmp far ptr 标号

功能：用标号的段地址和偏移地址修改CS和IP

(CS) = 标号所在段的段地址；（IP)=标号所在段的偏移地址

## 11.5 转移地址在寄存器中

jmp 某一合法寄存器

功能：用寄存器中的值修改IP

例子：jmp ax

执行后：（IP)=(ax)

注意：合法寄存器是指通用寄存器。

## 11.6 转移地址在内存中的用法

(1)、jmp word ptr 内存单元地址（段内地址）

功能：从内存单元地址处开始存放着一个字，是转移的目的的偏移地址

例子：mov ax, 0123H

mov [0x04], ax

jmp word ptr [0x04]

执行后：（IP)=0123H

（2）、jmp dword ptr 内存单元地址（段间转移）

功能：从内存单元地址处开始存放着两个字，高地址处是转移的目的段地址，低地址处是转移的目的的偏移地址

例子：

mov ax, 0123H

mov [0x04], ax

mov word ptr [0x06], 0

jmp dword ptr [0x06]

执行后：（CS)=0 , (IP)=0123H

# 12 movsb、movsw和movsd指令

movsb movsw movsd指令，这三个指令，都是数据传送指令，都是从源地址向目的地址传送数据。

16位模式下：

源地址是DS:SI，目的地址是ES:DI

32位模式下：

源地址是DS:ESI，目的地址是ES:EDI



注意：在每次传送完成之后，SI和DI(或者ESI和EDI)会增加或者减小。



8086的标志寄存器FLAGS（16位）

* ZF（zero flag）：零标志，处理器自动设置
* DF（direction flag）：方向标志

当DF=0时，表示正向传送，传送之后SI和DI(或者ESI和EDI)的值会自动增加。

当DF=1时，表示反向传送，传送之后SI和DI(或者ESI和EDI)的值会自动减少。

cld：方向标志清零指令，表示传送方向为正方向。

std：方向标志置1指令，表示传送反向为反反向。



他们的区别是：

movsb：传送一个字节，之后SI和DI(或ESI和EDI)加/减1

movsw：传送一个字，之后SI和DI(或ESI和EDI)加/减2

movsd：传送一个字，之后SI和DI(或ESI和EDI)加/减4



单纯的movsb/movw/movsd只能执行一次，如果希望处理器自动地反复执行，可以加上前缀rep；在寄存器CX（16位模式下）或者ECX(32位模式下)中设置传送次数。当CX/ECX不等于0时，则执行movsb/movsw/movsd，执行后，CX/CEX的值减1，直到减为0为止。

```assembly
		jmp start
mytext  db 'L', 0x07, 'a', 0x07, 'b', 0x07, 'e', 0x07, 'l', 0x07, ' ', 0x07, 'o', 0x07,\
		  'f', 0x07, 'f', 0x07, 's', 0x07, 'e', 0x07, 't', 0x07, ':', 0x07
		  
start:
		mov ax, 0x7c0		;设置数据段基地址
		mov ds, ax			
		
		mov ax, 0xb800		;设置附加段基地址
		mov es, ax 	

		cld
		mov si,mytext
		mov di,0
		mov cx, (start-mytext)/2	;实际上等于13
		rep movsw
		
		jmp $
		
		times 510 - ($-$$) db 0		;$表示当前指令的汇编地址，$$表示当前程序段的起始汇编地址，nasm编译器特有
		db 0x55, 0xaa
```

# 13 db/dw/dd伪指令

## 13.1 db伪指令

db伪指令的作用：声明并初始化数据。声明数据的本质就是：在内存中占用一块空间；初始化数据的本质就是：给空间赋予一个值。

举例：db 0,0,0,0,0, 在内存中占用5个字节的空间，这5个字节的值都是0。

类似的指令还有如下指令：

* dw指令：word的意思，就是表示我们声明的每个数值占用2个字节的宽度。
* dd指令：double word的意思，就是表示我们声明的每个数值占用4个字节的宽度
* dq指令：quard word的意思，就表示我们声明的每个数值占用8个字节的宽度。

## 13.2 伪指令和指令的区别

伪指令和指令的区别就是：伪指令会指导编译器的具体行为，而指令会对应具体的CPU指令。

比如：

* mov指令会被编译器编译为对应的机器指令，作用是控制处理器，将数据传送到我们指定的位置。
* db指令会被编译器编译为对应的一些数据，作用是控制编译器，来帮助我们声明并初始化一些数据。

# 14 loop指令

* E2 8位相对偏移量

```assembly
		jmp start
mytext  db 'L', 0x07, 'a', 0x07, 'b', 0x07, 'e', 0x07, 'l', 0x07, ' ', 0x07, 'o', 0x07,\
		  'f', 0x07, 'f', 0x07, 's', 0x07, 'e', 0x07, 't', 0x07, ':', 0x07
		  
start:
		mov ax, 0x7c0		;设置数据段基地址
		mov ds, ax			
		
		mov ax, 0xb800		;设置附加段基地址
		mov es, ax 	

		cld
		mov si,mytext
		mov di,0
		mov cx, (start-mytext)/2	;实际上等于13
		rep movsw
		
		;得到标号所代表的汇编地址
		mov ax, number
		
		;分解各个数位
		mov bx, ax
		mov cx, 5	;循环次数
		mov si, 10	;除数
digit:
		xor dx, dx
		div si
		mov [bx], dl	;保存数位
		inc bx
		loop digit
		
		jmp $
		
number db 0, 0, 0, 0, 0
		
		times 510 - ($-$$) db 0		;$表示当前指令的汇编地址，$$表示当前程序段的起始汇编地址，nasm编译器特有
		db 0x55, 0xaa
```



# 15 寻址方式

mov [bx], dl

* 在8086处理器上，如果要使用寄存器来提供偏移地址，只能使用BX、SI、DI、BP，不能使用其他寄存器。所以，以下指令都是非法的：

mov [ax], dl

mov [dx], bl

* 寄存器BX在设计之初的作用之一就是用来提供数据访问的基地址，所以又叫基址寄存器（Base Address Register）
* 在设计8086处理器时，每个寄存器都有自己的特殊用途，比如AX是累加器（Accumulator），与它相关的指令还会做指令长度上的优化（较短）；CX是计数器（Counter）；DX是数据（Data）寄存器，除了作为通用寄存器使用外，还专门用于和外设之间进行数据传送；SI是源索引寄存器（Source Index）；DI是目标索引寄存器（Destination Index），用于数据传送操作，我们已经在movsb和movsw指令的用法中领略过了。

## 15.1 立即数寻址

操作数就在指令中，作为指令的一部分，跟在操作码后存放在代码段。

```assembly
mov ah, 01h
mov ax, 1204h
mov dx, mydata		;mydata是标号，编译器编译时会转换为数字
```

## 15.2 寄存器寻址

操作数在寄存器中，指令中指定寄存器号。

对于8位操作数，寄存器可以是AL，AH，BL，BH，CL，CH，DL，DH。

对于16位操作数，寄存器可以是AX，BX，CX，DX，BP，SP，SI，DI等。

```assembly
mov ah, ch
mov bx, ax
```

## 15.3 直接（内存）寻址方式

操作数在内存单元中，指令直接包含操作数的有效地址EA。

```assembly
mov ax, [1122H]	;将ds:1122的数据放在ax,默认段为DS
mov ES:[1234], al	;采用了段前缀
add word [0x0230], 0x5000
xor byte [es:mydata], 0x05
```

## 15.4 寄存器间接（基址和变址）寻址

操作数在内存单元中，操作数的**有效地址**在**SI，DI，BX，BP**这4个寄存器之一中。在不采用段前缀的情况下，对于DI，SI，BX默认段为DS，**而BP为SS**。

```assembly
mov ax, [BX]
mov AH, CS:[BX] ;采用了段前缀
mov [es:di], al

mov ax, 0x5000
mov bx, 0x7000
mov cx, 0x8000

push ax
push bx
push cx

mov bx, sp
mov dx, [ss:bx+2]

;等价于
mov bp, sp
mov dx, [bp+2]	;默认段基址为ss
```

```assembly
		;就地反转字符串内容
		jmp start
string	db 'abcdefghijklmnopqrstuvwxyz'

start:
		mov ax, 0x7c0		;设置数据段的段基地址
		mov ds, ax
		
		mov ax, cs
		mov ss, ax		;初始化栈段的段基地址
		mov sp, 0		;初始化栈顶指针
		
		mov cx, start - string	;循环次数，从26到1，共26次
		mov bx, string	;数据区首地址（基地址）
		
lppush:
		mov al, [bx]
		push ax
		inc bx
		loop lppush 	;循环压栈
		
		mov cx, start-string
		mov bx, string
		
lppop:
		pop ax
		mov [bx], al
		inc bx
		loop lppop
		
		jmp $
		
		times 510-($-$$) db 0
		db 0x55, 0xaa
```



## 15.5 寄存器相对寻址

操作数在内存单元中，操作数的有效地址是一个基址寄存器（BX，BP）或变址寄存器（SI，DI）的内容加上偏移量。

```assembly
mov ah, [BX+6]	;段基址默认为DS
```

## 15.6 基址加变址寻址

操作数在内存单元中，操作数的有效地址是一个基址寄存器（BX，BP）加上变址寄存器（SI，DI）的内容。**如果有BP，则默认段基址为SS**，否则为DS。

在8086处理器上，只允许以下几种基址变址的组合：

* bx + si
* bx + di
* bp + si
* bp + di

```assembly
mov AH, [BX+SI]
mov AX, [BX][SI]
```

```assembly
		;就地反转字符串内容
		jmp start
string	db 'abcdefghijklmnopqrstuvwxyz'

start:
		mov ax, 0x7c0		;设置数据段的段基地址
		mov ds, ax
		
		mov bx, string		;数据区首地址
		mov si, 0			;正向索引
		mov di, start-string ;反向索引
		
rever:
		mov ah, [bx+si]
		mov al, [bx+di]
		mov [bx+si], al
		mov [bx+di], ah
		inc si
		dec di
		cmp si, di
		jl rever		;首尾没有相遇，或者没有超越，则继续交换
		
		jmp $
		
		times 510-($-$$) db 0
		db 0x55, 0xaa
```



## 15.7 相对基址加变址寻址

操作数在内存单元中，操作数的有效地址是一个基址寄存器（BX，BP）和变址寄存器（SI，DI）的内容加上偏移量。**如果有BP，则默认段基址为SS**，否则为DS。

```assembly
mov ax, [BX+DI-2]
mov ax, 1234H[BX][DI]	;1234H + BX + DI
```



```assembly
		;就地反转字符串内容
		jmp start
string	db 'abcdefghijklmnopqrstuvwxyz'

start:
		mov ax, 0x7c0		;设置数据段的段基地址
		mov ds, ax
		
		mov ax, cs
		mov ss, ax		;初始化栈段的段基地址
		mov sp, 0		;初始化栈顶指针
		
		mov cx, start - string	;循环次数，从26到1，共26次
		mov bx, string	;数据区首地址（基地址）
		
lppush:
		mov al, [bx]
		push ax
		inc bx
		loop lppush 	;循环压栈
		
		mov cx, start-string
		mov bx, string
		
lppop:
		pop ax
		mov [bx], al
		inc bx
		loop lppop
		
		jmp $
		
		times 510-($-$$) db 0
		db 0x55, 0xaa
```



# 16 inc（加1）指令

**inc r/m**

加1指令INC

指令功能：目标操作数+1

* INC指令只有1个操作数，它将指定的操作数的内容加1，再将结果送回该操作数。INC指令将影响SF，AF，ZF，PF，OF标志位，**但不影响CF标志位**。
* INC指令的操作数的类型可以是通用寄存器或存储单元，但不可以是段寄存器。字或字节操作均可。
* 对于存储单元，需要byte ptr或者word ptr说明是字节还是字操作。

```assembly
inc al
inc di
inc byte [0x2002]
```

# 17 dec(减1)指令

* **dec r/m**
* **不影响CF标志位*

```assembly
dec al
dec di
dec byte [0x2002]
```

```assembly
jmp start
mytext  db 'L', 0x07, 'a', 0x07, 'b', 0x07, 'e', 0x07, 'l', 0x07, ' ', 0x07, 'o', 0x07,\
		  'f', 0x07, 'f', 0x07, 's', 0x07, 'e', 0x07, 't', 0x07, ':', 0x07
		  
start:
		mov ax, 0x7c0		;设置数据段基地址
		mov ds, ax			
		
		mov ax, 0xb800		;设置附加段基地址
		mov es, ax 	

		cld
		mov si,mytext
		mov di,0
		mov cx, (start-mytext)/2	;实际上等于13
		rep movsw
		
		;得到标号所代表的汇编地址
		mov ax, number
		
		;分解各个数位
		mov bx, ax
		mov cx, 5	;循环次数
		mov si, 10	;除数
digit:
		xor dx, dx
		div si
		mov [bx], dl	;保存数位
		inc bx
		loop digit
		
		;开始显示各个数位
		mov cx, 5
		
show:
		dec bx
		mov al, [bx]
		add al, 0x30
		mov ah, 04
		mov [es:di], ax
		add di, 2
		loop show
		
		jmp $
		
number db 0, 0, 0, 0, 0
		
		times 510 - ($-$$) db 0		;$表示当前指令的汇编地址，$$表示当前程序段的起始汇编地址，nasm编译器特有
		db 0x55, 0xaa
```

# 18 条件转移指令jns

标志寄存器FLAGS

* SF(sign flag)：算术逻辑运算结果为0则为0，为1则为1

jns 标号或8位偏移量

当执行到jns指令时，如果标志位SF=0，则跳转到指定的地址，如果SF=1，不跳转。

# 19 sub指令

sub r/m，r/m/imm

```assembly
sub al, 35
sub dx, ax
sub dx, [0x2002]
sub byte [0x2002], 37
sub byte [0x2002], al
```



# 20 neg指令（求补指令）

neg 	r/m

对操作数执行求补运算：用零减去操作数，然后结果返回操作数。也可以表达成：将操作数按位取反后加1

```assembly
neg al
neg di
neg byte [0x2002]
```

```assembly
jmp start
data1 db -1
data2 db -25
start:
		mov ax, 0x7c0
		mov ds, ax
		
		mov bl, [data1]
		neg bl
		
current:
			jmp current
times 510 - ($ - $$) db 0
db 0x55, 0xaa
```

# 21 有符号数与无符号数

* 有符号数与无符号数在计算机中都是用补码表示。

* add和sub指令操作计算机中二进制数进行运算，运算结果看做是有符号数还是无符号数取决于程序员。即add和sub指令适用于无符号数和有符号数。
* 大多数指令既适用于无符号整数，也适用于有符号整数。指令执行的结果不管是用无符号整数来解释，还是用有符号整数来解释，都是正确的。
* 但是，也有一些指令不能同时应付无符号和有符号数，需要根据你的实际情况，选择它们的无符号版本和有符号版本。比如，无符号乘法指令mul和有符号乘法指令imul，以及无符号数除法指令div和有符号数除法指令idiv。

```assembly
mov ax, 0x0400		;1024(从无符号数角度看)，+1024（从有符号数的角度看）
mov bl, 0xf0		;240(从无符号数角度看)，-16（从有符号数的角度来看）
div bl				;al=0x04（无符号数除法）

times 510-($-$$) db 0

db 0x55, 0xaa
```

# 22 有符号数除法指令idiv的用法

idiv	r/m

## 22.1 16位除法

如果在指令中指定的是8位寄存器或8位操作数的内存地址，则意味着被除数在寄存器AX里。相除后，商在寄存器AL里，余数在寄存器AH里。

```assembly
idiv bh
idiv byte [0x2002]
```

## 22.2  32位除法

如果在指令中指定的是16位寄存器或者16位操作数的内存地址，则意味着被除数是32位的，低16位在寄存器AX里；高16位在寄存器DX里。

相除后，商在寄存器AX里，余数在寄存器DX里。

```assembly
idiv bx
idiv word [0x2002]
```

## 22.3 64位除法（8086不支持，从80386开始支持）

如果在指令中指定的是32位寄存器或者32位操作数的内存地址，则意味着被除数是64位的，低32位在寄存器EAX里；高32位在寄存器EDX里。

相除后，商在寄存器EAX里，余数在寄存器EDX里。

```assembly
idiv ebx
idiv dword [0x2002]
```

## 22.4 128位除法（8086和32位处理器不支持，只有64位处理器支持）

如果在指令中指定的是64位寄存器或者64位操作数的内存地址，则意味着被除数是128位的，低64位在寄存器RAX里；高64位在寄存器RDX里。

相除后，商在寄存器RAX里，余数在寄存器RDX里。

```assembly
idiv rbx
idiv qword [0x2002]
```



**如果被除数和除数的符号相同，商为正数，否则商为负数；**

**余数的符号始终和被除数相同。**

无符号数除法：

```assembly
mov ax, 0x0400		;1024(从无符号数角度看)，+1024（从有符号数的角度看）
mov bl, 0xf0		;240(从无符号数角度看)，-16（从有符号数的角度来看）
div bl				;al=0x04（无符号数除法）

times 510-($-$$) db 0

db 0x55, 0xaa
```

有符号数除法：

```assembly
mov ax, 1024		;1024(从无符号数角度看)，+1024（从有符号数的角度看）
mov bl, -16		;240(从无符号数角度看)，-16（从有符号数的角度来看）
idiv bl				;al=0x0c（有符号数除法）

times 510-($-$$) db 0

db 0x55, 0xaa
```

# 23 有符号数的符号扩展指令

8位有符号数的范围：-128——+127

16位有符号数的范围：-32768 —— +32767

32位有符号数的范围：-2147483648 —— +2147483647

```tex
+7
0000 0111			0x07
0000 0000 0000 0111	 0x0007
0000 0000 0000 0000 0000 0000 0000 0111	0x00000007

-3		
1111 1101		0xFD(8位)
1111 1111 1111 1101		0xFFFD（16位）
1111 1111 1111 1111 1111 1111 1111 1111	0xFFFFFFFD（32位）
```

```assembly
cbx		;将AL中的有符号数扩展到AX,若AL=FD(-3)，则扩展后，AX=FFFD(-3)
cwde	;将AX中的有符号数扩展到EAX，若AX=FFFD(-3),则扩展后，EAX=FFFFFFFD(-3)
cdqe	;将EAX中的有符号数扩展到RAX，若EAX=FFFFFFFD(-3),则扩展后，RAX=FFFFFFFFFFFFFFFD(-3)

cwd		;将AX中的有符号数扩展到DX:AX,若AX=FFFD(-3)，则扩展后，DX=FFFF，AX=FFFD
cdq		;将EAX中的有符号数扩展到EDX:EAX，若EAX=FFFFFFFD(-3)，则扩展后，EDX=FFFFFFFF, EAX=FFFFFFFD
cdo		;将RAX中的有符号数扩展到RDX:RAX，若RAX=FFFFFFFFFFFFFFFD(-3)，则扩展后，RDX=FFFFFFFFFFFFFFFF，RAX=FFFFFFFFFFFFFFFD
```

```assembly
mov ax, -6002
cwd		;扩展有符号数为32位，DX:AX		
mov bx, -10		
idiv bx			

times 510-($-$$) db 0

db 0x55, 0xaa
```

# 24 总结

## 24.1 标号

* 在NASM汇编中，标号可以由以下字符组成：
  * 字母 数字 _ $ # @ ~ . ?
* 其中，可以作为打头字符的是：
  * 字母 . _ ?
* 标号后面可以放一个冒号，但它不是标号的一部分



* 在需要两个操作数的指令中，如果至少有一个是寄存器，则不需要长度修饰符。例如：

  * ```assembly
    mov ah, bl
    mov [buffer], ax
    xor byte [buffer], 0x55
    ```

* 如果只有一个操作数且不是寄存器，必须用长度修饰符。例如：

  * ```assembly
    div word [divisor]
    ```

## 24.2 伪指令定义数据

* 伪指令db用来定义字节（8位）长度的数据。例如：

  * ```assembly
    db 0x55
    ```

* 伪指令dw用来定义长度为字（16位）的数据。例如：

  * ```assembly
    dw 0x55aa
    ```

* 伪指令dd用来定义长度为双字（32位）的数据。例如：

  * ```assembly
    dd 0xabcd123
    ```

* 伪指令dq用来定义长度为四字（64位）的数据。例如：

  * ```assembly
    dq 0x12345678aabbccdd
    ```

伪指令times用来重复后面的指令若干次。例如：

```assembly
times 5 mov ax, bx
```

等价于：

```assembly
mov ax, bx
mov ax, bx
mov ax, bx
mov ax, bx
mov ax, bx
```

## 24.3 标志寄存器flag

|  15  |  14  |  13  |  12  |  11  |  10  |  9   |  8   |  7   |  6   |  5   |  4   |  3   |  2   |  1   |  0   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|      |      |      |      |  OF  |  DF  |  IF  |  TF  |  SF  |  ZF  |      |  AF  |      |  PF  |      |  CF  |

* **进位标志（Carry Flag，CF）**：当一个算术操作在结果的最高位产生进位或者借位时，此标志是1；否则是0。
  
  * 例如：
    * 若AL中的内容是二进制数1000 0000，则指令add al, al 执行后，CF=1。
  
* **奇偶标志（Parity Flag，PF）**：当一个算术操作的结果在低8位中有偶数个“1”，此标志是1；否则为0。
  
  * 例如：
    * 若AL中的内容是二进制数0010 0110，则指令 xor al， 3 执行后，PF=0。
  
* **溢出标志（Overflow Flag，OF）**：对任何一个算术操作，假定它进行的是有符号运算。那么，当结果超出目标位置所能容纳的最大正数或者最小负数时，此标志为1，表示有符号整数运算的结果已经溢出；否则为0。

  * 例如：
    * 若AH中的内容是1111 1101，则指令 add ah, 5 执行后，OF=0。
    * mov ah, 115  add ah, ah ，此指令执行后，OF=1。

* **零标志（Zero Flag，ZF）**：当运算结果为0时，此标志为1；否则为0。

  * 例如：

    * ```assembly
      mov ax, 25
      sub ax, 25		;此指令执行后，ZF=1
      ```

* **符号标志（Sign Flag，SF）**：用运算结果的最高位来设置此标志（一般来说，这一位是有符号位。0表示正数，1表示负数）。

  * 例如：

    * ```assembly
      mov ah, 127
      add ah, 1		;此指令执行后，SF=1
      ```

* **调整标志（Adjust Flag，AF）**：当一个算术操作在结果的位3产生进位或者借位时，此标志为1；否则是0。此标志用于二进制编码的十进制算法里。

  * 例如：

    * ```assembly
      mov ah, 247
      sub ah, 8		;此指令执行后，AF=1
      ```

## 24.4现有指令对标志位的影响

```assembly
cbw/cwde/cdqe/cwd/cdq/cqo		不影响任何标志位
cld			DF=0，对CF、OF、ZF、SF、AF和PF的影响未定义(对当前处理器不影响)
std			DF=1，不影响其他的标志位
inc/dec		CF标志不受影响；对OF、SF、ZF、AF和PF的影响依计算结果而定
add/sub		OF、SF、ZF、AF、CF和PF的状态依计算结果而定
div/idiv	对CF、OF、SF、ZF和PF的影响未定义
mov/movs	这类指令不影响任何标志位
neg		如果操作数为0，则CF=0，否则CF=1；对OF、SF、ZF、AF和PF的影响依结果而定
xor		OF=0，CF=0；对SF、ZF和PF依计算结果而定；对AF的影响未定义
```

## 24.5 条件转移指令

```assembly
js		符号标志SF为1则转移
jns		符号标志SF不为1（为0）则转移
jz		零标志位ZF为1则转移
jnz		零标志位ZF不为1（为0）则转移
jo		溢出标志OF为1则转移
jno		溢出标志OF不为1（为0）则转移
jc		进位标志位CF为1则转移
jnc		进位标志位CF不为1（为0）则转移
jp		奇偶标志PF为1则转移
jnp		奇偶标志PF不为1（为0）则转移
eg:
dec si
jns show
```

# 25 CMP指令

```assembly
cmp r/m, r/m/imm		;影响到CF、OF、SF、ZF、AF和PF标志位,与sub指令操作一样，但是不保留计算结果，只是根据结果来影响标志位

eg:
cmp al, 35
cmp dx, ax
cmp dx, [0x2002]
cmp byte [0x2005], 37
cmp [0x2008], ax

cmp dh, 0
jl	negb

cmp dh, 0x80
jae negb
```

## 25.1 受CMP指令影响的条件转移指令及其依赖的标志位状态

| 指令 |           英文描述           |     比较结果     |                       相关标志位的状态                       |
| :--: | :--------------------------: | :--------------: | :----------------------------------------------------------: |
|  je  |        Jump if Equal         |    **等于=**     |                相减结果为零才成立，故要求ZF=1                |
| jne  |      Jump if Not Equal       |   **不等于≠**    |               相减结果不为零才成立，故要求ZF=0               |
|  jg  |       Jump if Greater        |    **大于>**     | 适用于有符号数比较<br />要求：ZF=0（两个数不同，相减的结果不为零），并且SF=OF（如果相减后溢出，则结果必须是负数，说明目的<br />操作数大；如果相减后未溢出，则结果必须是正数，也表明目的操作数大些） |
| jge  |   Jump if Greater or Equal   |  **大于等于≥**   |            适用于有符号数的比较<br />要求：SF=OF             |
| jng  |     Jump if Not Greater      |  **小于等于≤**   | 适用于有符号数的比较<br />要求：ZF=1（两个数相同结果为零）或者SF≠OF（如果相减后溢出，则结果必须是正数，说明源操作数大；如果相减后未溢出，则结果必须是负数，同样表明源操作数大些） |
| jnge | Jump if Not Greater or Equal | **不大于等于<**  |            适用于有符号数的比较<br />要求：SF≠OF             |
|  jl  |         Jump if less         |    **小于<**     |    适用于有符号数的比较等同于不大于等于<br />要求：SF≠OF     |
| jle  |    Jump if Less or Equal     |  **小于等于≤**   | 适用于有符号数的比较，等同于“不大于”<br />要求：ZF=1（两个数相同结果为零）或者SF≠OF（如果相减后溢出，则结果必须是正数，说明源操作数大；如果相减后未溢出，则结果必须是负数，同样表明源操作数大些） |
| jnl  |       Jump if Not Less       |   **不小于≥**    |   适用于有符号数的比较，等同于“大于等于”<br />要求：SF=OF    |
| jnle |  Jump if Not Less or Equal   | **不小于等于>**  | 适用于有符号数的比较，等同于“大于”<br />要求：ZF=0（两个数不同，相减的结果不为零），并且SF=OF（如果相减后溢出，则结果必须是负数，说明目的<br />操作数大；如果相减后未溢出，则结果必须是正数，也表明目的操作数大些） |
|  ja  |        Jump if Above         |    **高于>**     | 适用于无符号数的比较<br />要求：CF=0（没有进位或借位）而且ZF=0（两个数不相等） |
| jae  |    Jump if Above or Equal    |  **高于等于≥**   | 使用于无符号数的比较<br />要求：CF=0（目的操作数大些，不需要借位） |
| jna  |      Jump if Not Above       |   **不高于≤**    | 适用于无符号数的比较，等同于“低于等于”<br />要求：CF=1或者ZF=1 |
| jnae |  Jump if Not Above or Equal  | **不高于等于＜** |       适用于无符号数的比较，等同于低于<br />要求：CF=1       |
|  jb  |        Jump if Below         |    **低于＜**    |             适用于无符号数的比较<br />要求：CF=1             |
| jbe  |    Jump if Below or Equal    |  **低于等于≤**   |         适用于无符号数的比较<br />要求：CF=1或者ZF=1         |
| jnb  |      Jump if Not Below       |   **不低于≥**    |    适用于无符号数的比较，等同于“高于等于”<br />要求：CF=0    |
| jnbe |  Jump if Not Below or Equal  | **不低于等于>**  |  适用于无符号数的比较，等同于“高于”<br />要求：CF=0而且ZF=0  |
| jpe  |     Jump if Parity Even      |   **校验为偶**   |                          要求：PF=1                          |
| jpo  |      Jump if Parity Odd      |   **校验为奇**   |                          要求：PF=0                          |

## 25.2 jcxz指令

jcxz（jump if CX is zero）：意思是当CX寄存器的内容为零时则转移。执行这条指令时，处理器先测试寄存器CX是否为零。

例如：

```assembly
jcxz show		;若CX寄存器中的内容等于0则跳转至show标号处
```

```assembly
		;从1加到100并显示累加结果
		jmp start
message db '1+2+3+...+100='		;等同于 db '1', '+', '2', '+', '3', .....
	
start:
		mov ax, 0x7c0		;设置数据段的段基址
		mov ds, ax
			
		mov ax, 0xb800		;设置附加段基址到显示缓冲区
		mov es, ax
			
		;以下显示字符串
		mov si, message
		mov di, 0
		mov cx, start-message
			
showmsg:
		mov al, [si]
		mov [es:di], al
		inc di
		inc si
		loop showmsg
		
		;以下计算1到100的和
		xor ax, ax		;用AX存放累加结果
		mov cx, 1
summate:
		add ax, cx
		inc cx
		cmp cx, 100
		jle summate
		
		jmp $
		
		times 510-($-$$) db 0
		db 0x55, 0xaa
```

## 25.3 cmps（Compare String Operands）

对比字符串的过程，可以使用cmps指令。该指令有3种基本的形式，分别用于字节、字和双字的比较：

```assembly
cmpsb	;字节比较
cmpsw	;字比较
cmpsd	;双字比较
```

单纯的cmps指令只比较一次，所以需要加指令前缀rep使比较连续进行。但rep指令不能控制比较的停止点，所以针对cmps指令，应当使用repe(repz)和repne(repnz)前缀，前者的意思是“若相等则重复比较”，后者的意思是“若不相等（非零）则重复。

# 26 栈的原理与使用

```assembly
; push r/m
push dx
push word [0x2002]

 ; pop r/m
 pop ax
 pop word [0x08]
```

* SS：栈段基址寄存器
* SP：栈顶指针寄存器
* 栈里数据从高地址往低地址存入数据
* 例如：在8086处理器上，初始化SS=SP=0，则压栈时，SP = （SP-2）= 0xFFFE，于是第一次压栈的数据的物理地址=SS<<4 + SP = 0xFFFE

![](G:\images\Linux\image-20220708112908045.png)

**push （进栈）的执行过程：**

* SP<—— SP - 操作数的大小（字节数）；
* 段寄存器SS左移4位，加上SP里的偏移地址，生成物理地址；
* 将操作数写入上述地址处

**pop（出栈）的执行过程：**

* 段寄存器SS左移4位，加上SP里的偏移地址，生成物理地址；
* 从上述的地址处取得数据，存入由操作数提供的目标位置处；
* SP <—— SP + 2（在8086处理器中入栈和压栈的数据只能是16位的数据）

```assembly
mov ax, 25
mov bx, 30
mov cx, 35

push ax		;SS=0x256A，SP=0x0200
push bx		;SP=0x01FE（0x0200 - 0x02）
push cx		;SP=0x01FC（0x01FE - 0x02）

pop dx
pop si
pop di

push cs
pop ds

;等价于
mov ax, cs
mov ds, ax

push ax

;等价于
sub sp, 2
mov bx, sp
mov [ss:bx], ax

pop ax

;等价于
mov bx, sp
mov ax, [ss:bx]
add sp, 2

push word [es:code_2_segment]
```

```assembly
;从1加到100并显示累加结果
		jmp start
message db '1+2+3+...+100 = '		;等同于 db '1', '+', '2', '+', '3', .....
	
start:
		mov ax, 0x7c0		;设置数据段的段基址
		mov ds, ax
			
		mov ax, 0xb800		;设置附加段基址到显示缓冲区
		mov es, ax
			
		;以下显示字符串
		mov si, message
		mov di, 0
		mov cx, start-message
			
showmsg:
		mov al, [si]
		mov [es:di], al
		inc di
		mov byte [es:di], 0x07
		inc di
		inc si
		loop showmsg
		
		;以下计算1到100的和
		xor ax, ax		;用AX存放累加结果
		mov cx, 1
summate:
		add ax, cx
		inc cx
		cmp cx, 100
		jle summate
		
		;以下分解累加和的每个数位
		xor cx, cx
		mov ss, cx
		mov sp, cx
		
		mov bx, 10
		xor cx, cx
		
decompo:
		inc cx
		xor dx, dx
		div bx
		add dl, 0x30
		push dx
		cmp ax, 0
		jne decompo
		
		
		;以下显示各个数位
shownum:
		pop dx
		mov [es:di], dl
		inc di
		mov byte [es:di], 0x07
		inc di
		loop shownum
		
		jmp $
		
		times 510-($-$$) db 0
		db 0x55, 0xaa
```



# 27 or（逻辑或）指令

```assembly
or r/m, r/m/imm		;按位进行或运算

or bh, al
or cx, dx
or ax, 3
or word [0x2002], 67
or si, [0x2002]
```

**逻辑或指令or执行后，**

**CF=0，OF=0；**

**SF、ZF和PF依计算结果而定；AF的状态未定义。**

# 28 and（逻辑与）指令

```assembly
and r/m, r/m/imm	;按位进行与运算

and bh, al
and cx, dx
and ax, 3
and word [0x2002], 67
and si, [0x2002]
```

# 29 给汇编语言程序分段

* section 段名称：分段标识
* align=数值：指定对其字节数，默认是4字节对齐
* vstart=地址：汇编地址是相对于程序开头的偏移量。而通常情况下所有标号等于偏移地址。指定了vstart使得标号代表的是相对于本段内的偏移量加上指定的vstart值

```assembly
SECTION data1 ALIGN=16 VSTART=0
mydata dw 0xFACE

SECTION data2 ALIGN=16 VSTART=0x100
string db 'hello'

section code ALIGN=16 VSTART=0
		mov bx, mydata
		mov si, string
```

```assembly
section s1
offset dw str1, str2, num		;str1=0x100	str2=0x105	num=0x20

section s2 align=16 vstart=0x100
str1 db 'hello'
str2 db 'world'

section s3 align=16
num dw 0xbad
```

# 30 加载器和用户程序头部段

![image-20220709111345265](G:\images\Linux\image-20220709111345265.png)

![image-20220709112312585](C:\Users\pc\AppData\Roaming\Typora\typora-user-images\image-20220709112312585.png)

```assembly
SECTION header vstart=0		;用户程序头部段
	program_length dd program_end	;程序总长度[0x00]
	
	;用户程序入口点
	code_entry		dw start	;偏移地址[0x04]
					dd section.code.start	;段地址[0x06]
	
	realloc_tbl_len	dw (segtbl_end-segtbl_begin)/4		;段重定位表项个数[0x0A]
	
	;段重定位表
	segtbl_begin:
	code_segment	dd section.code.start		;[0x0C]
	data_segment	dd secton.data.start		;[0x10]
	stack_segment	dd section.stack.start		;[0x14]
	segtbl_end;
```

## 30.1 加载器的工作流程

* 读取用户程序的起始扇区
* 把整个用户程序都读入内存
* 计算段的物理地址和逻辑段地址（段的重定位）
* 转移到用户程序执行（将处理器的控制权交给用户程序）。

用户程序从逻辑扇区100开始存放

![image-20220709150944693](G:\images\Linux\image-20220709150944693.png)

## 30.2 确定用户程序的加载地址，并转换为逻辑段地址

在加载程序中，即主引导程序中，phy_base标号处用两个字存储着加载用户程序的物理地址。之所以用两个字存储，是因为8086处理器对应的的内存大小为1MB，需要20根地址线进行寻址。这里需要将物理地址转换为逻辑段地址，方便处理器寻址。

```assembly
;计算用于加载用户程序的逻辑段地址,phy_base标号处用两个字的长度存储了加载用户程序的物理地址，需要转换为逻辑段地址
         mov ax,[cs:phy_base]             
         mov dx,[cs:phy_base+0x02]
         mov bx,16 						;除以16，转换为逻辑段地址，方便存储在段寄存器中       
         div bx            
         mov ds,ax                       ;令DS和ES指向该段以进行操作
         mov es,ax  
         
;......

-------------------------------------------------------------------------------
         phy_base dd 0x10000             ;用户程序被加载的物理起始地址
         
 times 510-($-$$) db 0
                  db 0x55,0xaa
```



![image-20220709153530347](G:\images\Linux\image-20220709153530347.png)

![image-20220709152523199](G:\images\Linux\image-20220709152523199.png)

## 30.3 加载硬盘中用户程序所在的第一个扇区数据（头部信息）

```assembly
app_lba_start equ 100           ;声明常数（用户程序起始逻辑扇区号）
                                         ;常数的声明不会占用汇编地址
                                      
;以下读取程序的起始部分 
xor di,di						 ;di:si = 用户程序在硬盘的存储起始扇区
mov si,app_lba_start            ;程序在硬盘上的起始逻辑扇区号 
xor bx,bx                       ;加载到DS:0x0000处 
call read_hard_disk_0

;......

read_hard_disk_0:                        ;从硬盘读取一个逻辑扇区
                                         ;输入：DI:SI=起始逻辑扇区号
                                         ;      DS:BX=目标缓冲区地址
         push ax						;保存调用前的环境，以方便恢复
         push bx
         push cx
         push dx
      
         mov dx,0x1f2
         mov al,1
         out dx,al                       ;读取的扇区数
		;传送扇区号和读取模式以及硬盘
         inc dx                          ;0x1f3
         mov ax,si
         out dx,al                       ;LBA地址7~0

         inc dx                          ;0x1f4
         mov al,ah
         out dx,al                       ;LBA地址15~8

         inc dx                          ;0x1f5
         mov ax,di
         out dx,al                       ;LBA地址23~16

         inc dx                          ;0x1f6
         mov al,0xe0                     ;LBA28模式，主盘
         or al,ah                        ;LBA地址27~24
         out dx,al
		;传送读数据命令
         inc dx                          ;0x1f7
         mov al,0x20                     ;读命令
         out dx,al
  ;等待硬盘准备数据
  .waits:
         in al,dx
         and al,0x88
         cmp al,0x08
         jnz .waits                      ;不忙，且硬盘已准备好数据传输 

         mov cx,256                      ;总共要读取的字数
         mov dx,0x1f0
  .readw:
         in ax,dx
         mov [bx],ax
         add bx,2
         loop .readw

         pop dx							;恢复调用前的工作环境
         pop cx
         pop bx
         pop ax
      
         ret
```

## 30.4 加载整个用户程序

![image-20220709204717029](G:\images\Linux\image-20220709204717029.png)

在8086处理器的环境下，每个段的最大空间是64KB，当程序的空间大于64KB时，随着偏移地址的增加，硬盘加载的数据会覆盖掉段首数据。因此每加载一个扇区，就新开辟一个新段，用于存储该扇区数据。即数据段寄存器DS+0x20(512)。如下图所示：

![image-20220709211203658](G:\images\Linux\image-20220709211203658.png)



```assembly
;以下判断整个程序有多大
         mov dx,[2]                      ;曾经把dx写成了ds，花了二十分钟排错 
         mov ax,[0]
         mov bx,512                      ;512字节每扇区
         div bx
         cmp dx,0						
         jnz @1                          ;未除尽，因此结果比实际扇区数少1，但第一扇区已经被读取，因此ax里是真实剩余扇区数
         dec ax                          ;已经读了一个扇区，扇区总数减1 
   @1:
         cmp ax,0                        ;考虑实际长度小于等于512个字节的情况 
         jz direct
         
         ;读取剩余的扇区
         push ds                         ;以下要用到并改变DS寄存器 

         mov cx,ax                       ;循环次数（剩余扇区数）
   @2:
         mov ax,ds
         add ax,0x20                     ;得到下一个以512字节为边界的段地址
         mov ds,ax  
                              
         xor bx,bx                       ;每次读时，偏移地址始终为0x0000 
         inc si                          ;下一个逻辑扇区 
         call read_hard_disk_0
         loop @2                         ;循环读，直到读完整个功能程序 

         pop ds                          ;恢复数据段基址到用户程序头部段 
```

## 30.5 用户程序的重定位并跳转至用户程序起始点开始执行

![image-20220710145004041](G:\linux系统编程\image-20220710145004041.png)

在用户程序头部保存了程序入口段的段起始汇编地址，和入口指令的段内偏移地址。以及各个段的起始汇编地址。汇编地址是指该段地址距离用户程序起始点的偏移量。汇编地址是用32位双字存储的，加上加载用户程序的物理地址，便是该段的物理地址，然后将物理地址转为逻辑地址，即左移4位（除以16）。得到逻辑地址（16位）后，再把逻辑地址写回用户程序头部。但8086处理器不支持32位加法，因此需要用到**adc指令**，具体方法如下：

* 先用add指令进行低16位的加法，add指令会影响CF标志位，如果产生进位，则CF=1
* 再用adc指令进行高16位的加法，adc指令会自动加上标志位CF

![image-20220710153609521](G:\images\Linux\image-20220710153609521.png)

**先转换用户程序入口段的汇编地址：**

```assembly
direct:
         mov dx,[0x08]
         mov ax,[0x06]					 ;取得用户程序入口段的汇编地址，dx:ax
         call calc_segment_base
         mov [0x06],ax                   ;回填修正后的入口点代码段基址
         

calc_segment_base:                       ;计算16位段地址
                                         ;输入：DX:AX=32位物理地址
                                         ;返回：AX=16位段基地址 
         push dx                          
         
         add ax,[cs:phy_base]
         adc dx,[cs:phy_base+0x02]
         shr ax,4
         ror dx,4
         and dx,0xf000
         or ax,dx
         
         pop dx
         
         ret
```

**再转换段重定位表中各个段的汇编地址：**

```assembly
    
         ;开始处理段重定位表
         mov cx,[0x0a]                   ;需要重定位的项目数量
         mov bx,0x0c                     ;重定位表首地址
          
 realloc:
         mov dx,[bx+0x02]                ;32位地址的高16位 
         mov ax,[bx]
         call calc_segment_base
         mov [bx],ax                     ;回填段的基址
         add bx,4                        ;下一个重定位项（每项占4个字节） 
         loop realloc 
      
         jmp far [0x04]                  ;转移到用户程序  
```

## 30.6 加载器完整代码

```assembly
         ;代码清单8-1
         ;文件名：c08_mbr.asm
         ;文件说明：硬盘主引导扇区代码（加载程序） 
         ;创建日期：2011-5-5 18:17
         
         app_lba_start equ 100           ;声明常数（用户程序起始逻辑扇区号）
                                         ;常数的声明不会占用汇编地址
                                    
SECTION mbr align=16 vstart=0x7c00	;cs=0,ip起始=0x7c00，这里使得段偏移地址等于汇编地址                                     

         ;设置堆栈段和栈指针 
         mov ax,0      
         mov ss,ax
         mov sp,ax						;cs=0,ss=0,sp=0，栈段与代码段为同一个段，大小为64KB(0x0 - 0xFFFF)，栈数据从0xFFFF开始往下存数据，主引导代码从0x7c00开始存代码
        
		;计算用于加载用户程序的逻辑段地址,phy_base标号处用两个字的长度存储了加载用户程序的物理地址，需要转换为逻辑段地址
         mov ax,[cs:phy_base]             
         mov dx,[cs:phy_base+0x02]
         mov bx,16     					;除以16，转换为逻辑段地址，方便存储在段寄存器中   
         div bx            
         mov ds,ax                       ;令DS和ES指向该段以进行操作
         mov es,ax                        
    
         ;以下读取程序的起始部分 
         xor di,di						 ;di:si = 用户程序在硬盘的存储起始扇区
         mov si,app_lba_start            ;程序在硬盘上的起始逻辑扇区号 
         xor bx,bx                       ;加载到DS:0x0000处 
         call read_hard_disk_0
      
         ;以下判断整个程序有多大
         mov dx,[2]                      ;曾经把dx写成了ds，花了二十分钟排错 
         mov ax,[0]
         mov bx,512                      ;512字节每扇区
         div bx
         cmp dx,0						
         jnz @1                          ;未除尽，因此结果比实际扇区数少1，但第一扇区已经被读取，因此ax里是真实剩余扇区数
         dec ax                          ;已经读了一个扇区，扇区总数减1 
   @1:
         cmp ax,0                        ;考虑实际长度小于等于512个字节的情况 
         jz direct
         
         ;读取剩余的扇区
         push ds                         ;以下要用到并改变DS寄存器 

         mov cx,ax                       ;循环次数（剩余扇区数）
   @2:
         mov ax,ds
         add ax,0x20                     ;得到下一个以512字节为边界的段地址
         mov ds,ax  
                              
         xor bx,bx                       ;每次读时，偏移地址始终为0x0000 
         inc si                          ;下一个逻辑扇区 
         call read_hard_disk_0
         loop @2                         ;循环读，直到读完整个功能程序 

         pop ds                          ;恢复数据段基址到用户程序头部段 
      
         ;计算入口点代码段基址 
   direct:
         mov dx,[0x08]
         mov ax,[0x06]					 ;取得用户程序入口段的汇编地址，dx:ax
         call calc_segment_base
         mov [0x06],ax                   ;回填修正后的入口点代码段基址 
      
         ;开始处理段重定位表
         mov cx,[0x0a]                   ;需要重定位的项目数量
         mov bx,0x0c                     ;重定位表首地址
          
 realloc:
         mov dx,[bx+0x02]                ;32位地址的高16位 
         mov ax,[bx]
         call calc_segment_base
         mov [bx],ax                     ;回填段的基址
         add bx,4                        ;下一个重定位项（每项占4个字节） 
         loop realloc 
      
         jmp far [0x04]                  ;转移到用户程序  
 
;-------------------------------------------------------------------------------
read_hard_disk_0:                        ;从硬盘读取一个逻辑扇区
                                         ;输入：DI:SI=起始逻辑扇区号
                                         ;      DS:BX=目标缓冲区地址
         push ax						;保存调用前的环境，以方便恢复
         push bx
         push cx
         push dx
      
         mov dx,0x1f2
         mov al,1
         out dx,al                       ;读取的扇区数
		;传送扇区号和读取模式以及硬盘
         inc dx                          ;0x1f3
         mov ax,si
         out dx,al                       ;LBA地址7~0

         inc dx                          ;0x1f4
         mov al,ah
         out dx,al                       ;LBA地址15~8

         inc dx                          ;0x1f5
         mov ax,di
         out dx,al                       ;LBA地址23~16

         inc dx                          ;0x1f6
         mov al,0xe0                     ;LBA28模式，主盘
         or al,ah                        ;LBA地址27~24
         out dx,al
		;传送读数据命令
         inc dx                          ;0x1f7
         mov al,0x20                     ;读命令
         out dx,al
  ;等待硬盘准备数据
  .waits:
         in al,dx
         and al,0x88
         cmp al,0x08
         jnz .waits                      ;不忙，且硬盘已准备好数据传输 

         mov cx,256                      ;总共要读取的字数
         mov dx,0x1f0
  .readw:
         in ax,dx
         mov [bx],ax
         add bx,2
         loop .readw

         pop dx							;恢复调用前的工作环境
         pop cx
         pop bx
         pop ax
      
         ret

;-------------------------------------------------------------------------------
calc_segment_base:                       ;计算16位段地址
                                         ;输入：DX:AX=32位物理地址
                                         ;返回：AX=16位段基地址 
         push dx                          
         
         add ax,[cs:phy_base]
         adc dx,[cs:phy_base+0x02]
         shr ax,4
         ror dx,4
         and dx,0xf000
         or ax,dx
         
         pop dx
         
         ret

;-------------------------------------------------------------------------------
         phy_base dd 0x10000             ;用户程序被加载的物理起始地址
         
 times 510-($-$$) db 0
                  db 0x55,0xaa
```

# 31 外围设备及其接口

![image-20220709154914165](G:\images\Linux\image-20220709154914165.png)

![image-20220709161143343](G:\images\Linux\image-20220709161143343.png)

![image-20220709161419259](G:\images\Linux\image-20220709161419259.png)

## 31 输入输出端口的访问

端口：本质上是I/O接口中的寄存器，每个端口都有自己的数据宽度，和自己的端口号。对于每个I/O设备的接口都有可能有多个端口，分别用于传送不同的数据。

![image-20220709161932312](G:\images\Linux\image-20220709161932312.png)

## 31.1 访问端口的指令

### 31.1.2 in指令获取端口数据

```assembly
;in指令不影响标志位
in al, dx		;dx中存放端口号，目的操作数的长度取决于访问端口的长度
in ax, dx		;在8086处理器中，in指令的目的操作数必须是ax或al寄存器

in al, imm8
in ax, imm8		;当端口号小于256时，源操作数可以是8位数字

eg:
	in al, 0x60
	in ax, 0xa7

eg:
	mov dx, 0x3c0
	in ax, dx
```

### 31.1.3 out指令向端口发送数据

```assembly
;out指令不影响标志位
out dx/imm8, al/ax

eg:
	out 0x60, al
	out 0xa7, ax
	
	mov dx, 0x3c0
	out dx, ax
```

# 32 通过硬盘控制器端口读扇区数据

硬盘数据的读取以扇区为单位，也就是说，每次读取至少一个扇区。因此硬盘属于块（Block）设备。

CHS模式（Cylinder.Header.Sector）

LBA模式（Logical Block Addressing）LBA28表示采用28个比特来表示扇区号

在个人计算机上硬盘被分配了7个8位的端口，1个16位端口，端口号从1f0至1f7，其中1f0位16位端口，用来传送硬盘数据。

**第一步：把需要读取的扇区数传送到0x1f2端口**

```assembly
mov dx, 0x1f2		;将端口号送入dx寄存器
mov al, 0x01		;将需要扇区数量送入al寄存器，注意0x00表示扇区数量为256
out dx, al
```

**第二步：设置起始的扇区号（28位），这里假定起始扇区号为0x02**

由于扇区号是8位的，接收不了28位的扇区号，因此，需要把扇区号切分分发至不同的端口，从高位至低位共28位，被切分成4，8，8，8分别传送给**1f6、1f5、1f4和1f3端口**。对于1f6端口，其高四位用于确定读取模式和硬盘，在8086处理器的环境下，可以有两个硬盘，主硬盘(0)和从硬盘(1)，两种读取模式CHS（0）和LBA（1）模式，其它两位置1。

![image-20220709172427632](G:\images\Linux\image-20220709172427632.png)

```assembly
mov dx, 0x1f3
mov al, 0x02
out dx, al		;LBA地址7~0，从低位计数，即低8位

inc dx			;0x1f4
mov al, 0x00
out	dx,	al		;LBA地址15~8

inc dx			;0x1f5
out dx, al		;LBA地址23~16

inc dx			;0x1f6
mov al 0xe0		;LBA模式，主硬盘，以及LBA地址27~24
out dx, al
```

**第三步：发送读命令(0x20)到0x1f7端口（命令端口和状态端口）**

```assembly
mov dx, 0x1f7
mov al, 0x20		;读命令
out dx, al
```



**第四步：等待硬盘读写准备，监测0x1f7端口，获取硬盘状态，当0x1f7端口位7为0，位3为1，表示已经准备好了传送数据**

![image-20220709190046855](G:\images\Linux\image-20220709190046855.png)

```assembly
mov dx, 0x1f7
.waits:
	in al, dx
	and al, 0x88
	cmp al, 0x08
	jnz .waits
```

**第五步：从0x1f0端口读取数据**

```assembly
;假定DS已指向存放扇区数据的段，BX里是段内偏移地址
mov cx, 256	;总共读取的字数
mov dx, 0x1f0

.readw:
	in ax, dx
	mov [bx], ax
	add bx, 2
	loop .readw
```

# 33 过程和过程调用

![image-20220709193355281](G:\images\Linux\image-20220709193355281.png)

过程调用过程中，需要保存调用前的工作环境，过程结束时恢复环境。

例如：

```assembly
push ax						;保存调用前的环境，以方便恢复
push bx
push cx
push dx
;......

pop dx						;恢复调用前的工作环境
pop cx
pop bx
pop ax
```

以下是从硬盘读取1扇区数据的过程：

```assembly
read_hard_disk_0:                        ;从硬盘读取一个逻辑扇区
                                         ;输入：DI:SI=起始逻辑扇区号
                                         ;      DS:BX=目标缓冲区地址
         push ax						;保存调用前的环境，以方便恢复
         push bx
         push cx
         push dx
      
         mov dx,0x1f2
         mov al,1
         out dx,al                       ;读取的扇区数
		;传送扇区号和读取模式以及硬盘
         inc dx                          ;0x1f3
         mov ax,si
         out dx,al                       ;LBA地址7~0

         inc dx                          ;0x1f4
         mov al,ah
         out dx,al                       ;LBA地址15~8

         inc dx                          ;0x1f5
         mov ax,di
         out dx,al                       ;LBA地址23~16

         inc dx                          ;0x1f6
         mov al,0xe0                     ;LBA28模式，主盘
         or al,ah                        ;LBA地址27~24
         out dx,al
		;传送读数据命令
         inc dx                          ;0x1f7
         mov al,0x20                     ;读命令
         out dx,al
  ;等待硬盘准备数据
  .waits:
         in al,dx
         and al,0x88
         cmp al,0x08
         jnz .waits                      ;不忙，且硬盘已准备好数据传输 

         mov cx,256                      ;总共要读取的字数
         mov dx,0x1f0
  .readw:
         in ax,dx
         mov [bx],ax
         add bx,2
         loop .readw

         pop dx							;恢复调用前的工作环境
         pop cx
         pop bx
         pop ax
      
         ret
```

## 33.1 过程调用和返回的原理

```assembly
;16位相对近调用，即调用的位置位于当前代码段内
;call 标号
;机器码：0xE8 16位相对偏移量
```

当程序执行call指令的同时，IP的数值自动更新为下一条指令的偏移量，即call指令的下一条指令。执行call指令后，首先将IP的内容进行压栈，即过程返回后执行的第一条指令的偏移地址，然后再改计算出过程的偏移地址，并赋予IP。

ret指令用于返回至过程调用处的下一条指令，其本质是从栈中弹出一个字（进入过程之前保存的偏移地址），赋予IP寄存器。

![image-20220709203936640](G:\images\Linux\image-20220709203936640.png)

## 33.2 过程调用方式

### 33.2.1 16位相对近调用

> call 标号或目标处的汇编地址		；编译时会自动转换为16位偏移量，E8 16位偏移量

```assembly
call dest
```

### 32.2.2 16位间接绝对近调用

> call r/m		;内存地址或寄存器中保存着目标地址的段内偏移地址，先把源地址压栈保护，然后把目标地址的段内偏移地址赋予IP

```assembly
call cx
call [0x3000]
call [bx]
```

### 32.2.3 16位直接绝对远调用

> call 16位段地址：16位偏移地址		;先将CS的内容压栈，再将IP的内容压栈

```assembly
call 0x052e:0x003c
```

### 32.2.3 16位间接绝对远调用

> call far m			；低16位为段内偏移地址高16位为CS基址

```assembly
call far [0x2000]
call far [bx]
```

## 32.3 返回方式

### 32.3.1 近调用过程的返回方式

> **用call调用过程，若压入栈的是IP，在过程内部用ret返回。**

### 32.3.2 远调用过程的返回方式

> **用call far调用过程，压入的是CS和IP；在过程内部用retf返回。**

# 34 逻辑右移指令shr与逻辑左移指令shl

## 34.1 shr

```assembly
;最后一位被挤出的比特赋予CF标志位
shr r/m, imm8
shr r/m, cl

shr ax, 4
```

![image-20220710145639887](G:\images\Linux\image-20220710145639887.png)

## 34.2 shl

# 35 循环右移指令ror和循环左移指令rol

## 35.1 循环右移指令ror

```assembly
ror r/m, imm8
ror r/m, cl
```

![image-20220710153340494](G:\images\Linux\image-20220710153340494.png)
